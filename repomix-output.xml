This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
android/
  app/
    google-services.json
app/
  (tabs)/
    chat/
      index.tsx
    connections/
      index.tsx
    map/
      index.tsx
    profile/
      index.tsx
    _layout.tsx
    index.tsx
  auth/
    _layout.tsx
    login.tsx
  chat/
    [id].tsx
  map/
    index.tsx
  _layout.tsx
  +html.tsx
  +not-found.tsx
  complete-profile.tsx
  edit-profile.tsx
  index.tsx
  modal.tsx
  settings.tsx
  user-profile.tsx
assets/
  images/
    default-avatar.svg
components/
  __tests__/
    StyledText-test.js
  maps/
    EnhancedUserMapMarker.tsx
    FilterDrawer.tsx
    MarkerSpiderfier.tsx
    ProfileCard.tsx
    UserMapMarker.tsx
  navigation/
    FloatingTabBar.tsx
    ModernTabBar.tsx
    ModernTabBarIcon.tsx
    PreciseTabBar.tsx
    README.md
  screens/
    LoadingScreen.tsx
  EditScreenInfo.tsx
  ExternalLink.tsx
  StyledText.tsx
  Themed.tsx
  useClientOnlyValue.ts
  useClientOnlyValue.web.ts
  useColorScheme.ts
  useColorScheme.web.ts
config/
  firebase.js
constants/
  Colors.ts
contexts/
  AuthContext.tsx
  useProtectedRoute.js
  useProtectedRoute.tsx
ios/
  GoogleService-Info.plist
utils/
  geospatial.ts
  presence.ts
.gitignore
app.json
MAP_SCREEN_UPDATE.md
metro.config.js
package.json
tsconfig.json
UI_IMPROVEMENTS.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="android/app/google-services.json">
{
  "project_info": {
    "project_number": "224390534339",
    "project_id": "hivesocial-75456",
    "storage_bucket": "hivesocial-75456.firebasestorage.app"
  },
  "client": [
    {
      "client_info": {
        "mobilesdk_app_id": "1:224390534339:android:2df441d00697ee7165fe76",
        "android_client_info": {
          "package_name": "com.romanabad.hivesocial"
        }
      },
      "oauth_client": [],
      "api_key": [
        {
          "current_key": "AIzaSyCDA03q2JGfIIn8OHymsAgVaUXOgypaYOM"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": []
        }
      }
    }
  ],
  "configuration_version": "1"
}
</file>

<file path="app/auth/_layout.tsx">
import React, { useEffect } from 'react';
import { Stack, useRouter } from 'expo-router';
import { useAuth } from '@/contexts/AuthContext';
import LoadingScreen from '@/components/screens/LoadingScreen';

export default function AuthLayout() {
  const { user, loading } = useAuth();
  const router = useRouter();
  
  // Log for debugging
  console.log('Auth layout rendered, user:', user ? 'Authenticated' : 'Not authenticated', 'loading:', loading);
  
  // Redirect authenticated users away from auth screens
  useEffect(() => {
    if (!loading && user) {
      console.log('Auth layout detected authenticated user, redirecting to home...');
      router.replace('/');
    }
  }, [user, loading, router]);
  
  // If we're still loading and no determination has been made, show loading screen
  if (loading) {
    return <LoadingScreen message="Checking authentication..." />;
  }
  
  // If the user is authenticated, we're in the process of redirecting
  // Don't render anything to avoid flicker
  if (user) {
    return <LoadingScreen message="Redirecting to app..." />;
  }
  
  return (
    <Stack
      screenOptions={{
        headerShown: false,
        animation: 'slide_from_right',
      }}
    />
  );
}
</file>

<file path="app/auth/login.tsx">
import React, { useState, useEffect } from 'react';
import { StyleSheet, View, Text, TextInput, TouchableOpacity, KeyboardAvoidingView, Platform, ScrollView, Alert, ActivityIndicator } from 'react-native';
import { Stack, router } from 'expo-router';
import FontAwesome from '@expo/vector-icons/FontAwesome';
import { createUserWithEmailAndPassword, signInWithEmailAndPassword } from '@firebase/auth';
import { doc, setDoc, serverTimestamp } from '@firebase/firestore';
import { auth, db } from '../../config/firebase';
import { useAuth } from '@/contexts/AuthContext';
import LoadingScreen from '@/components/screens/LoadingScreen';

export default function LoginScreen() {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [isLogin, setIsLogin] = useState(true);
  const [loading, setLoading] = useState(false);
  const { user, loading: authLoading } = useAuth();
  
  // Check if user is already authenticated and redirect if needed
  useEffect(() => {
    if (user) {
      console.log('Login screen: User already authenticated, redirecting to home...');
      router.replace('/');
    }
  }, [user]);
  
  // Show loading screen while checking auth state
  if (authLoading) {
    return <LoadingScreen message="Checking authentication..." />;
  }
  
  // If the user is authenticated, we're in the process of redirecting
  // Don't render anything to avoid flicker
  if (user) {
    return <LoadingScreen message="Redirecting to app..." />;
  }

  const handleAuth = async () => {
    // Validation
    if (!email || !password) {
      Alert.alert('Error', 'Please enter both email and password');
      return;
    }
    
    if (password.length < 6) {
      Alert.alert('Error', 'Password should be at least 6 characters');
      return;
    }
    
    // Set loading state
    setLoading(true);
    
    try {
      // Handle either sign in or sign up
      if (isLogin) {
        // Sign in
        await signInWithEmailAndPassword(auth, email, password);
        console.log('User signed in successfully');
      } else {
        // Sign up
        const userCredential = await createUserWithEmailAndPassword(auth, email, password);
        const user = userCredential.user;
        
        // Create user document in Firestore
        await setDoc(doc(db, 'users', user.uid), {
          email: user.email,
          uid: user.uid,
          createdAt: serverTimestamp(),
          name: '',
          bio: '',
          interests: [],
          location: {
            visible: true
          },
          photoURL: ''
        });
        
        console.log('User account created successfully');
      }
      
      // Authentication successful, use router navigation
      console.log('User signed in successfully, navigating to tabs...');
      
      setLoading(false); // Make sure to turn off loading state

      // Use expo-router to navigate
      console.log('Executing navigation to /(tabs)');
      try {
        router.replace('/');
      } catch (e) {
        console.error('Navigation error:', e);
      }
    } catch (error) {
      // Handle specific error cases
      let errorMessage = 'An error occurred. Please try again.';
      
      switch(error.code) {
        case 'auth/invalid-email':
          errorMessage = 'The email address is not valid.';
          break;
        case 'auth/user-disabled':
          errorMessage = 'This user account has been disabled.';
          break;
        case 'auth/user-not-found':
          errorMessage = 'No user found with this email address.';
          break;
        case 'auth/wrong-password':
          errorMessage = 'Incorrect password.';
          break;
        case 'auth/email-already-in-use':
          errorMessage = 'This email is already registered.';
          break;
        case 'auth/weak-password':
          errorMessage = 'The password is too weak.';
          break;
        case 'auth/network-request-failed':
          errorMessage = 'Network error. Please check your connection.';
          break;
        default:
          console.error('Firebase auth error:', error);
      }
      
      Alert.alert('Authentication Error', errorMessage);
    } finally {
      setLoading(false);
    }
  };

  return (
    <KeyboardAvoidingView 
      style={styles.container}
      behavior={Platform.OS === 'ios' ? 'padding' : null}
      keyboardVerticalOffset={60}
    >
      <Stack.Screen options={{ title: '', headerShown: false }} />
      
      <ScrollView contentContainerStyle={styles.scrollContent}>
        <View style={styles.headerContainer}>
          <FontAwesome name="connectdevelop" size={80} color="#007bff" />
          <Text style={styles.appName}>HiveSocial</Text>
          <Text style={styles.tagline}>Connect with nearby people who share your interests</Text>
        </View>
        
        <View style={styles.formContainer}>
          <Text style={styles.formTitle}>{isLogin ? 'Log In' : 'Sign Up'}</Text>
          
          <View style={styles.inputContainer}>
            <FontAwesome name="envelope" size={20} color="#999" style={styles.inputIcon} />
            <TextInput
              style={styles.input}
              placeholder="Email"
              value={email}
              onChangeText={setEmail}
              autoCapitalize="none"
              keyboardType="email-address"
              editable={!loading}
            />
          </View>
          
          <View style={styles.inputContainer}>
            <FontAwesome name="lock" size={20} color="#999" style={styles.inputIcon} />
            <TextInput
              style={styles.input}
              placeholder="Password"
              value={password}
              onChangeText={setPassword}
              secureTextEntry
              editable={!loading}
            />
          </View>
          
          {isLogin && (
            <TouchableOpacity 
              style={styles.forgotPasswordContainer}
              disabled={loading}
              onPress={() => {
                if (email) {
                  // You can implement password reset functionality here
                  Alert.alert('Reset Password', 'Password reset functionality will be implemented here.');
                } else {
                  Alert.alert('Email Required', 'Please enter your email address first.');
                }
              }}
            >
              <Text style={styles.forgotPasswordText}>Forgot Password?</Text>
            </TouchableOpacity>
          )}
          
          <TouchableOpacity 
            style={[styles.authButton, loading && styles.authButtonDisabled]}
            onPress={handleAuth}
            disabled={loading}
          >
            {loading ? (
              <ActivityIndicator size="small" color="#ffffff" />
            ) : (
              <Text style={styles.authButtonText}>{isLogin ? 'Log In' : 'Sign Up'}</Text>
            )}
          </TouchableOpacity>
          
          <View style={styles.switchContainer}>
            <Text style={styles.switchText}>
              {isLogin ? "Don't have an account? " : "Already have an account? "}
            </Text>
            <TouchableOpacity onPress={() => setIsLogin(!isLogin)} disabled={loading}>
              <Text style={[styles.switchActionText, loading && styles.textDisabled]}>
                {isLogin ? 'Sign Up' : 'Log In'}
              </Text>
            </TouchableOpacity>
          </View>
        </View>
      </ScrollView>
    </KeyboardAvoidingView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff',
  },
  scrollContent: {
    flexGrow: 1,
    justifyContent: 'center',
    padding: 20,
  },
  headerContainer: {
    alignItems: 'center',
    marginBottom: 40,
  },
  appName: {
    fontSize: 32,
    fontWeight: 'bold',
    color: '#333',
    marginTop: 16,
  },
  tagline: {
    fontSize: 16,
    color: '#666',
    textAlign: 'center',
    marginTop: 8,
  },
  formContainer: {
    width: '100%',
  },
  formTitle: {
    fontSize: 24,
    fontWeight: 'bold',
    marginBottom: 24,
    color: '#333',
  },
  inputContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    borderWidth: 1,
    borderColor: '#ddd',
    borderRadius: 8,
    marginBottom: 16,
    paddingHorizontal: 12,
  },
  inputIcon: {
    marginRight: 12,
  },
  input: {
    flex: 1,
    height: 50,
    fontSize: 16,
  },
  forgotPasswordContainer: {
    alignItems: 'flex-end',
    marginBottom: 24,
  },
  forgotPasswordText: {
    color: '#007bff',
    fontSize: 14,
  },
  authButton: {
    backgroundColor: '#007bff',
    borderRadius: 8,
    height: 50,
    justifyContent: 'center',
    alignItems: 'center',
    marginBottom: 16,
  },
  authButtonDisabled: {
    backgroundColor: '#99caff',
  },
  authButtonText: {
    color: '#fff',
    fontSize: 16,
    fontWeight: 'bold',
  },
  switchContainer: {
    flexDirection: 'row',
    justifyContent: 'center',
    marginTop: 16,
  },
  switchText: {
    color: '#666',
    fontSize: 14,
  },
  switchActionText: {
    color: '#007bff',
    fontSize: 14,
    fontWeight: 'bold',
  },
  textDisabled: {
    color: '#99caff',
  },
});
</file>

<file path="app/map/index.tsx">
import { Redirect } from 'expo-router';

export default function MapRedirect() {
  return <Redirect href="/(tabs)/map" />;
}
</file>

<file path="app/+html.tsx">
import { ScrollViewStyleReset } from 'expo-router/html';

// This file is web-only and used to configure the root HTML for every
// web page during static rendering.
// The contents of this function only run in Node.js environments and
// do not have access to the DOM or browser APIs.
export default function Root({ children }: { children: React.ReactNode }) {
  return (
    <html lang="en">
      <head>
        <meta charSet="utf-8" />
        <meta httpEquiv="X-UA-Compatible" content="IE=edge" />
        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />

        {/* 
          Disable body scrolling on web. This makes ScrollView components work closer to how they do on native. 
          However, body scrolling is often nice to have for mobile web. If you want to enable it, remove this line.
        */}
        <ScrollViewStyleReset />

        {/* Using raw CSS styles as an escape-hatch to ensure the background color never flickers in dark-mode. */}
        <style dangerouslySetInnerHTML={{ __html: responsiveBackground }} />
        {/* Add any additional <head> elements that you want globally available on web... */}
      </head>
      <body>{children}</body>
    </html>
  );
}

const responsiveBackground = `
body {
  background-color: #fff;
}
@media (prefers-color-scheme: dark) {
  body {
    background-color: #000;
  }
}`;
</file>

<file path="app/complete-profile.tsx">
import React, { useState, useEffect } from 'react';
import { StyleSheet, View, Text, TextInput, TouchableOpacity, ScrollView, Alert, ActivityIndicator, FlatList, Image, Platform } from 'react-native';
import { Stack, router } from 'expo-router';
import FontAwesome from '@expo/vector-icons/FontAwesome';
import * as ImagePicker from 'expo-image-picker';
import { doc, updateDoc } from '@firebase/firestore';
import { ref, uploadBytes, getDownloadURL } from '@firebase/storage';
import { db, storage } from '@/config/firebase';
import { useAuth } from '@/contexts/AuthContext';

// Sample interests list - in a real app, this could be fetched from Firestore
const INTERESTS = [
  'Hiking', 'Reading', 'Gaming', 'Cooking', 'Photography', 
  'Art', 'Music', 'Movies', 'Sports', 'Travel', 
  'Technology', 'Fashion', 'Fitness', 'Dancing', 'Writing',
  'Gardening', 'Pets', 'Yoga', 'Meditation', 'Programming',
  'Coffee', 'Wine', 'Food', 'Cycling', 'Running'
];

export default function CompleteProfileScreen() {
  const { user, refreshUserData } = useAuth();
  const [name, setName] = useState('');
  const [bio, setBio] = useState('');
  const [selectedInterests, setSelectedInterests] = useState<string[]>([]);
  const [customInterests, setCustomInterests] = useState<string[]>([]);
  const [customInterest, setCustomInterest] = useState('');
  const [profileImage, setProfileImage] = useState<string | null>(null);
  const [loading, setLoading] = useState(false);
  const [uploadingImage, setUploadingImage] = useState(false);

  // Request permission for media library access
  useEffect(() => {
    (async () => {
      if (Platform.OS !== 'web') {
        const { status } = await ImagePicker.requestMediaLibraryPermissionsAsync();
        if (status !== 'granted') {
          Alert.alert('Permission Needed', 'Sorry, we need camera roll permissions to upload a profile photo.');
        }
      }
    })();
  }, []);

  const toggleInterest = (interest: string) => {
    if (selectedInterests.includes(interest)) {
      setSelectedInterests(selectedInterests.filter(item => item !== interest));
    } else {
      setSelectedInterests([...selectedInterests, interest]);
    }
  };

  const addCustomInterest = () => {
    if (!customInterest.trim()) {
      return;
    }
    
    // Check if interest already exists
    if ([...selectedInterests, ...customInterests].includes(customInterest.trim())) {
      Alert.alert('Interest Exists', 'You have already added this interest.');
      return;
    }
    
    setCustomInterests([...customInterests, customInterest.trim()]);
    setCustomInterest('');
  };

  const removeCustomInterest = (interest: string) => {
    setCustomInterests(customInterests.filter(item => item !== interest));
  };

  const pickImage = async () => {
    try {
      const result = await ImagePicker.launchImageLibraryAsync({
        mediaTypes: ['images'],
        allowsEditing: true,
        aspect: [1, 1],
        quality: 0.7,
      });
      
      if (!result.canceled && result.assets && result.assets.length > 0) {
        await uploadImage(result.assets[0].uri);
      }
    } catch (error) {
      console.error('Error picking image:', error);
      Alert.alert('Error', 'Failed to pick image. Please try again.');
    }
  };

  const uploadImage = async (uri: string) => {
    setUploadingImage(true);
    
    try {
      // Get file name from URI
      const fileName = uri.split('/').pop();
      const fileExtension = fileName?.split('.').pop() || 'jpg';
      
      // Create a unique file name to avoid overwriting
      const storageFileName = `profile_${user?.uid}_${Date.now()}.${fileExtension}`;
      
      // Create a reference to the storage location
      const storageRef = ref(storage, `profile_images/${storageFileName}`);
      
      // Fetch the image and convert it to a blob
      const response = await fetch(uri);
      const blob = await response.blob();
      
      // Upload the blob to Firebase Storage
      const snapshot = await uploadBytes(storageRef, blob);
      
      // Get the download URL
      const downloadURL = await getDownloadURL(snapshot.ref);
      
      // Update the profile image state
      setProfileImage(downloadURL);
      
      console.log('Image uploaded successfully. URL:', downloadURL);
      
    } catch (error) {
      console.error('Error uploading image:', error);
      Alert.alert('Upload Failed', 'Failed to upload image. Please try again.');
    } finally {
      setUploadingImage(false);
    }
  };

  const handleSaveProfile = async () => {
    // Validation
    if (!name.trim()) {
      Alert.alert('Missing Information', 'Please enter your name.');
      return;
    }

    if ([...selectedInterests, ...customInterests].length < 1) {
      Alert.alert('Missing Information', 'Please select at least one interest.');
      return;
    }

    setLoading(true);

    try {
      if (user?.uid) {
        const userRef = doc(db, 'users', user.uid);
        
        // Combine selected predefined interests and custom interests
        const combinedInterests = [...selectedInterests, ...customInterests];
        
        const updateData: any = {
          name: name.trim(),
          bio: bio.trim(),
          interests: combinedInterests,
          'location.visible': true, // Default to visible for new users
          lastUpdated: new Date()
        };
        
        // Only include photoURL if a profile image was uploaded
        if (profileImage) {
          updateData.photoURL = profileImage;
        }
        
        await updateDoc(userRef, updateData);
        
        await refreshUserData();
        router.replace('/(tabs)');
      }
    } catch (error) {
      console.error('Error updating profile:', error);
      Alert.alert('Error', 'Failed to save profile. Please try again.');
    } finally {
      setLoading(false);
    }
  };

  const renderInterestItem = ({ item }: { item: string }) => (
    <TouchableOpacity
      style={[
        styles.interestTag,
        selectedInterests.includes(item) && styles.interestTagSelected
      ]}
      onPress={() => toggleInterest(item)}
    >
      <Text 
        style={[
          styles.interestText,
          selectedInterests.includes(item) && styles.interestTextSelected
        ]}
      >
        {item}
      </Text>
    </TouchableOpacity>
  );

  return (
    <View style={styles.container}>
      <Stack.Screen options={{ title: 'Complete Your Profile', headerShown: true }} />
      
      <ScrollView contentContainerStyle={styles.scrollContent}>
        <Text style={styles.intro}>
          Complete your profile to start connecting with people who share your interests.
        </Text>
        
        {/* Profile Image Section */}
        <View style={styles.profileImageSection}>
          <TouchableOpacity 
            style={styles.profileImageContainer}
            onPress={pickImage}
            disabled={uploadingImage || loading}
          >
            {profileImage ? (
              <Image source={{ uri: profileImage }} style={styles.profileImage} />
            ) : (
              <FontAwesome name="user-circle" size={100} color="#ccc" />
            )}
            
            {uploadingImage && (
              <View style={styles.uploadingOverlay}>
                <ActivityIndicator size="large" color="#fff" />
              </View>
            )}
            
            <View style={styles.editIconContainer}>
              <FontAwesome name="camera" size={16} color="#fff" />
            </View>
          </TouchableOpacity>
          <Text style={styles.changePhotoText}>Tap to add a profile photo</Text>
        </View>
        
        <View style={styles.section}>
          <Text style={styles.label}>Name</Text>
          <TextInput
            style={styles.input}
            placeholder="Your name"
            value={name}
            onChangeText={setName}
            maxLength={50}
            editable={!loading}
          />
        </View>
        
        <View style={styles.section}>
          <Text style={styles.label}>Bio</Text>
          <TextInput
            style={styles.bioInput}
            placeholder="Tell us about yourself..."
            value={bio}
            onChangeText={setBio}
            multiline
            maxLength={200}
            editable={!loading}
          />
          <Text style={styles.charCount}>{bio.length}/200</Text>
        </View>
        
        <View style={styles.section}>
          <Text style={styles.label}>Your Interests</Text>
          <Text style={styles.subLabel}>
            Select interests to connect with like-minded people ({selectedInterests.length + customInterests.length} selected)
          </Text>
          
          <FlatList
            data={INTERESTS}
            renderItem={renderInterestItem}
            keyExtractor={(item) => item}
            numColumns={3}
            scrollEnabled={false}
            contentContainerStyle={styles.interestsContainer}
          />
          
          {/* Custom Interest Input */}
          <View style={styles.customInterestSection}>
            <Text style={styles.subLabel}>Add your own interests</Text>
            <View style={styles.customInterestInputContainer}>
              <TextInput
                style={styles.customInterestInput}
                placeholder="Add a custom interest"
                value={customInterest}
                onChangeText={setCustomInterest}
                maxLength={20}
                editable={!loading}
              />
              <TouchableOpacity
                style={[styles.addButton, (!customInterest.trim() || loading) && styles.addButtonDisabled]}
                onPress={addCustomInterest}
                disabled={!customInterest.trim() || loading}
              >
                <Text style={styles.addButtonText}>Add</Text>
              </TouchableOpacity>
            </View>
            
            {/* Custom Interests List */}
            {customInterests.length > 0 && (
              <View style={styles.customInterestsList}>
                {customInterests.map((interest, index) => (
                  <View key={index} style={styles.customInterestItem}>
                    <Text style={styles.customInterestText}>{interest}</Text>
                    <TouchableOpacity
                      style={styles.removeButton}
                      onPress={() => removeCustomInterest(interest)}
                      disabled={loading}
                    >
                      <FontAwesome name="times" size={14} color="#fff" />
                    </TouchableOpacity>
                  </View>
                ))}
              </View>
            )}
          </View>
        </View>
        
        <TouchableOpacity
          style={[styles.saveButton, loading && styles.saveButtonDisabled]}
          onPress={handleSaveProfile}
          disabled={loading}
        >
          {loading ? (
            <ActivityIndicator size="small" color="#fff" />
          ) : (
            <Text style={styles.saveButtonText}>Save Profile</Text>
          )}
        </TouchableOpacity>
      </ScrollView>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f8f8f8',
  },
  scrollContent: {
    padding: 20,
    paddingBottom: 40,
  },
  intro: {
    fontSize: 16,
    color: '#666',
    marginBottom: 24,
    lineHeight: 22,
  },
  profileImageSection: {
    alignItems: 'center',
    marginBottom: 24,
  },
  profileImageContainer: {
    position: 'relative',
    width: 120,
    height: 120,
    borderRadius: 60,
    backgroundColor: '#eee',
    justifyContent: 'center',
    alignItems: 'center',
    marginBottom: 8,
    overflow: 'hidden',
  },
  profileImage: {
    width: 120,
    height: 120,
    borderRadius: 60,
  },
  uploadingOverlay: {
    position: 'absolute',
    width: '100%',
    height: '100%',
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  editIconContainer: {
    position: 'absolute',
    bottom: 0,
    right: 0,
    backgroundColor: '#007bff',
    width: 36,
    height: 36,
    borderRadius: 18,
    justifyContent: 'center',
    alignItems: 'center',
    borderWidth: 2,
    borderColor: '#fff',
  },
  changePhotoText: {
    fontSize: 14,
    color: '#007bff',
  },
  section: {
    marginBottom: 24,
  },
  label: {
    fontSize: 16,
    fontWeight: 'bold',
    color: '#333',
    marginBottom: 8,
  },
  subLabel: {
    fontSize: 14,
    color: '#666',
    marginBottom: 12,
  },
  input: {
    backgroundColor: '#fff',
    borderWidth: 1,
    borderColor: '#ddd',
    borderRadius: 8,
    padding: 12,
    fontSize: 16,
  },
  bioInput: {
    backgroundColor: '#fff',
    borderWidth: 1,
    borderColor: '#ddd',
    borderRadius: 8,
    padding: 12,
    fontSize: 16,
    height: 120,
    textAlignVertical: 'top',
  },
  charCount: {
    fontSize: 12,
    color: '#999',
    textAlign: 'right',
    marginTop: 4,
  },
  interestsContainer: {
    marginHorizontal: -4,
  },
  interestTag: {
    backgroundColor: '#fff',
    borderWidth: 1,
    borderColor: '#ddd',
    borderRadius: 20,
    paddingHorizontal: 12,
    paddingVertical: 8,
    margin: 4,
  },
  interestTagSelected: {
    backgroundColor: '#007bff',
    borderColor: '#007bff',
  },
  interestText: {
    fontSize: 14,
    color: '#666',
  },
  interestTextSelected: {
    color: '#fff',
  },
  customInterestSection: {
    marginTop: 16,
  },
  customInterestInputContainer: {
    flexDirection: 'row',
    marginBottom: 12,
  },
  customInterestInput: {
    flex: 1,
    backgroundColor: '#fff',
    borderWidth: 1,
    borderColor: '#ddd',
    borderRadius: 8,
    padding: 12,
    fontSize: 16,
    marginRight: 8,
  },
  addButton: {
    backgroundColor: '#007bff',
    borderRadius: 8,
    paddingHorizontal: 16,
    justifyContent: 'center',
    alignItems: 'center',
  },
  addButtonDisabled: {
    backgroundColor: '#99caff',
  },
  addButtonText: {
    color: '#fff',
    fontSize: 16,
    fontWeight: 'bold',
  },
  customInterestsList: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    marginTop: 8,
  },
  customInterestItem: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#e1f5fe',
    borderRadius: 20,
    paddingHorizontal: 12,
    paddingVertical: 6,
    marginRight: 8,
    marginBottom: 8,
  },
  customInterestText: {
    fontSize: 14,
    color: '#0288d1',
    marginRight: 8,
  },
  removeButton: {
    backgroundColor: '#0288d1',
    width: 20,
    height: 20,
    borderRadius: 10,
    justifyContent: 'center',
    alignItems: 'center',
  },
  saveButton: {
    backgroundColor: '#007bff',
    borderRadius: 8,
    padding: 16,
    alignItems: 'center',
    marginTop: 20,
  },
  saveButtonDisabled: {
    backgroundColor: '#99caff',
  },
  saveButtonText: {
    color: '#fff',
    fontSize: 16,
    fontWeight: 'bold',
  },
});
</file>

<file path="app/index.tsx">
import React, { useEffect } from 'react';
import { router } from 'expo-router';
import { useAuth } from '@/contexts/AuthContext';
import LoadingScreen from '@/components/screens/LoadingScreen';

// This component renders when the root URL is accessed
export default function Root() {
  const { user, loading } = useAuth();
  
  useEffect(() => {
    // Log the current auth state
    console.log('Root index screen:', { 
      loading, 
      isAuthenticated: !!user,
      userId: user?.uid || 'none'
    });
    
    // Only navigate after auth state is determined
    if (!loading) {
      if (user) {
        console.log('Root index: User is authenticated, navigating to tabs...');
        router.replace('/(tabs)');
      } else {
        console.log('Root index: User is NOT authenticated, navigating to login...');
        router.replace('/auth/login');
      }
    }
  }, [user, loading]);
  
  // Show loading screen while checking auth state
  return <LoadingScreen message="Starting HiveSocial..." />;
}
</file>

<file path="app/modal.tsx">
import { StatusBar } from 'expo-status-bar';
import { Platform, StyleSheet } from 'react-native';

import EditScreenInfo from '@/components/EditScreenInfo';
import { Text, View } from '@/components/Themed';

export default function ModalScreen() {
  return (
    <View style={styles.container}>
      <Text style={styles.title}>Modal</Text>
      <View style={styles.separator} lightColor="#eee" darkColor="rgba(255,255,255,0.1)" />
      <EditScreenInfo path="app/modal.tsx" />

      {/* Use a light status bar on iOS to account for the black space above the modal */}
      <StatusBar style={Platform.OS === 'ios' ? 'light' : 'auto'} />
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center',
  },
  title: {
    fontSize: 20,
    fontWeight: 'bold',
  },
  separator: {
    marginVertical: 30,
    height: 1,
    width: '80%',
  },
});
</file>

<file path="app/settings.tsx">
import { StatusBar } from 'expo-status-bar';
import { Platform, StyleSheet, TouchableOpacity } from 'react-native';
import { Text, View } from '@/components/Themed';
import { router } from 'expo-router';
import FontAwesome from '@expo/vector-icons/FontAwesome';

export default function SettingsScreen() {
  return (
    <View style={styles.container}>
      <Text style={styles.title}>Settings</Text>
      
      <View style={styles.separator} lightColor="#eee" darkColor="rgba(255,255,255,0.1)" />
      
      <View style={styles.settingsContainer}>
        <TouchableOpacity style={styles.settingItem}>
          <FontAwesome name="bell" size={24} color="#666" style={styles.settingIcon} />
          <View style={styles.settingContent}>
            <Text style={styles.settingTitle}>Notifications</Text>
            <Text style={styles.settingDescription}>Manage your notification preferences</Text>
          </View>
          <FontAwesome name="chevron-right" size={16} color="#ccc" />
        </TouchableOpacity>
        
        <TouchableOpacity style={styles.settingItem}>
          <FontAwesome name="lock" size={24} color="#666" style={styles.settingIcon} />
          <View style={styles.settingContent}>
            <Text style={styles.settingTitle}>Privacy</Text>
            <Text style={styles.settingDescription}>Control your privacy settings</Text>
          </View>
          <FontAwesome name="chevron-right" size={16} color="#ccc" />
        </TouchableOpacity>
        
        <TouchableOpacity style={styles.settingItem}>
          <FontAwesome name="question-circle" size={24} color="#666" style={styles.settingIcon} />
          <View style={styles.settingContent}>
            <Text style={styles.settingTitle}>Help & Support</Text>
            <Text style={styles.settingDescription}>Get help with HiveSocial</Text>
          </View>
          <FontAwesome name="chevron-right" size={16} color="#ccc" />
        </TouchableOpacity>
        
        <TouchableOpacity style={styles.settingItem}>
          <FontAwesome name="info-circle" size={24} color="#666" style={styles.settingIcon} />
          <View style={styles.settingContent}>
            <Text style={styles.settingTitle}>About</Text>
            <Text style={styles.settingDescription}>App version and information</Text>
          </View>
          <FontAwesome name="chevron-right" size={16} color="#ccc" />
        </TouchableOpacity>
      </View>
      
      <TouchableOpacity style={styles.logoutButton}>
        <Text style={styles.logoutButtonText}>Log Out</Text>
      </TouchableOpacity>
      
      <TouchableOpacity style={styles.closeButton} onPress={() => router.back()}>
        <Text style={styles.closeButtonText}>Close</Text>
      </TouchableOpacity>
      
      {/* Use a light status bar on iOS to account for the black space above the modal */}
      <StatusBar style={Platform.OS === 'ios' ? 'light' : 'auto'} />
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 20,
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    marginBottom: 20,
  },
  separator: {
    marginVertical: 20,
    height: 1,
    width: '100%',
  },
  settingsContainer: {
    width: '100%',
  },
  settingItem: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#eee',
  },
  settingIcon: {
    marginRight: 16,
  },
  settingContent: {
    flex: 1,
  },
  settingTitle: {
    fontSize: 16,
    fontWeight: 'bold',
    marginBottom: 4,
  },
  settingDescription: {
    fontSize: 14,
    color: '#666',
  },
  logoutButton: {
    backgroundColor: '#ff3b30',
    padding: 16,
    borderRadius: 8,
    alignItems: 'center',
    marginTop: 40,
  },
  logoutButtonText: {
    color: '#fff',
    fontSize: 16,
    fontWeight: 'bold',
  },
  closeButton: {
    padding: 16,
    borderRadius: 8,
    alignItems: 'center',
    marginTop: 16,
  },
  closeButtonText: {
    color: '#007aff',
    fontSize: 16,
  },
});
</file>

<file path="app/user-profile.tsx">
import React, { useState, useEffect, useRef } from 'react';
import { 
  StyleSheet, 
  View, 
  Text, 
  Image, 
  ScrollView, 
  TouchableOpacity, 
  ActivityIndicator, 
  Animated,
  Dimensions,
  Platform,
  Modal,
  SafeAreaView,
  Alert
} from 'react-native';
import { StatusBar } from 'expo-status-bar';
import { LinearGradient } from 'expo-linear-gradient';
import { BlurView } from 'expo-blur';
import { Stack, useLocalSearchParams, router } from 'expo-router';
import FontAwesome from '@expo/vector-icons/FontAwesome';
import MaterialIcons from '@expo/vector-icons/MaterialIcons';
import Ionicons from '@expo/vector-icons/Ionicons';
import { useAuth } from '@/contexts/AuthContext';
import { doc, getDoc, collection, query, where, getDocs } from '@firebase/firestore';
import { db } from '@/config/firebase';

const { width: SCREEN_WIDTH } = Dimensions.get('window');
const CARD_PADDING = 20;

// Tier color mapping to match the map screen colors
const TIER_COLORS = {
  'soulmate': { primary: '#00B0FF', gradient: ['#00B0FF', '#64c8ff'] },     // Light blue
  'bestFriend': { primary: '#FFD700', gradient: ['#FFD700', '#ffe666'] },  // Gold
  'friend': { primary: '#C0C0C0', gradient: ['#C0C0C0', '#e6e6e6'] },      // Silver
  'buddy': { primary: '#CD7F32', gradient: ['#CD7F32', '#e2aa73'] },       // Bronze
  'casual': { primary: '#AAAAAA', gradient: ['#AAAAAA', '#d9d9d9'] }        // Gray
};

export default function UserProfileScreen() {
  const { user } = useAuth();
  const params = useLocalSearchParams();
  const { id, name, tier } = params;
  
  const [loading, setLoading] = useState(true);
  const [userData, setUserData] = useState(null);
  const [selectedImageIndex, setSelectedImageIndex] = useState(null);
  const [showImageModal, setShowImageModal] = useState(false);
  const [connection, setConnection] = useState(null);
  
  // Animation values
  const scrollY = useRef(new Animated.Value(0)).current;
  const headerOpacity = scrollY.interpolate({
    inputRange: [0, 100],
    outputRange: [0, 1],
    extrapolate: 'clamp',
  });
  
  // Load user data
  useEffect(() => {
    const fetchUserData = async () => {
      if (!id) {
        setLoading(false);
        return;
      }
      
      try {
        console.log('Fetching user profile for:', id);
        const userDocRef = doc(db, 'users', id.toString());
        const userDocSnapshot = await getDoc(userDocRef);
        
        if (userDocSnapshot.exists()) {
          const userData = userDocSnapshot.data();
          console.log('User data retrieved:', userData.name);
          setUserData(userData);
          
          // Also fetch connection data to get the chat room ID
          if (user?.uid) {
            try {
              // Check for connection between current user and this user
              const connectionQuery1 = query(
                collection(db, 'connectionRequests'),
                where('senderId', '==', user.uid),
                where('receiverId', '==', id.toString()),
                where('status', '==', 'accepted')
              );
              
              const connectionQuery2 = query(
                collection(db, 'connectionRequests'),
                where('senderId', '==', id.toString()),
                where('receiverId', '==', user.uid),
                where('status', '==', 'accepted')
              );
              
              const [snapshot1, snapshot2] = await Promise.all([
                getDocs(connectionQuery1),
                getDocs(connectionQuery2)
              ]);
              
              let connectionData = null;
              
              if (!snapshot1.empty) {
                connectionData = { id: snapshot1.docs[0].id, ...snapshot1.docs[0].data() };
              } else if (!snapshot2.empty) {
                connectionData = { id: snapshot2.docs[0].id, ...snapshot2.docs[0].data() };
              }
              
              if (connectionData) {
                console.log('Connection found with chat room ID:', connectionData.chatRoomId);
                setConnection(connectionData);
              }
            } catch (error) {
              console.error('Error fetching connection data:', error);
            }
          }
        } else {
          console.log('No user found with ID:', id);
          Alert.alert('Error', 'User not found');
        }
      } catch (error) {
        console.error('Error fetching user data:', error);
        Alert.alert('Error', 'Failed to load user profile');
      } finally {
        setLoading(false);
      }
    };
    
    fetchUserData();
  }, [id, user?.uid]);
  
  // Handle image tap for viewing
  const handleImageTap = (index) => {
    setSelectedImageIndex(index);
    setShowImageModal(true);
  };
  
  // Close image modal
  const closeImageModal = () => {
    setShowImageModal(false);
    setSelectedImageIndex(null);
  };
  
  // Get tier display info
  const getTierInfo = (tier) => {
    const tierKey = tier || 'casual';
    return {
      colors: TIER_COLORS[tierKey]?.gradient || TIER_COLORS.casual.gradient,
      name: getTierDisplayName(tierKey),
      color: TIER_COLORS[tierKey]?.primary || TIER_COLORS.casual.primary
    };
  };
  
  // Helper function to get display name for tier
  const getTierDisplayName = (tier) => {
    switch(tier) {
      case 'soulmate': return 'Soulmate';
      case 'bestFriend': return 'Best Friend';
      case 'friend': return 'Friend';
      case 'buddy': return 'Buddy';
      case 'casual': 
      default: return 'Casual';
    }
  };
  
  // Handle back button
  const handleGoBack = () => {
    router.back();
  };
  
  // Handle message button
  const handleMessage = () => {
    // Navigate to the chat screen if a chat room exists
    if (connection?.chatRoomId) {
      router.push(`/chat/${connection.chatRoomId}?name=${encodeURIComponent(userData?.name || 'User')}`);
    } else {
      // No chat room found - prompt user to connect first
      Alert.alert(
        'No Connection',
        'You need to connect with this user before you can message them.',
        [
          {
            text: 'Go Back',
            style: 'cancel'
          },
          {
            text: 'View Connections',
            onPress: () => router.push('/(tabs)/connections')
          }
        ]
      );
    }
  };
  
  const tierInfo = getTierInfo(tier);
  
  if (loading) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color="#6C5CE7" />
        <Text style={styles.loadingText}>Loading profile...</Text>
      </View>
    );
  }
  
  if (!userData) {
    return (
      <View style={styles.errorContainer}>
        <MaterialIcons name="error-outline" size={60} color="#ff4757" />
        <Text style={styles.errorText}>User not found</Text>
        <TouchableOpacity 
          style={styles.backButton}
          onPress={handleGoBack}
        >
          <Text style={styles.backButtonText}>Go Back</Text>
        </TouchableOpacity>
      </View>
    );
  }
  
  return (
    <View style={styles.container}>
      <StatusBar style="dark" />
      
      <Stack.Screen
        options={{
          title: userData?.name || name || 'Profile',
          headerShown: true,
          headerBackTitle: 'Back',
          headerTintColor: '#6C5CE7',
          headerStyle: {
            backgroundColor: '#fff',
          },
          headerShadowVisible: false,
        }}
      />
      
      {/* Animated Header */}
      <Animated.View style={[styles.animatedHeader, { opacity: headerOpacity }]}>
        <Text style={styles.animatedHeaderText}>{userData?.name || name || 'Profile'}</Text>
      </Animated.View>
      
      <Animated.ScrollView 
        style={styles.scrollView}
        contentContainerStyle={styles.scrollContent}
        showsVerticalScrollIndicator={false}
        onScroll={Animated.event(
          [{ nativeEvent: { contentOffset: { y: scrollY } } }],
          { useNativeDriver: true }
        )}
        scrollEventThrottle={16}
      >
        {/* Profile Header */}
        <View style={styles.profileHeader}>
          <LinearGradient
            colors={tierInfo.colors}
            style={styles.headerGradient}
            start={{ x: 0, y: 0 }}
            end={{ x: 1, y: 1 }}
          />
          <View style={styles.profileImageContainer}>
            {userData.photoURL ? (
              <Image source={{ uri: userData.photoURL }} style={styles.profileImage} />
            ) : (
              <View style={styles.placeholderImage}>
                <FontAwesome name="user" size={60} color="#fff" />
              </View>
            )}
          </View>
          <Text style={styles.profileName}>{userData.name || 'User'}</Text>
          <View style={styles.tierBadge}>
            <Text style={styles.tierBadgeText}>{tierInfo.name}</Text>
          </View>
        </View>
        
        {/* About Me Card */}
        {userData.bio && (
          <View style={styles.card}>
            <View style={styles.cardHeader}>
              <MaterialIcons name="person" size={20} color={tierInfo.color} />
              <Text style={styles.cardTitle}>About Me</Text>
            </View>
            <Text style={styles.bioText}>
              {userData.bio}
            </Text>
          </View>
        )}
        
        {/* Interests Card */}
        {userData.interests && userData.interests.length > 0 && (
          <View style={styles.card}>
            <View style={styles.cardHeader}>
              <MaterialIcons name="favorite" size={20} color={tierInfo.color} />
              <Text style={styles.cardTitle}>Interests</Text>
            </View>
            
            <View style={styles.interestsContainer}>
              {userData.interests.map((interest, index) => (
                <View key={index} style={[styles.interestTag, { backgroundColor: `${tierInfo.color}15` }]}>
                  <Text style={[styles.interestText, { color: tierInfo.color }]}>{interest}</Text>
                </View>
              ))}
            </View>
          </View>
        )}
        
        {/* Profile Images Card */}
        {userData.profileImages && userData.profileImages.length > 0 && (
          <View style={styles.card}>
            <View style={styles.cardHeader}>
              <MaterialIcons name="photo-library" size={20} color={tierInfo.color} />
              <Text style={styles.cardTitle}>Photos</Text>
            </View>
            <View style={styles.profileImagesGrid}>
              {userData.profileImages.map((imageUrl, index) => (
                <TouchableOpacity 
                  key={index} 
                  style={styles.gridImageContainer}
                  onPress={() => handleImageTap(index)}
                  activeOpacity={0.9}
                >
                  <Image 
                    source={{ uri: imageUrl }} 
                    style={styles.gridImage}
                    resizeMode="cover"
                  />
                  <LinearGradient
                    colors={['transparent', 'rgba(0,0,0,0.3)']}
                    style={styles.gridImageOverlay}
                  />
                </TouchableOpacity>
              ))}
            </View>
          </View>
        )}
        
        {/* Message Button */}
        <TouchableOpacity 
          style={styles.messageButton}
          onPress={handleMessage}
          activeOpacity={0.8}
        >
          <LinearGradient
            colors={['#6C5CE7', '#a29bfe']}
            style={styles.messageButtonGradient}
            start={{ x: 0, y: 0 }}
            end={{ x: 1, y: 0 }}
          >
            <Ionicons name="chatbubble-outline" size={20} color="#fff" style={styles.messageButtonIcon} />
            <Text style={styles.messageButtonText}>Message</Text>
          </LinearGradient>
        </TouchableOpacity>
      </Animated.ScrollView>
      
      {/* Image Modal */}
      <Modal
        visible={showImageModal}
        transparent={true}
        animationType="fade"
        onRequestClose={closeImageModal}
      >
        <View style={styles.modalContainer}>
          <BlurView intensity={100} style={styles.modalBlur} tint="dark">
            <TouchableOpacity 
              style={styles.modalCloseButton}
              onPress={closeImageModal}
            >
              <Ionicons name="close-circle" size={36} color="#fff" />
            </TouchableOpacity>
            
            {selectedImageIndex !== null && userData?.profileImages?.[selectedImageIndex] && (
              <Image
                source={{ uri: userData.profileImages[selectedImageIndex] }}
                style={styles.fullScreenImage}
                resizeMode="contain"
              />
            )}
          </BlurView>
        </View>
      </Modal>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#f5f5f5',
  },
  loadingText: {
    marginTop: 16,
    fontSize: 16,
    color: '#666',
  },
  errorContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#f5f5f5',
    padding: 32,
  },
  errorText: {
    fontSize: 18,
    fontWeight: '600',
    color: '#333',
    marginTop: 16,
    marginBottom: 24,
  },
  backButton: {
    backgroundColor: '#6C5CE7',
    paddingVertical: 12,
    paddingHorizontal: 24,
    borderRadius: 12,
  },
  backButtonText: {
    color: '#fff',
    fontSize: 16,
    fontWeight: '600',
  },
  scrollView: {
    flex: 1,
  },
  scrollContent: {
    paddingBottom: 40,
  },
  animatedHeader: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    height: Platform.OS === 'ios' ? 90 : 60,
    backgroundColor: '#fff',
    zIndex: 1000,
    justifyContent: 'flex-end',
    alignItems: 'center',
    paddingBottom: 10,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 3,
    elevation: 5,
  },
  animatedHeaderText: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#333',
  },
  profileHeader: {
    height: 200,
    alignItems: 'center',
    justifyContent: 'flex-end',
    position: 'relative',
    marginBottom: 80,
  },
  headerGradient: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    height: '100%',
  },
  profileImageContainer: {
    position: 'absolute',
    bottom: -50,
    borderRadius: 80,
    borderWidth: 5,
    borderColor: '#fff',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.2,
    shadowRadius: 5,
    elevation: 5,
    backgroundColor: '#fff',
  },
  profileImage: {
    width: 100,
    height: 100,
    borderRadius: 50,
  },
  placeholderImage: {
    width: 100,
    height: 100,
    borderRadius: 50,
    backgroundColor: '#a29bfe',
    justifyContent: 'center',
    alignItems: 'center',
  },
  profileName: {
    color: '#fff',
    fontSize: 24,
    fontWeight: 'bold',
    marginBottom: 8,
    textShadowColor: 'rgba(0, 0, 0, 0.3)',
    textShadowOffset: { width: 0, height: 1 },
    textShadowRadius: 3,
  },
  tierBadge: {
    backgroundColor: 'rgba(255, 255, 255, 0.25)',
    paddingHorizontal: 16,
    paddingVertical: 6,
    borderRadius: 20,
    marginBottom: 60,
  },
  tierBadgeText: {
    color: '#fff',
    fontSize: 14,
    fontWeight: '600',
  },
  card: {
    backgroundColor: '#fff',
    borderRadius: 16,
    marginHorizontal: 16,
    marginBottom: 16,
    padding: CARD_PADDING,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.05,
    shadowRadius: 3,
    elevation: 3,
  },
  cardHeader: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 14,
  },
  cardTitle: {
    fontSize: 18,
    fontWeight: '600',
    color: '#333',
    marginLeft: 8,
  },
  bioText: {
    fontSize: 16,
    color: '#555',
    lineHeight: 24,
  },
  interestsContainer: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    marginHorizontal: -4,
  },
  interestTag: {
    paddingHorizontal: 14,
    paddingVertical: 8,
    borderRadius: 20,
    margin: 4,
  },
  interestText: {
    fontSize: 14,
    fontWeight: '500',
  },
  profileImagesGrid: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    marginHorizontal: -6,
  },
  gridImageContainer: {
    width: (SCREEN_WIDTH - 32 - CARD_PADDING * 2 - 12) / 3,
    aspectRatio: 1,
    padding: 6,
    position: 'relative',
  },
  gridImage: {
    width: '100%',
    height: '100%',
    borderRadius: 12,
  },
  gridImageOverlay: {
    position: 'absolute',
    bottom: 6,
    left: 6,
    right: 6,
    height: '50%',
    borderBottomLeftRadius: 12,
    borderBottomRightRadius: 12,
  },
  messageButton: {
    marginHorizontal: 16,
    marginTop: 8,
    marginBottom: 20,
    borderRadius: 12,
    overflow: 'hidden',
    shadowColor: '#6C5CE7',
    shadowOffset: { width: 0, height: 3 },
    shadowOpacity: 0.2,
    shadowRadius: 4,
    elevation: 5,
  },
  messageButtonGradient: {
    flexDirection: 'row',
    paddingVertical: 16,
    alignItems: 'center',
    justifyContent: 'center',
  },
  messageButtonIcon: {
    marginRight: 8,
  },
  messageButtonText: {
    color: '#fff',
    fontSize: 16,
    fontWeight: 'bold',
  },
  modalContainer: {
    flex: 1,
    backgroundColor: 'transparent',
  },
  modalBlur: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  modalCloseButton: {
    position: 'absolute',
    top: 40,
    right: 20,
    zIndex: 2,
    backgroundColor: 'rgba(0,0,0,0.3)',
    borderRadius: 20,
  },
  fullScreenImage: {
    width: SCREEN_WIDTH - 40,
    height: SCREEN_WIDTH - 40,
    borderRadius: 12,
  },
});
</file>

<file path="assets/images/default-avatar.svg">
<svg enable-background="new" height="16" width="16" xmlns="http://www.w3.org/2000/svg"><path d="m17.466336 16.914007c-.159-.052-1.164-.505-.536-2.414h-.009c1.637-1.686 2.888-4.399 2.888-7.0700001 0-4.107-2.731-6.26-5.905-6.26-3.176 0-5.8920001 2.152-5.8920001 6.26 0 2.6820001 1.244 5.4060001 2.8910001 7.0880001.642 1.684-.506 2.309-.746 2.396-2.2377834.723652-8.3253526 4.33152-8.2290392 9.585718h24.0505822c.107339-5.019251-4.707828-8.278585-8.512543-9.585718zm19.943463-3.079141a23.455896 23.455898 0 0 1 -23.455894 23.455898 23.455896 23.455898 0 0 1 -23.4558962-23.455898 23.455896 23.455898 0 0 1 23.4558962-23.4558977 23.455896 23.455898 0 0 1 23.455894 23.4558977z" fill="#bebebe" transform="matrix(.2557992 0 0 .2557992 4.430602 4.461052)"/></svg>
</file>

<file path="components/__tests__/StyledText-test.js">
import * as React from 'react';
import renderer from 'react-test-renderer';

import { MonoText } from '../StyledText';

it(`renders correctly`, () => {
  const tree = renderer.create(<MonoText>Snapshot test!</MonoText>).toJSON();

  expect(tree).toMatchSnapshot();
});
</file>

<file path="components/maps/FilterDrawer.tsx">
import React, { useMemo } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  ScrollView,
  Switch,
  Dimensions,
  Animated,
  PanResponder,
  TextInput
} from 'react-native';
import FontAwesome from '@expo/vector-icons/FontAwesome';

const { width } = Dimensions.get('window');
const DRAWER_WIDTH = width * 0.8; // 80% of screen width
const DISMISS_THRESHOLD = 50; // How far to swipe to dismiss

// Predefined interest categories
const INTEREST_CATEGORIES = {
  "Activities": [
    "Hiking", "Cycling", "Running", "Swimming", "Yoga", "Dancing", 
    "Photography", "Painting", "Drawing", "Crafting"
  ],
  "Entertainment": [
    "Movies", "TV Shows", "Gaming", "Music", "Reading", "Theater", 
    "Concerts", "Festivals"
  ],
  "Lifestyle": [
    "Cooking", "Baking", "Travel", "Fashion", "Fitness", "Meditation", 
    "Mindfulness"
  ],
  "Social & Intellectual": [
    "Politics", "History", "Science", "Philosophy", "Technology",
    "Languages", "Volunteering", "Networking"
  ],
  "Sports": [
    "Football", "Basketball", "Baseball", "Soccer", "Tennis", "Golf", 
    "Volleyball", "Skiing", "Snowboarding", "Surfing"
  ],
  "Other": [] // Will contain any interests not in above categories
};

interface FilterDrawerProps {
  visible: boolean;
  onClose: () => void;
  filters: {
    // Interest filters
    selectedInterests: string[];
    minSharedInterests: number;
    // Visibility filters
    onlineOnly: boolean;
  };
  allInterests: string[];
  onInterestToggle: (interest: string) => void;
  onMinSharedInterestsChange: (value: number) => void;
  onOnlineOnlyToggle: (value: boolean) => void;
  drawerAnimation: Animated.Value;
}

const FilterDrawer: React.FC<FilterDrawerProps> = ({
  visible,
  onClose,
  filters,
  allInterests,
  onInterestToggle,
  onMinSharedInterestsChange,
  onOnlineOnlyToggle,
  drawerAnimation
}) => {
  // Create pan responder for swipe to dismiss - HOOK 1
  const panResponder = useMemo(() => PanResponder.create({
    onStartShouldSetPanResponder: () => true,
    onMoveShouldSetPanResponder: (_, gestureState) => {
      // Only respond to horizontal gestures
      return Math.abs(gestureState.dx) > Math.abs(gestureState.dy) && gestureState.dx < 0;
    },
    onPanResponderMove: (_, gestureState) => {
      // Only allow swiping left (negative dx)
      if (gestureState.dx < 0) {
        drawerAnimation.setValue(gestureState.dx);
      }
    },
    onPanResponderRelease: (_, gestureState) => {
      if (gestureState.dx < -DISMISS_THRESHOLD) {
        // Swipe threshold met, close the drawer
        onClose();
      } else {
        // Reset to open position
        Animated.spring(drawerAnimation, {
          toValue: 0,
          useNativeDriver: true,
        }).start();
      }
    },
  }), [drawerAnimation, onClose]);

  // Sort interests into categories - HOOK 2
  const categorizedInterests = useMemo(() => {
    const result = {...INTEREST_CATEGORIES};
    
    // Initialize "Other" category
    result["Other"] = [];
    
    // Categorize each interest
    allInterests.forEach(interest => {
      let found = false;
      
      // Check each category
      for (const category in result) {
        if (category === "Other") continue; // Skip "Other" for now
        
        if (result[category].includes(interest)) {
          found = true;
          break;
        }
      }
      
      // If not found in any category, add to "Other"
      if (!found) {
        result["Other"].push(interest);
      }
    });
    
    return result;
  }, [allInterests]);

  // Don't render if not visible
  if (!visible) return null;

  return (
    <Animated.View 
      style={[
        styles.container,
        {
          transform: [{
            translateX: drawerAnimation.interpolate({
              inputRange: [-DRAWER_WIDTH, 0],
              outputRange: [-DRAWER_WIDTH, 0],
              extrapolate: 'clamp'
            })
          }]
        }
      ]}
      {...panResponder.panHandlers}
    >
      <View style={styles.header}>
        <Text style={styles.title}>Filters</Text>
        <TouchableOpacity onPress={onClose} style={styles.closeButton}>
          <FontAwesome name="times" size={24} color="#333" />
        </TouchableOpacity>
      </View>
      
      <ScrollView style={styles.scrollContent}>
        {/* Minimum Shared Interests Slider */}
        <View style={styles.section}>
          <Text style={styles.sectionTitle}>Minimum Shared Interests</Text>
          <Text style={styles.sliderValue}>{filters.minSharedInterests}</Text>
          
          <View style={styles.customSliderContainer}>
            <TouchableOpacity
              style={styles.sliderButton}
              onPress={() => {
                if (filters.minSharedInterests > 1) {
                  onMinSharedInterestsChange(filters.minSharedInterests - 1);
                }
              }}
            >
              <Text style={styles.sliderButtonText}>-</Text>
            </TouchableOpacity>
            
            <TextInput
              style={styles.sliderInput}
              value={filters.minSharedInterests.toString()}
              keyboardType="number-pad"
              onChangeText={(text) => {
                const value = parseInt(text);
                if (!isNaN(value) && value >= 1 && value <= 15) {
                  onMinSharedInterestsChange(value);
                }
              }}
            />
            
            <TouchableOpacity
              style={styles.sliderButton}
              onPress={() => {
                if (filters.minSharedInterests < 15) {
                  onMinSharedInterestsChange(filters.minSharedInterests + 1);
                }
              }}
            >
              <Text style={styles.sliderButtonText}>+</Text>
            </TouchableOpacity>
          </View>
          
          <View style={styles.sliderLabels}>
            <Text style={styles.sliderLabel}>1</Text>
            <Text style={styles.sliderLabel}>15</Text>
          </View>
        </View>
        
        {/* Online Only Toggle */}
        <View style={styles.section}>
          <View style={styles.switchRow}>
            <Text style={styles.switchLabel}>Show Online Users Only</Text>
            <Switch
              value={filters.onlineOnly}
              onValueChange={onOnlineOnlyToggle}
              trackColor={{ false: "#D3D3D3", true: "#4B7BEC" }}
              thumbColor="#ffffff"
            />
          </View>
        </View>
        
        {/* Interest Filters */}
        <View style={styles.section}>
          <Text style={styles.sectionTitle}>Filter by Interests</Text>
          <Text style={styles.sectionSubtitle}>
            Show users who have these interests
          </Text>
          
          {/* Categorized Interest List */}
          {Object.keys(categorizedInterests).map(category => {
            // Skip empty categories
            if (categorizedInterests[category].length === 0) return null;
            
            return (
              <View key={category} style={styles.categorySection}>
                <Text style={styles.categoryTitle}>{category}</Text>
                
                <View style={styles.interestsGrid}>
                  {categorizedInterests[category].map(interest => (
                    <TouchableOpacity 
                      key={interest}
                      style={[
                        styles.interestTag,
                        filters.selectedInterests.includes(interest) && styles.interestTagSelected
                      ]}
                      onPress={() => onInterestToggle(interest)}
                    >
                      <Text 
                        style={[
                          styles.interestText,
                          filters.selectedInterests.includes(interest) && styles.interestTextSelected
                        ]}
                      >
                        {interest}
                      </Text>
                    </TouchableOpacity>
                  ))}
                </View>
              </View>
            );
          })}
        </View>
        
        {/* Info section at bottom */}
        <View style={styles.infoSection}>
          <FontAwesome name="info-circle" size={16} color="#666" style={styles.infoIcon} />
          <Text style={styles.infoText}>
            Users will only appear if they match your filters AND you match their filters (bilateral filtering).
          </Text>
        </View>
        
        {/* Bottom padding for scrolling */}
        <View style={{ height: 30 }} />
      </ScrollView>
    </Animated.View>
  );
};

const styles = StyleSheet.create({
  container: {
    position: 'absolute',
    top: 0,
    left: 0,
    width: DRAWER_WIDTH,
    height: '100%',
    backgroundColor: 'white',
    shadowColor: '#000',
    shadowOffset: { width: 2, height: 0 },
    shadowOpacity: 0.3,
    shadowRadius: 5,
    elevation: 10,
    zIndex: 1000,
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingHorizontal: 20,
    paddingVertical: 15,
    borderBottomWidth: 1,
    borderBottomColor: '#eee',
  },
  title: {
    fontSize: 20,
    fontWeight: 'bold',
    color: '#333',
  },
  closeButton: {
    padding: 5,
  },
  scrollContent: {
    flex: 1,
  },
  section: {
    padding: 20,
    borderBottomWidth: 1,
    borderBottomColor: '#eee',
  },
  sectionTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#333',
    marginBottom: 10,
  },
  sectionSubtitle: {
    fontSize: 14,
    color: '#666',
    marginBottom: 15,
  },
  slider: {
    width: '100%',
    height: 40,
  },
  customSliderContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    marginVertical: 10,
    paddingHorizontal: 10,
  },
  sliderButton: {
    width: 40,
    height: 40,
    borderRadius: 20,
    backgroundColor: '#4B7BEC',
    justifyContent: 'center',
    alignItems: 'center',
  },
  sliderButtonText: {
    color: 'white',
    fontSize: 24,
    fontWeight: 'bold',
  },
  sliderInput: {
    width: 60,
    height: 40,
    textAlign: 'center',
    fontSize: 18,
    fontWeight: 'bold',
    borderWidth: 1,
    borderColor: '#D3D3D3',
    borderRadius: 8,
  },
  sliderValue: {
    fontSize: 24,
    fontWeight: 'bold',
    color: '#4B7BEC',
    textAlign: 'center',
    marginBottom: 10,
  },
  sliderLabels: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    paddingHorizontal: 10,
  },
  sliderLabel: {
    fontSize: 12,
    color: '#666',
  },
  switchRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
  },
  switchLabel: {
    fontSize: 16,
    color: '#333',
  },
  categorySection: {
    marginTop: 15,
  },
  categoryTitle: {
    fontSize: 16,
    fontWeight: '600',
    color: '#555',
    marginBottom: 10,
  },
  interestsGrid: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    marginHorizontal: -5,
  },
  interestTag: {
    backgroundColor: '#f0f0f0',
    paddingHorizontal: 12,
    paddingVertical: 8,
    borderRadius: 20,
    margin: 5,
    borderWidth: 1,
    borderColor: '#e0e0e0',
  },
  interestTagSelected: {
    backgroundColor: '#4B7BEC',
    borderColor: '#3B6AD9',
  },
  interestText: {
    fontSize: 14,
    color: '#555',
  },
  interestTextSelected: {
    color: 'white',
    fontWeight: '500',
  },
  infoSection: {
    flexDirection: 'row',
    padding: 20,
    backgroundColor: '#f9f9f9',
    alignItems: 'flex-start',
  },
  infoIcon: {
    marginRight: 10,
    marginTop: 2,
  },
  infoText: {
    flex: 1,
    fontSize: 13,
    color: '#666',
    lineHeight: 18,
  },
});

export default FilterDrawer;
</file>

<file path="components/maps/MarkerSpiderfier.tsx">
import React, { useState, useEffect, useRef } from 'react';
import { Animated, View, TouchableOpacity, Text, StyleSheet, Platform } from 'react-native';
import { Marker } from 'react-native-maps';
import EnhancedUserMapMarker from './EnhancedUserMapMarker';

interface SpiderfiedMarkerProps {
  marker: any;
  index: number;
  totalMarkers: number;
  baseCoordinate: {
    latitude: number;
    longitude: number;
  };
  onPress: (marker: any) => void;
  onAnimationComplete?: () => void;
}

const SpiderfiedMarker: React.FC<SpiderfiedMarkerProps> = ({
  marker,
  index,
  totalMarkers,
  baseCoordinate,
  onPress,
  onAnimationComplete
}) => {
  const animation = useRef(new Animated.Value(0)).current;
  
  // Calculate the target position in the spiderfied pattern
  // Using a spiral pattern for many markers or a circle for fewer
  const calculateTargetPosition = () => {
    const MIN_OFFSET = 0.0004; // Base offset distance in degrees
    const useSpiral = totalMarkers > 8;
    
    if (useSpiral) {
      // Spiral pattern - markers get progressively further out
      const spiralAngleDelta = 2 * Math.PI / 6; // How much to rotate per spiral
      const angle = index * spiralAngleDelta;
      const radius = MIN_OFFSET * (1 + Math.floor(index / 6) * 0.5);
      
      return {
        latitude: baseCoordinate.latitude + radius * Math.sin(angle),
        longitude: baseCoordinate.longitude + radius * Math.cos(angle)
      };
    } else {
      // Circle pattern - evenly distribute markers in a circle
      const angle = index * (2 * Math.PI / totalMarkers);
      const radius = MIN_OFFSET;
      
      return {
        latitude: baseCoordinate.latitude + radius * Math.sin(angle),
        longitude: baseCoordinate.longitude + radius * Math.cos(angle)
      };
    }
  };
  
  const targetPosition = calculateTargetPosition();
  
  // Calculate the interpolated position
  const latitude = animation.interpolate({
    inputRange: [0, 1],
    outputRange: [baseCoordinate.latitude, targetPosition.latitude]
  });
  
  const longitude = animation.interpolate({
    inputRange: [0, 1],
    outputRange: [baseCoordinate.longitude, targetPosition.longitude]
  });
  
  // Animate to the spiderfied position
  useEffect(() => {
    // Stagger the animations slightly
    const delay = index * 40;
    
    Animated.timing(animation, {
      toValue: 1,
      duration: 300,
      delay,
      useNativeDriver: false // Native driver doesn't work with coordinates
    }).start(() => {
      if (index === totalMarkers - 1 && onAnimationComplete) {
        onAnimationComplete();
      }
    });
    
    return () => {
      // Animate back when component unmounts
      Animated.timing(animation, {
        toValue: 0,
        duration: 200,
        useNativeDriver: false
      }).start();
    };
  }, []);

  return (
    <Marker
      coordinate={{
        latitude,
        longitude
      }}
      tracksViewChanges={Platform.OS === 'ios'} // iOS needs this set to true
      onPress={() => onPress(marker)}
    >
      <EnhancedUserMapMarker
        photoURL={marker.photoURL}
        distance={marker.distance}
        name={marker.name}
        tier={marker.tier}
        sharedInterestsCount={marker.sharedInterestsCount}
        online={marker.online}
      />
    </Marker>
  );
};

interface MarkerSpiderfierProps {
  markers: any[];
  baseCoordinate: {
    latitude: number;
    longitude: number;
  };
  onMarkerPress: (marker: any) => void;
  onClose: () => void;
}

const MarkerSpiderfier: React.FC<MarkerSpiderfierProps> = ({
  markers,
  baseCoordinate,
  onMarkerPress,
  onClose
}) => {
  const [animationComplete, setAnimationComplete] = useState(false);
  
  // Handle animation completion
  const handleAnimationComplete = () => {
    setAnimationComplete(true);
  };

  return (
    <>
      {/* Line connecting to base coordinate */}
      {markers.map((marker, index) => (
        <SpiderfiedMarker
          key={`spider-${marker.uid}-${index}`}
          marker={marker}
          index={index}
          totalMarkers={markers.length}
          baseCoordinate={baseCoordinate}
          onPress={onMarkerPress}
          onAnimationComplete={handleAnimationComplete}
        />
      ))}
      
      {/* Close button */}
      {animationComplete && (
        <Marker
          coordinate={baseCoordinate}
          tracksViewChanges={Platform.OS === 'ios'}
          onPress={onClose}
        >
          <TouchableOpacity style={styles.closeButton} onPress={onClose}>
            <Text style={styles.closeText}></Text>
          </TouchableOpacity>
        </Marker>
      )}
    </>
  );
};

const styles = StyleSheet.create({
  closeButton: {
    backgroundColor: 'rgba(255, 0, 0, 0.8)',
    width: 28,
    height: 28,
    borderRadius: 14,
    justifyContent: 'center',
    alignItems: 'center',
    borderWidth: 2,
    borderColor: 'white',
  },
  closeText: {
    color: 'white',
    fontSize: 18,
    fontWeight: 'bold',
    textAlign: 'center',
    marginTop: -2,
  },
});

export default MarkerSpiderfier;
</file>

<file path="components/maps/UserMapMarker.tsx">
import React, { useState } from 'react';
import { View, Image, Text, StyleSheet } from 'react-native';
import FontAwesome from '@expo/vector-icons/FontAwesome';

/**
 * Custom marker component for maps that displays a user's profile photo
 */
const UserMapMarker = ({ photoURL, distance, name }) => {
  const [imageLoaded, setImageLoaded] = useState(false);
  const [imageError, setImageError] = useState(false);
  
  // Log props for debugging
  console.log('UserMapMarker props:', { 
    photoURL: photoURL ? 'exists' : 'missing', 
    photoURLLength: photoURL ? photoURL.length : 0,
    distance, 
    name 
  });

  // Handle image load error
  const handleImageError = (error) => {
    console.error('Image load error:', error.nativeEvent.error);
    setImageError(true);
  };

  // Handle image load success
  const handleImageLoad = () => {
    console.log('Image loaded successfully for:', name);
    setImageLoaded(true);
  };

  return (
    <View style={styles.container}>
      <View style={styles.imageContainer}>
        {photoURL && !imageError ? (
          <Image 
            source={{ uri: photoURL }} 
            style={styles.image}
            onLoad={handleImageLoad}
            onError={handleImageError}
          />
        ) : (
          <View style={styles.defaultImage}>
            <FontAwesome name="user" size={20} color="#fff" />
            {imageError && <Text style={styles.errorIndicator}>!</Text>}
          </View>
        )}
      </View>
      {distance && (
        <View style={styles.distanceContainer}>
          <Text style={styles.distanceText}>{distance}m</Text>
        </View>
      )}
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    alignItems: 'center',
    width: 80,
    height: 70,
  },
  imageContainer: {
    width: 40,
    height: 40,
    borderRadius: 20,
    backgroundColor: '#fff',
    justifyContent: 'center',
    alignItems: 'center',
    borderWidth: 2,
    borderColor: '#007bff',
    overflow: 'hidden',
  },
  image: {
    width: 40,
    height: 40,
    borderRadius: 20,
    resizeMode: 'cover',
  },
  defaultImage: {
    width: 40,
    height: 40,
    borderRadius: 20,
    backgroundColor: '#007bff',
    justifyContent: 'center',
    alignItems: 'center',
  },
  distanceContainer: {
    backgroundColor: 'rgba(0, 123, 255, 0.8)',
    paddingHorizontal: 8,
    paddingVertical: 2,
    borderRadius: 10,
    marginTop: 4,
  },
  distanceText: {
    color: '#fff',
    fontSize: 10,
    fontWeight: 'bold',
  },
  errorIndicator: {
    position: 'absolute',
    bottom: 2,
    right: 2,
    color: '#ff0000',
    fontSize: 10,
    fontWeight: 'bold',
  },
});

export default UserMapMarker;
</file>

<file path="components/navigation/FloatingTabBar.tsx">
import React, { useState, useEffect } from 'react';
import { 
  View, 
  StyleSheet, 
  TouchableOpacity, 
  Text, 
  Dimensions,
  Platform
} from 'react-native';
import { useSafeAreaInsets } from 'react-native-safe-area-context';
import { BlurView } from 'expo-blur';
import Animated, { 
  useAnimatedStyle, 
  withSpring, 
  useSharedValue,
  withTiming,
  Easing
} from 'react-native-reanimated';
import FontAwesome from '@expo/vector-icons/FontAwesome';
import Colors from '@/constants/Colors';
import { useColorScheme } from '@/components/useColorScheme';
import { LinearGradient } from 'expo-linear-gradient';

const { width: SCREEN_WIDTH } = Dimensions.get('window');
const TAB_BAR_HEIGHT = 70;
const ICON_SIZE = 24;
const ACTIVE_ICON_SIZE = 26;

type FloatingTabBarProps = {
  state: any;
  descriptors: any;
  navigation: any;
};

export default function FloatingTabBar({ state, descriptors, navigation }: FloatingTabBarProps) {
  const colorScheme = useColorScheme();
  const insets = useSafeAreaInsets();
  const [selectedTab, setSelectedTab] = useState(state.index);
  
  // Count visible routes (excluding any with href: null and the index route)
  const visibleRoutes = state.routes.filter(route => {
    const { options } = descriptors[route.key];
    return options.href !== null && route.name !== "index";
  });
  
  // Create scale animation values for each tab upfront
  const tabScales = state.routes.map((_, index) => 
    useSharedValue(state.index === index ? 1 : 0.85)
  );
  
  // Update selected tab when route changes
  useEffect(() => {
    setSelectedTab(state.index);
    
    // Update all tab animations
    state.routes.forEach((_, index) => {
      tabScales[index].value = withSpring(
        state.index === index ? 1 : 0.85,
        { damping: 15, stiffness: 120 }
      );
    });
  }, [state.index]);
  
  // Fade-in animation for the tab bar
  const opacity = useSharedValue(0);
  
  useEffect(() => {
    opacity.value = withTiming(1, {
      duration: 500,
      easing: Easing.out(Easing.ease),
    });
  }, []);
  
  const containerStyle = useAnimatedStyle(() => {
    return {
      opacity: opacity.value,
      transform: [
        { translateY: withTiming((1 - opacity.value) * 20, { duration: 500 }) }
      ],
    };
  });
  
  return (
    <Animated.View style={[styles.container, containerStyle]}>
      <View 
        style={[
          styles.floatingBar,
          {
            backgroundColor: 
              colorScheme === 'dark' 
                ? 'rgba(30, 30, 30, 0.95)' 
                : 'rgba(255, 255, 255, 0.97)',
            shadowColor: colorScheme === 'dark' ? '#000' : '#888',
            paddingBottom: insets.bottom > 0 ? insets.bottom - 10 : 16,
          }
        ]}
      >
        {Platform.OS === 'ios' && (
          <BlurView
            intensity={colorScheme === 'dark' ? 30 : 50}
            tint={colorScheme === 'dark' ? "dark" : "light"}
            style={StyleSheet.absoluteFill}
          />
        )}
        
        <View style={styles.tabContainer}>
          {state.routes.map((route, index) => {
            const { options } = descriptors[route.key];
            
            // Skip hidden tabs or the "index" tab
            if (options.href === null || route.name === "index") {
              return null;
            }
            
            const isFocused = state.index === index;
            
            // Get the pre-created animation value for this tab
            const animatedIconStyle = useAnimatedStyle(() => {
              return {
                transform: [{ scale: tabScales[index].value }],
              };
            });
            
            const onPress = () => {
              const event = navigation.emit({
                type: 'tabPress',
                target: route.key,
                canPreventDefault: true,
              });

              if (!isFocused && !event.defaultPrevented) {
                navigation.navigate(route.name);
              }
            };

            return (
              <TouchableOpacity
                key={route.key}
                accessibilityRole="button"
                accessibilityState={isFocused ? { selected: true } : {}}
                accessibilityLabel={options.tabBarAccessibilityLabel}
                testID={options.tabBarTestID}
                onPress={onPress}
                style={styles.tab}
                activeOpacity={0.7}
              >
                <Animated.View style={[
                  isFocused ? styles.activeIconContainer : styles.inactiveIconContainer,
                  animatedIconStyle
                ]}>
                  {isFocused ? (
                    <LinearGradient
                      colors={[Colors.primary, Colors.primaryLight]}
                      style={styles.activeIconBackground}
                      start={{ x: 0, y: 0 }}
                      end={{ x: 1, y: 1 }}
                    >
                      {options.tabBarIcon && options.tabBarIcon({ 
                        color: '#FFFFFF', 
                        focused: true,
                        size: ACTIVE_ICON_SIZE
                      })}
                    </LinearGradient>
                  ) : (
                    <>
                      {options.tabBarIcon && options.tabBarIcon({ 
                        color: Colors[colorScheme]?.tabIconDefault || '#888', 
                        focused: false,
                        size: ICON_SIZE
                      })}
                    </>
                  )}
                </Animated.View>
                
                <Text
                  style={[
                    styles.tabLabel,
                    {
                      color: isFocused 
                        ? Colors[colorScheme]?.tabIconSelected 
                        : Colors[colorScheme]?.tabIconDefault,
                      opacity: isFocused ? 1 : 0.7,
                    }
                  ]}
                  numberOfLines={1}
                >
                  {options.title}
                </Text>
              </TouchableOpacity>
            );
          })}
        </View>
      </View>
    </Animated.View>
  );
}

const styles = StyleSheet.create({
  container: {
    position: 'absolute',
    bottom: 0,
    left: 0,
    right: 0,
    width: '100%',
    margin: 0,
    padding: 0,
  },
  floatingBar: {
    width: '100%',
    borderRadius: 0,
    paddingTop: 12,
    paddingHorizontal: 0,
    margin: 0,
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.15,
    shadowRadius: 16,
    elevation: 10,
    borderTopWidth: StyleSheet.hairlineWidth,
    borderColor: 'rgba(150, 150, 150, 0.2)',
  },
  tabContainer: {
    flexDirection: 'row',
    width: '100%',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingHorizontal: 0,
    margin: 0,
  },
  tab: {
    alignItems: 'center',
    paddingVertical: 4,
    flex: 1,
    paddingHorizontal: 0,
    margin: 0,
  },
  activeIconContainer: {
    height: 45,
    width: 45,
    justifyContent: 'center',
    alignItems: 'center',
    marginBottom: 5,
  },
  inactiveIconContainer: {
    height: 45,
    width: 45,
    justifyContent: 'center',
    alignItems: 'center',
    marginBottom: 5,
  },
  activeIconBackground: {
    width: 45,
    height: 45,
    borderRadius: 22.5,
    justifyContent: 'center',
    alignItems: 'center',
    shadowColor: Colors.primary,
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.3,
    shadowRadius: 8,
    elevation: 5,
  },
  tabLabel: {
    fontSize: 11,
    fontWeight: '600',
    textAlign: 'center',
    width: '100%',
    paddingHorizontal: 2,
  },
});
</file>

<file path="components/navigation/ModernTabBar.tsx">
import React, { useEffect, useState } from 'react';
import { 
  View, 
  TouchableOpacity, 
  Text, 
  StyleSheet, 
  Dimensions, 
  Platform, 
  useWindowDimensions,
  LayoutAnimation,
  UIManager
} from 'react-native';
import { useSafeAreaInsets } from 'react-native-safe-area-context';
import Animated, { 
  useAnimatedStyle, 
  withSpring, 
  useSharedValue 
} from 'react-native-reanimated';
import { BlurView } from 'expo-blur';
import Colors from '@/constants/Colors';
import { useColorScheme } from '@/components/useColorScheme';
import { LinearGradient } from 'expo-linear-gradient';
import { usePathname } from 'expo-router';

// Enable layout animation for Android
if (Platform.OS === 'android' && UIManager.setLayoutAnimationEnabledExperimental) {
  UIManager.setLayoutAnimationEnabledExperimental(true);
}

const { width: SCREEN_WIDTH } = Dimensions.get('window');

type TabBarProps = {
  state: any;
  descriptors: any;
  navigation: any;
};

const TabBarIndicator = ({ position, tabWidth }: { position: number, tabWidth: number }) => {
  const colorScheme = useColorScheme();
  const xPos = position * tabWidth;

  return (
    <Animated.View 
      style={[
        styles.indicator,
        {
          width: tabWidth * 0.5,
          left: xPos + tabWidth * 0.25, // Center the indicator within the tab
        }
      ]}
    >
      <LinearGradient
        colors={[Colors.primary, Colors.primaryLight]}
        start={{ x: 0, y: 0 }}
        end={{ x: 1, y: 0 }}
        style={styles.indicatorGradient}
      />
    </Animated.View>
  );
};

export default function ModernTabBar({ state, descriptors, navigation }: TabBarProps) {
  const colorScheme = useColorScheme();
  const insets = useSafeAreaInsets();
  const { width } = useWindowDimensions();
  const [activeTabIndex, setActiveTabIndex] = useState(state.index);
  const pathname = usePathname();
  
  // Calculate tab width based on screen size and number of visible routes
  const visibleRoutes = state.routes.filter(route => {
    const { options } = descriptors[route.key];
    return options.href !== null;
  });
  
  const tabWidth = width / visibleRoutes.length;
  
  // Update active tab when the route changes
  useEffect(() => {
    LayoutAnimation.configureNext(LayoutAnimation.Presets.easeInEaseOut);
    setActiveTabIndex(state.index);
  }, [state.index, pathname]);
  
  return (
    <View style={[
      styles.container,
      {
        paddingBottom: insets.bottom > 0 ? insets.bottom : 12,
        backgroundColor: Colors[colorScheme]?.tabBarBackground,
        borderTopColor: Colors[colorScheme]?.tabBarBorder,
      }
    ]}>
      {Platform.OS === 'ios' && colorScheme === 'dark' ? (
        <BlurView
          intensity={30}
          tint="dark"
          style={StyleSheet.absoluteFill}
        />
      ) : null}
      
      <TabBarIndicator position={activeTabIndex - 1} tabWidth={tabWidth} />
      
      <View style={styles.tabs}>
        {state.routes.map((route, index) => {
          const { options } = descriptors[route.key];
          
          // Skip hidden tabs
          if (options.href === null) {
            return null;
          }
          
          const isFocused = state.index === index;
          
          const onPress = () => {
            const event = navigation.emit({
              type: 'tabPress',
              target: route.key,
              canPreventDefault: true,
            });

            if (!isFocused && !event.defaultPrevented) {
              navigation.navigate(route.name);
            }
          };

          const onLongPress = () => {
            navigation.emit({
              type: 'tabLongPress',
              target: route.key,
            });
          };

          return (
            <TouchableOpacity
              key={route.key}
              accessibilityRole="button"
              accessibilityState={isFocused ? { selected: true } : {}}
              accessibilityLabel={options.tabBarAccessibilityLabel}
              testID={options.tabBarTestID}
              onPress={onPress}
              onLongPress={onLongPress}
              style={styles.tab}
              activeOpacity={0.8}
            >
              <View style={styles.tabContent}>
                {options.tabBarIcon && options.tabBarIcon({ 
                  color: isFocused 
                    ? Colors[colorScheme]?.tabIconSelected 
                    : Colors[colorScheme]?.tabIconDefault, 
                  size: 24,
                  focused: isFocused
                })}
                <Animated.Text 
                  style={[
                    styles.tabLabel,
                    { 
                      color: isFocused 
                        ? Colors[colorScheme]?.tabIconSelected 
                        : Colors[colorScheme]?.tabIconDefault,
                      opacity: isFocused ? 1 : 0.8,
                      transform: [{ scale: isFocused ? 1 : 0.9 }]
                    }
                  ]}
                  numberOfLines={1}
                >
                  {options.title}
                </Animated.Text>
              </View>
            </TouchableOpacity>
          );
        })}
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    width: '100%',
    borderTopWidth: 1,
    elevation: 8,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: -2 },
    shadowOpacity: 0.1,
    shadowRadius: 3,
    position: 'relative',
  },
  tabs: {
    flexDirection: 'row',
    paddingTop: 8,
  },
  tab: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center',
  },
  tabContent: {
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: 4,
  },
  tabLabel: {
    fontSize: 11,
    fontWeight: '500',
    marginTop: 4,
    textAlign: 'center',
  },
  indicator: {
    height: 3,
    borderRadius: 1.5,
    position: 'absolute',
    top: -1.5,
    zIndex: 2,
    overflow: 'hidden',
  },
  indicatorGradient: {
    flex: 1,
    borderRadius: 1.5,
  },
});
</file>

<file path="components/navigation/ModernTabBarIcon.tsx">
import React from 'react';
import { View, StyleSheet } from 'react-native';
import FontAwesome from '@expo/vector-icons/FontAwesome';
import Colors from '@/constants/Colors';
import { useColorScheme } from '@/components/useColorScheme';

type TabBarIconProps = {
  name: React.ComponentProps<typeof FontAwesome>['name'];
  color: string;
  size?: number;
  focused?: boolean;
};

export default function ModernTabBarIcon({ name, color, size = 24, focused = false }: TabBarIconProps) {
  const colorScheme = useColorScheme();
  
  return (
    <View style={styles.container}>
      <FontAwesome 
        name={name} 
        size={size} 
        color={color} 
        style={styles.icon} 
      />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    alignItems: 'center',
    justifyContent: 'center',
  },
  icon: {
    marginBottom: -2,
  },
});
</file>

<file path="components/navigation/PreciseTabBar.tsx">
import React from 'react';
import { 
  View, 
  Text, 
  StyleSheet, 
  TouchableOpacity, 
  Dimensions, 
  Platform 
} from 'react-native';
import { useSafeAreaInsets } from 'react-native-safe-area-context';
import FontAwesome from '@expo/vector-icons/FontAwesome';
import { LinearGradient } from 'expo-linear-gradient';
import Colors from '@/constants/Colors';
import { useColorScheme } from '@/components/useColorScheme';

const { width } = Dimensions.get('window');

/**
 * TabBar component that ensures precise alignment and equal width distribution
 */
export default function TabBar({ state, descriptors, navigation }) {
  const colorScheme = useColorScheme();
  const insets = useSafeAreaInsets();
  
  // Filter visible routes (exclude routes with href: null)
  const visibleRoutes = state.routes.filter(route => {
    const { options } = descriptors[route.key];
    return options.href !== null;
  });
  
  // Number of tabs to display
  const numTabs = visibleRoutes.length;
  
  // Calculate tab width (equal distribution)
  const tabWidth = width / numTabs;
  
  return (
    <View style={[
      styles.container, 
      { paddingBottom: insets.bottom > 0 ? insets.bottom : 8 }
    ]}>
      <View style={styles.tabBarContainer}>
        {state.routes.map((route, index) => {
          const { options } = descriptors[route.key];
          
          // Skip tabs with href: null
          if (options.href === null) {
            return null;
          }
          
          const label = options.tabBarLabel ?? options.title ?? route.name;
          const isFocused = state.index === index;
          
          const onPress = () => {
            const event = navigation.emit({
              type: 'tabPress',
              target: route.key,
              canPreventDefault: true,
            });

            if (!isFocused && !event.defaultPrevented) {
              navigation.navigate(route.name);
            }
          };

          const onLongPress = () => {
            navigation.emit({
              type: 'tabLongPress',
              target: route.key,
            });
          };

          return (
            <TouchableOpacity
              key={route.key}
              activeOpacity={0.7}
              accessibilityRole="button"
              accessibilityState={isFocused ? { selected: true } : {}}
              accessibilityLabel={options.tabBarAccessibilityLabel}
              testID={options.tabBarTestID}
              onPress={onPress}
              onLongPress={onLongPress}
              style={[styles.tab, { width: tabWidth }]}
            >
              <View style={styles.tabContent}>
                {isFocused ? (
                  <LinearGradient
                    colors={[Colors.primary, Colors.primaryLight]}
                    style={styles.activeIconContainer}
                    start={{ x: 0, y: 0 }}
                    end={{ x: 1, y: 1 }}
                  >
                    {options.tabBarIcon && options.tabBarIcon({
                      focused: true,
                      color: '#FFFFFF',
                      size: 24,
                    })}
                  </LinearGradient>
                ) : (
                  <View style={styles.inactiveIconContainer}>
                    {options.tabBarIcon && options.tabBarIcon({
                      focused: false,
                      color: Colors[colorScheme]?.tabIconDefault || '#888',
                      size: 22,
                    })}
                  </View>
                )}
                
                <Text
                  numberOfLines={1}
                  style={[
                    styles.label,
                    {
                      color: isFocused 
                        ? Colors[colorScheme]?.tabIconSelected 
                        : Colors[colorScheme]?.tabIconDefault,
                    }
                  ]}
                >
                  {label}
                </Text>
              </View>
            </TouchableOpacity>
          );
        })}
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    position: 'absolute',
    bottom: 0,
    left: 0,
    right: 0,
    backgroundColor: 'transparent',
    zIndex: 999,
  },
  tabBarContainer: {
    flexDirection: 'row',
    backgroundColor: Platform.OS === 'ios' 
      ? 'rgba(255, 255, 255, 0.95)'
      : 'rgba(255, 255, 255, 1)',
    borderTopWidth: StyleSheet.hairlineWidth,
    borderTopColor: 'rgba(0, 0, 0, 0.1)',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: -2 },
    shadowOpacity: 0.05,
    shadowRadius: 3,
    elevation: 5,
    height: 60,
  },
  tab: {
    height: '100%',
    alignItems: 'center',
    justifyContent: 'center',
  },
  tabContent: {
    alignItems: 'center',
    justifyContent: 'center',
  },
  activeIconContainer: {
    width: 48,
    height: 48,
    borderRadius: 24,
    alignItems: 'center',
    justifyContent: 'center',
    marginBottom: 2,
  },
  inactiveIconContainer: {
    width: 48,
    height: 48,
    alignItems: 'center',
    justifyContent: 'center',
    marginBottom: 2,
  },
  label: {
    fontSize: 10,
    fontWeight: '500',
    textAlign: 'center',
    marginTop: -8,
    width: '100%',
  },
});
</file>

<file path="components/navigation/README.md">
# HiveSocial Bottom Navigation

This document describes the bottom navigation components available in the HiveSocial app.

## Available Navigation Styles

The app now includes two modern bottom navigation styles that you can use:

1. **ModernTabBar** (Default) - A clean, modern tab bar with indicator and subtle animations
2. **FloatingTabBar** - A floating pill-shaped tab bar with more prominent animations

## How to Switch Between Navigation Styles

To use the ModernTabBar (default), your `_layout.tsx` should include:

```tsx
<Tabs
  screenOptions={{
    // options here
  }}
  tabBar={props => <ModernTabBar {...props} />}
>
  {/* Tab screens */}
</Tabs>
```

To use the FloatingTabBar, update your `_layout.tsx` to:

```tsx
<Tabs
  screenOptions={{
    // options here
    tabBarStyle: { 
      display: 'none' // Hide the default tab bar
    },
  }}
  tabBar={props => <FloatingTabBar {...props} />}
>
  {/* Tab screens */}
</Tabs>
```

## Implementation Details

### ModernTabBar

The ModernTabBar provides:
- Clean, minimalist design
- Animated indicator
- Gradient highlight for active tab
- Proper iOS/Android adaptations

### FloatingTabBar 

The FloatingTabBar provides:
- Floating appearance with rounded corners
- Larger icon for the active tab
- Gradient background for active tab
- Smooth animations between tab changes

## Design Principles

The navigation follows these design principles:

1. **Consistency**: Matches the visual styling of profile, chat, and connections screens
2. **Clarity**: Clear visual indication of the active tab
3. **Accessibility**: Proper contrast, touch targets, and visual feedback
4. **Modern Aesthetics**: Uses the app's color palette and rounded design language

## Primary Color Palette

The navigation uses the following color palette:
- Primary: #6C5CE7 (Purple)
- Primary Light: #a29bfe (Light Purple)
- Secondary: #FF6B6B (Red accent for notifications)

These colors align with the profile screen's color scheme.
</file>

<file path="components/screens/LoadingScreen.tsx">
import React from 'react';
import { View, ActivityIndicator, Text, StyleSheet } from 'react-native';
import FontAwesome from '@expo/vector-icons/FontAwesome';

interface LoadingScreenProps {
  message?: string;
}

export default function LoadingScreen({ message = 'Loading...' }: LoadingScreenProps) {
  return (
    <View style={styles.container}>
      <FontAwesome name="connectdevelop" size={80} color="#007bff" style={styles.logo} />
      <Text style={styles.appTitle}>HiveSocial</Text>
      <ActivityIndicator size="large" color="#007bff" style={styles.spinner} />
      <Text style={styles.message}>{message}</Text>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#ffffff',
  },
  logo: {
    marginBottom: 16,
  },
  appTitle: {
    fontSize: 24,
    fontWeight: 'bold',
    color: '#333',
    marginBottom: 40,
  },
  spinner: {
    marginBottom: 16,
  },
  message: {
    fontSize: 16,
    color: '#666',
    textAlign: 'center',
    paddingHorizontal: 20,
  },
});
</file>

<file path="components/EditScreenInfo.tsx">
import React from 'react';
import { StyleSheet } from 'react-native';

import { ExternalLink } from './ExternalLink';
import { MonoText } from './StyledText';
import { Text, View } from './Themed';

import Colors from '@/constants/Colors';

export default function EditScreenInfo({ path }: { path: string }) {
  return (
    <View>
      <View style={styles.getStartedContainer}>
        <Text
          style={styles.getStartedText}
          lightColor="rgba(0,0,0,0.8)"
          darkColor="rgba(255,255,255,0.8)">
          Open up the code for this screen:
        </Text>

        <View
          style={[styles.codeHighlightContainer, styles.homeScreenFilename]}
          darkColor="rgba(255,255,255,0.05)"
          lightColor="rgba(0,0,0,0.05)">
          <MonoText>{path}</MonoText>
        </View>

        <Text
          style={styles.getStartedText}
          lightColor="rgba(0,0,0,0.8)"
          darkColor="rgba(255,255,255,0.8)">
          Change any of the text, save the file, and your app will automatically update.
        </Text>
      </View>

      <View style={styles.helpContainer}>
        <ExternalLink
          style={styles.helpLink}
          href="https://docs.expo.io/get-started/create-a-new-app/#opening-the-app-on-your-phonetablet">
          <Text style={styles.helpLinkText} lightColor={Colors.light.tint}>
            Tap here if your app doesn't automatically update after making changes
          </Text>
        </ExternalLink>
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  getStartedContainer: {
    alignItems: 'center',
    marginHorizontal: 50,
  },
  homeScreenFilename: {
    marginVertical: 7,
  },
  codeHighlightContainer: {
    borderRadius: 3,
    paddingHorizontal: 4,
  },
  getStartedText: {
    fontSize: 17,
    lineHeight: 24,
    textAlign: 'center',
  },
  helpContainer: {
    marginTop: 15,
    marginHorizontal: 20,
    alignItems: 'center',
  },
  helpLink: {
    paddingVertical: 15,
  },
  helpLinkText: {
    textAlign: 'center',
  },
});
</file>

<file path="components/ExternalLink.tsx">
import { Link } from 'expo-router';
import * as WebBrowser from 'expo-web-browser';
import React from 'react';
import { Platform } from 'react-native';

export function ExternalLink(
  props: Omit<React.ComponentProps<typeof Link>, 'href'> & { href: string }
) {
  return (
    <Link
      target="_blank"
      {...props}
      // @ts-expect-error: External URLs are not typed.
      href={props.href}
      onPress={(e) => {
        if (Platform.OS !== 'web') {
          // Prevent the default behavior of linking to the default browser on native.
          e.preventDefault();
          // Open the link in an in-app browser.
          WebBrowser.openBrowserAsync(props.href as string);
        }
      }}
    />
  );
}
</file>

<file path="components/StyledText.tsx">
import { Text, TextProps } from './Themed';

export function MonoText(props: TextProps) {
  return <Text {...props} style={[props.style, { fontFamily: 'SpaceMono' }]} />;
}
</file>

<file path="components/Themed.tsx">
/**
 * Learn more about Light and Dark modes:
 * https://docs.expo.io/guides/color-schemes/
 */

import { Text as DefaultText, View as DefaultView } from 'react-native';

import Colors from '@/constants/Colors';
import { useColorScheme } from './useColorScheme';

type ThemeProps = {
  lightColor?: string;
  darkColor?: string;
};

export type TextProps = ThemeProps & DefaultText['props'];
export type ViewProps = ThemeProps & DefaultView['props'];

export function useThemeColor(
  props: { light?: string; dark?: string },
  colorName: keyof typeof Colors.light & keyof typeof Colors.dark
) {
  const theme = useColorScheme() ?? 'light';
  const colorFromProps = props[theme];

  if (colorFromProps) {
    return colorFromProps;
  } else {
    return Colors[theme][colorName];
  }
}

export function Text(props: TextProps) {
  const { style, lightColor, darkColor, ...otherProps } = props;
  const color = useThemeColor({ light: lightColor, dark: darkColor }, 'text');

  return <DefaultText style={[{ color }, style]} {...otherProps} />;
}

export function View(props: ViewProps) {
  const { style, lightColor, darkColor, ...otherProps } = props;
  const backgroundColor = useThemeColor({ light: lightColor, dark: darkColor }, 'background');

  return <DefaultView style={[{ backgroundColor }, style]} {...otherProps} />;
}
</file>

<file path="components/useClientOnlyValue.ts">
// This function is web-only as native doesn't currently support server (or build-time) rendering.
export function useClientOnlyValue<S, C>(server: S, client: C): S | C {
  return client;
}
</file>

<file path="components/useClientOnlyValue.web.ts">
import React from 'react';

// `useEffect` is not invoked during server rendering, meaning
// we can use this to determine if we're on the server or not.
export function useClientOnlyValue<S, C>(server: S, client: C): S | C {
  const [value, setValue] = React.useState<S | C>(server);
  React.useEffect(() => {
    setValue(client);
  }, [client]);

  return value;
}
</file>

<file path="components/useColorScheme.ts">
export { useColorScheme } from 'react-native';
</file>

<file path="components/useColorScheme.web.ts">
// NOTE: The default React Native styling doesn't support server rendering.
// Server rendered styles should not change between the first render of the HTML
// and the first render on the client. Typically, web developers will use CSS media queries
// to render different styles on the client and server, these aren't directly supported in React Native
// but can be achieved using a styling library like Nativewind.
export function useColorScheme() {
  return 'light';
}
</file>

<file path="contexts/AuthContext.tsx">
import React, { createContext, useContext, useState, useEffect, useRef } from 'react';
import { onAuthStateChanged } from '@firebase/auth';
import { doc, getDoc } from '@firebase/firestore';
import { auth, db } from '../config/firebase';
import { useProtectedRoute } from './useProtectedRoute';
import { useRouter, useSegments, usePathname } from 'expo-router';
import { Platform } from 'react-native';

// Define types
type User = {
  uid: string;
  email: string;
  name?: string;
  bio?: string;
  interests?: string[];
  photoURL?: string;
  profileImages?: string[]; // Array of image URLs for profile grid
  location?: {
    visible: boolean;
  };
} | null;

type AuthContextType = {
  user: User;
  userData: any;
  loading: boolean;
  refreshUserData: () => Promise<void>;
  signOut: () => Promise<void>;
};

// Create the context
const AuthContext = createContext<AuthContextType | undefined>(undefined);

// Create a provider component
export function AuthProvider({ children }: { children: React.ReactNode }) {
  const [user, setUser] = useState<User>(null);
  const [userData, setUserData] = useState<any>(null);
  const [loading, setLoading] = useState(true);
  const router = useRouter();
  const pathname = usePathname();
  const segments = useSegments();
  const authCheckComplete = useRef(false);
  const isNavigating = useRef(false);

  // Debug logging
  useEffect(() => {
    console.log('Auth state changed:', { 
      user: user ? 'Authenticated' : 'Not authenticated', 
      loading, 
      pathname, 
      segments,
      platform: Platform.OS
    });
    
    // When auth check is complete and user is authenticated,
    // log additional info to help with debugging
    if (!loading && user) {
      console.log('User authenticated:', {
        uid: user.uid,
        hasUserData: !!userData,
        pathname,
      });
    }
  }, [user, loading, pathname, segments, userData]);

  // Function to fetch user data from Firestore
  const fetchUserData = async (uid: string) => {
    try {
      const userDocRef = doc(db, 'users', uid);
      const userDoc = await getDoc(userDocRef);
      if (userDoc.exists()) {
        setUserData(userDoc.data());
      } else {
        console.log('No user data found in Firestore');
      }
    } catch (error) {
      console.error('Error fetching user data:', error);
    }
  };

  // Function to refresh user data
  const refreshUserData = async () => {
    if (user?.uid) {
      await fetchUserData(user.uid);
    }
  };

  // Sign out function
  const signOut = async () => {
    try {
      console.log('Signing out user...');
      await auth.signOut();
      console.log('User signed out');
      
      // Reset state
      setUser(null);
      setUserData(null);
      
      // Clear AsyncStorage cache if needed
      // This might be needed in some cases if there are persistence issues
      // await AsyncStorage.clear();
      
      // Navigate to login
      router.replace('/auth/login');
    } catch (error) {
      console.error('Error signing out:', error);
    }
  };

  // Handle direct navigation to fixed routes based on auth state
  const navigateToInitialScreen = () => {
    // Skip if already navigating
    if (isNavigating.current) return;
    isNavigating.current = true;
    
    // Navigate to the appropriate screen based on auth state
    try {
      console.log('Navigating to initial screen based on auth state:', user ? 'Authenticated' : 'Not authenticated');
      if (user) {
        // User is authenticated, navigate to tabs index which will redirect to map
        router.replace('/');
      } else {
        // User is not authenticated, navigate to login
        router.replace('/auth/login');
      }
    } catch (e) {
      console.error('Navigation error:', e);
    } finally {
      // Reset navigation flag after a delay
      setTimeout(() => {
        isNavigating.current = false;
      }, 500);
    }
  };

  // When Firebase auth state changes, set user and navigate
  useEffect(() => {
    let unsubscribe: () => void;
    let initialAuthCheckComplete = false;
    
    const setupAuthListener = async () => {
      console.log('Setting up Firebase auth state listener...');
      
      try {
        // Make sure we're loading while checking auth
        setLoading(true);
        
        // Set up the auth state change listener
        unsubscribe = onAuthStateChanged(auth, async (authUser) => {
          console.log('Firebase auth state changed:', authUser ? 'Logged in' : 'Logged out');
          
          if (authUser) {
            // User is signed in
            setUser({
              uid: authUser.uid,
              email: authUser.email || '',
            });
            
            // Fetch additional user data from Firestore
            await fetchUserData(authUser.uid);
            
            // Let any navigation happen naturally from the root component
            // after we set loading to false
          } else {
            // User is signed out
            setUser(null);
            setUserData(null);
          }
          
          initialAuthCheckComplete = true;
          
          // After we've determined the auth state, turn off loading
          setLoading(false);
          authCheckComplete.current = true;
        });
      } catch (error) {
        console.error('Error setting up auth listener:', error);
        setLoading(false);
        authCheckComplete.current = true;
      }
    };
    
    setupAuthListener();

    // Cleanup subscription
    return () => {
      if (unsubscribe) unsubscribe();
    };
  }, []);

  // Handle navigation when pathname is not-found or index
  useEffect(() => {
    if (loading) return;
    if (!authCheckComplete.current) return;
    
    // Check if we're on the not-found screen
    if (segments && segments.length > 0 && segments[0] === '+not-found') {
      console.log('On not-found screen, navigating to initial screen');
      navigateToInitialScreen();
      return;
    }
    
    // Check if we're on the root index with no segments
    if ((!segments || segments.length === 0) && pathname === '/') {
      console.log('On root path, navigating to initial screen');
      navigateToInitialScreen();
      return;
    }
  }, [loading, pathname, segments, user]);

  // Use the protected route hook
  useProtectedRoute(user);

  return (
    <AuthContext.Provider value={{ user, userData, loading, refreshUserData, signOut }}>
      {children}
    </AuthContext.Provider>
  );
}

// Create a hook to use the auth context
export function useAuth() {
  const context = useContext(AuthContext);
  if (context === undefined) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
}
</file>

<file path="contexts/useProtectedRoute.js">
// Re-export from TypeScript file
export { useProtectedRoute } from './useProtectedRoute.tsx';
</file>

<file path="contexts/useProtectedRoute.tsx">
// useProtectedRoute.tsx
import { useEffect, useRef } from 'react';
import { useSegments, useRouter } from 'expo-router';

/**
 * Hook to protect routes based on authentication state
 * @param user - The current user object
 * @returns void
 */
export function useProtectedRoute(user: any) {
  const segments = useSegments();
  const router = useRouter();
  const isNavigating = useRef(false);
  
  // Log current route info
  useEffect(() => {
    if (segments && segments.length > 0) {
      console.log('useProtectedRoute - Current route:', { 
        segments, 
        isAuth: user ? true : false,
        inAuthGroup: segments[0] === 'auth'
      });
    }
  }, [segments, user]);
  
  // Only run basic route protection logic
  useEffect(() => {
    // Skip if we're already navigating or if user state is not defined yet
    if (isNavigating.current || user === undefined || !segments || segments.length === 0) {
      return;
    }

    // Always ignore not-found screens
    if (segments[0] === '+not-found') {
      return;
    }

    // Get the current route group (first segment)
    const inAuthGroup = segments[0] === 'auth';

    // Handle authenticated users trying to access auth screens
    if (user && inAuthGroup) {
      console.log('User is authenticated but on auth screen, redirecting to home...');
      isNavigating.current = true;
      router.replace('/');
      
      // Reset navigation flag after delay
      setTimeout(() => {
        isNavigating.current = false;
      }, 500);
      return;
    }
    
    // Handle unauthenticated users trying to access protected routes
    if (!user && !inAuthGroup) {
      console.log('User is NOT authenticated but trying to access protected route, redirecting to login...');
      isNavigating.current = true;
      router.replace('/auth/login');
      
      // Reset navigation flag after delay
      setTimeout(() => {
        isNavigating.current = false;
      }, 500);
      return;
    }
  }, [user, segments, router]);
}
</file>

<file path="ios/GoogleService-Info.plist">
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>API_KEY</key>
	<string>AIzaSyDthqZjSpEDLd4s6SRQ5U-Wfbb2Zve3lP0</string>
	<key>GCM_SENDER_ID</key>
	<string>224390534339</string>
	<key>PLIST_VERSION</key>
	<string>1</string>
	<key>BUNDLE_ID</key>
	<string>com.romanabad.hivesocial</string>
	<key>PROJECT_ID</key>
	<string>hivesocial-75456</string>
	<key>STORAGE_BUCKET</key>
	<string>hivesocial-75456.firebasestorage.app</string>
	<key>IS_ADS_ENABLED</key>
	<false></false>
	<key>IS_ANALYTICS_ENABLED</key>
	<false></false>
	<key>IS_APPINVITE_ENABLED</key>
	<true></true>
	<key>IS_GCM_ENABLED</key>
	<true></true>
	<key>IS_SIGNIN_ENABLED</key>
	<true></true>
	<key>GOOGLE_APP_ID</key>
	<string>1:224390534339:ios:c719c50a819089ca65fe76</string>
</dict>
</plist>
</file>

<file path=".gitignore">
# Learn more https://docs.github.com/en/get-started/getting-started-with-git/ignoring-files

# dependencies
node_modules/

# Expo
.expo/
dist/
web-build/
expo-env.d.ts

# Native
.kotlin/
*.orig.*
*.jks
*.p8
*.p12
*.key
*.mobileprovision

# Metro
.metro-health-check*

# debug
npm-debug.*
yarn-debug.*
yarn-error.*

# macOS
.DS_Store
*.pem

# local env files
.env*.local

# typescript
*.tsbuildinfo
</file>

<file path="MAP_SCREEN_UPDATE.md">
# HiveSocial Map Screen Update

## New Features Implemented

### Filtering System
- **Interest Filters**: Users can filter by specific interests to only see users who have selected interests
- **Minimum Shared Interests**: Filter by a threshold of shared interests (1-15)
- **Filter Drawer**: Side panel with filtering controls accessible via the filter button
- **Swipe to Close**: Swipe left to close the filter drawer
- **Filter Indication**: Active filters are indicated by highlighting the filter button
- **Bilateral Filtering**: Only shows users who mutually meet each other's filter criteria

### Map Overlapping Markers
- Implemented an algorithm to slightly offset users at the same location
- Higher tier matches (more shared interests) are shown on top
- Markers are positioned in a circular pattern around overlapping points

### Real-time Updates
- Live updates when users' status changes
- Online status indicator for users who are currently active
- Session management that updates presence when logging in/out

### Geospatial Querying
- Efficient algorithm to find users within proximity
- Quarter-mile radius visualization (400 meters)
- Displays users within the specified radius

### Privacy Controls
- **Visibility Toggle**: Button to hide or show your location to other users
- **Online Status**: Ability to see which users are currently online

## Implementation Details

### Presence System
- Implemented using Firebase Realtime Database and Firestore
- Real-time status updates
- Automatic background/foreground state detection

### Filter Drawer
- Animated side panel with intuitive controls
- Categorized interests for easier selection
- Visual indication of active filters
- Custom implementation of number input without external dependencies

### Marker Offsetting
- Smart algorithm that maintains relative positions
- Prioritizes higher-tier matches when overlapping
- Ensures all markers are visible even in crowded areas

### User Interface Improvements
- Enhanced marker visualization with online indicators
- Profile cards show online status
- Filter status indicators
- Improved information panel with filter status

## Performance Optimizations
- Pre-fetching of profile images
- Separation of data fetching and filtering
- Efficient geospatial calculations
- Real-time data is only fetched when needed
- Filtered user list is cached for performance

## Technologies Used
- React Native
- Firebase Firestore
- Firebase Realtime Database
- GeoHash-based proximity queries
- Animated API for smooth transitions
- PanResponder for swipe gestures

## Implementation Notes
- Custom implementation for slider functionality to avoid external dependencies
- Modified presence system to work without NetInfo dependency
- Used existing React Native components where possible
</file>

<file path="metro.config.js">
const { getDefaultConfig } = require('expo/metro-config');

const config = getDefaultConfig(__dirname, {
  // Enable the Expo Router extension for metro
  projectRoot: __dirname,
});

// Firebase compatibility fixes for Expo SDK 53
config.resolver.sourceExts.push('cjs');
config.resolver.unstable_enablePackageExports = false;

module.exports = config;
</file>

<file path="tsconfig.json">
{
  "extends": "expo/tsconfig.base",
  "compilerOptions": {
    "strict": true,
    "paths": {
      "@/*": [
        "./*"
      ]
    }
  },
  "include": [
    "**/*.ts",
    "**/*.tsx",
    ".expo/types/**/*.ts",
    "expo-env.d.ts"
  ]
}
</file>

<file path="UI_IMPROVEMENTS.md">
# Map Screen UI Improvements

## Changes Implemented

### Visibility Toggle Switch
- Replaced the visibility toggle button with a modern Switch component
- Added a text label to indicate the current visibility state
- Improved visual feedback with color changes (green for visible, red for hidden)

### Profile Card Slide-in from Top
- Redesigned the profile card to slide in from the top of the screen
- Positioned it to appear below the status bar, avoiding any overlap with tab navigation
- Added swipe-up gesture to dismiss the profile card
- Improved animation timing and easing for smoother transitions

### Responsive Layout
- Added dynamic positioning based on safe area insets
- Improved compatibility with different iOS and Android devices
- Ensured proper spacing around navigation elements

### Additional UI Refinements
- Enhanced online status indicator visibility
- Improved button positioning and spacing
- Added shadow effects for better visual hierarchy
- Optimized transitions and animations for smoother performance

## Implementation Details

### Switch Component
Implemented using the native React Native Switch component for a platform-specific look and feel. The switch provides visual feedback through:
- Color transitions based on state
- Clear text labels for additional context
- Proper positioning in the UI hierarchy

### Profile Card Improvements
The profile card now slides in from the top with several usability enhancements:
- Close button for easy dismissal
- Drag handle with animation feedback
- Optimized layout that doesn't interfere with navigation tabs
- Smooth animation effects for a polished experience

### Geospatial and Status Updates
- Maintained all existing functionality for map overlapping markers
- Preserved real-time updates for user status
- Retained all filtering capabilities with improved UI feedback

## Technologies Used
- React Native Switch component
- Animated API for smooth transitions
- PanResponder for swipe gesture detection
- Platform-specific styling for native look and feel
</file>

<file path="app/(tabs)/index.tsx">
import { Redirect } from 'expo-router';

// This file redirects from the root tab screen to the map screen
export default function Index() {
  // Use Redirect component instead of router.replace for cleaner navigation
  return <Redirect href="/map" />;
}
</file>

<file path="app/chat/[id].tsx">
import React, { useState, useEffect, useCallback, useRef } from 'react';
import { 
  StyleSheet, 
  View, 
  Text, 
  TextInput, 
  TouchableOpacity, 
  FlatList, 
  KeyboardAvoidingView, 
  Platform, 
  Image, 
  ActivityIndicator,
  Animated,
  Dimensions,
  SafeAreaView
} from 'react-native';
import { Stack, useLocalSearchParams, router } from 'expo-router';
import { StatusBar } from 'expo-status-bar';
import { BlurView } from 'expo-blur';
import { LinearGradient } from 'expo-linear-gradient';
import FontAwesome from '@expo/vector-icons/FontAwesome';
import MaterialIcons from '@expo/vector-icons/MaterialIcons';
import Ionicons from '@expo/vector-icons/Ionicons';
import { useAuth } from '@/contexts/AuthContext';
import { 
  collection, 
  query, 
  where, 
  getDocs, 
  orderBy, 
  onSnapshot, 
  doc, 
  getDoc, 
  addDoc,
  updateDoc,
  serverTimestamp,
  setDoc
} from '@firebase/firestore';
import { db } from '@/config/firebase';

const { width: SCREEN_WIDTH } = Dimensions.get('window');
const BUBBLE_MAX_WIDTH = SCREEN_WIDTH * 0.75;

export default function ChatRoomScreen() {
  const { user, userData } = useAuth();
  const { id: chatId, name } = useLocalSearchParams();
  const [loading, setLoading] = useState(true);
  const [messages, setMessages] = useState([]);
  const [newMessage, setNewMessage] = useState('');
  const [otherUser, setOtherUser] = useState(null);
  const [isTyping, setIsTyping] = useState(false);
  const [otherUserTyping, setOtherUserTyping] = useState(false);
  const [inputHeight, setInputHeight] = useState(50);
  const typingTimeoutRef = useRef(null);
  
  // Animation values
  const fadeAnim = useRef(new Animated.Value(0)).current;
  const contentOffsetY = useRef(new Animated.Value(0)).current;
  
  // Reference to FlatList for scrolling
  const flatListRef = useRef(null);

  // Load chat messages
  useEffect(() => {
    if (!user?.uid || !chatId) return;

    let unsubscribe = null;
    
    try {
      console.log(`Loading chat ${chatId}...`);
      
      // Get the chat room data
      const chatRoomRef = doc(db, 'chatRooms', chatId.toString());
      
      // Get a reference to the messages collection for this chat room
      const messagesRef = collection(db, 'chatRooms', chatId.toString(), 'messages');
      
      // Order messages by timestamp
      const messagesQuery = query(
        messagesRef,
        orderBy('createdAt', 'desc')
      );
      
      // Set up a listener for messages
      unsubscribe = onSnapshot(messagesQuery, (snapshot) => {
        const messageList = snapshot.docs.map(doc => ({
          id: doc.id,
          ...doc.data(),
          createdAt: doc.data().createdAt?.toDate() || new Date()
        }));
        
        // Mark messages as delivered when seen by recipient
        snapshot.docs.forEach(async (doc) => {
          const messageData = doc.data();
          
          // Check if this message is from the other user and needs delivery status update
          if (messageData.userId !== user.uid && 
              messageData.status && 
              !messageData.status.delivered) {
            
            await updateDoc(doc.ref, {
              'status.delivered': true
            });
          }
          
          // Check if this message is from the other user and needs read status update
          if (messageData.userId !== user.uid && 
              messageData.status && 
              !messageData.status.read) {
            
            await updateDoc(doc.ref, {
              'status.read': true,
              'status.readAt': serverTimestamp()
            });
          }
        });
        
        setMessages(messageList);
        setLoading(false);
        
        // Fade in animation
        Animated.timing(fadeAnim, {
          toValue: 1,
          duration: 300,
          useNativeDriver: true,
        }).start();
      }, error => {
        console.error('Error fetching messages:', error);
        setLoading(false);
      });
      
      // Also get the chat room to find the other user
      getDoc(chatRoomRef).then(async (chatRoomDoc) => {
        if (!chatRoomDoc.exists()) {
          console.log(`Chat room ${chatId} does not exist`);
          return;
        }
        
        const chatRoomData = chatRoomDoc.data();
        
        // Find the other user ID (not current user)
        const otherUserId = chatRoomData.participants.find(id => id !== user.uid);
        
        if (!otherUserId) {
          console.log('Could not find other user in chat room');
          return;
        }
        
        // Get other user's data
        const otherUserDoc = await getDoc(doc(db, 'users', otherUserId));
        
        if (otherUserDoc.exists()) {
          setOtherUser({
            id: otherUserId,
            ...otherUserDoc.data()
          });
        }
      }).catch(error => {
        console.error('Error getting chat room data:', error);
      });
      
    } catch (error) {
      console.error('Error setting up chat listener:', error);
      setLoading(false);
    }
    
    // Return cleanup function
    return () => {
      if (unsubscribe) {
        console.log(`Cleaning up chat listener for ${chatId}`);
        unsubscribe();
      }
    };
  }, [user?.uid, chatId]);

  // Handle sending a new message
  const handleSendMessage = async () => {
    if (!user?.uid || !chatId || !newMessage.trim()) return;
    
    try {
      // Get a reference to the messages collection for this chat room
      const messagesRef = collection(db, 'chatRooms', chatId.toString(), 'messages');
      
      // Add the new message with delivery status
      const messageDoc = await addDoc(messagesRef, {
        text: newMessage.trim(),
        createdAt: serverTimestamp(),
        userId: user.uid,
        userName: userData?.name || 'You',
        system: false,
        status: {
          delivered: false,
          read: false,
          readAt: null
        }
      });
      
      // Update the chat room with the last message
      const chatRoomRef = doc(db, 'chatRooms', chatId.toString());
      await updateDoc(chatRoomRef, {
        lastMessage: {
          text: newMessage.trim(),
          userId: user.uid,
          userName: userData?.name || 'You',
          createdAt: serverTimestamp()
        },
        lastMessageText: newMessage.trim(),
        lastMessageTimestamp: serverTimestamp()
      });
      
      // Clear the input
      setNewMessage('');
      setInputHeight(50); // Reset input height
      
      // Scroll to bottom if needed
      if (flatListRef.current) {
        flatListRef.current.scrollToOffset({ animated: true, offset: 0 });
      }
    } catch (error) {
      console.error('Error sending message:', error);
      alert('Error sending message. Please try again.');
    }
  };

  // Determine if we should show avatar and timestamp for this message
  const shouldShowAvatarAndTime = (currentMessage, previousMessage, nextMessage) => {
    // Always show for the first message in a group
    if (!nextMessage) return true;
    
    // If next message is from a different user, show avatar/time
    if (nextMessage.userId !== currentMessage.userId) return true;
    
    // If the time difference between messages is greater than 5 minutes, show
    const timeDiff = Math.abs(
      nextMessage.createdAt.getTime() - currentMessage.createdAt.getTime()
    );
    if (timeDiff > 5 * 60 * 1000) return true;
    
    return false;
  };

  const renderMessage = ({ item, index }) => {
    const isUser = item.userId === user?.uid;
    const isSystem = item.system;
    const previousMessage = messages[index + 1];
    const nextMessage = messages[index - 1];
    
    const showAvatarAndTime = !isUser && 
                              !isSystem && 
                              shouldShowAvatarAndTime(item, previousMessage, nextMessage);
    
    // Determine if this is the first message in a group (for styling)
    const isFirstInGroup = !previousMessage || previousMessage.userId !== item.userId;
    
    // Determine if this is the last message in a group (for styling)
    const isLastInGroup = !nextMessage || nextMessage.userId !== item.userId;
    
    // Format the timestamp
    const timestamp = item.createdAt ? 
      item.createdAt.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) : '';
    
    // System message (like "User joined the conversation")
    if (isSystem) {
      return (
        <View style={styles.systemMessageContainer}>
          <Text style={styles.systemMessageText}>{item.text}</Text>
        </View>
      );
    }
    
    return (
      <View style={[
        styles.messageRow,
        isUser ? styles.userMessageRow : styles.otherMessageRow
      ]}>
        {/* Avatar (only show for other user's messages when needed) */}
        {!isUser && showAvatarAndTime ? (
          <View style={styles.avatarContainer}>
            {otherUser?.photoURL ? (
              <Image source={{ uri: otherUser.photoURL }} style={styles.avatar} />
            ) : (
              <View style={styles.defaultAvatar}>
                <Text style={styles.defaultAvatarText}>
                  {(otherUser?.name || 'U').charAt(0).toUpperCase()}
                </Text>
              </View>
            )}
          </View>
        ) : (
          // Empty space to align messages properly
          <View style={!isUser ? styles.avatarSpacer : null} />
        )}
        
        {/* Message bubble */}
        <View style={[
          styles.messageContainer,
          isUser ? styles.userMessage : styles.otherMessage,
          isFirstInGroup && (isUser ? styles.userFirstInGroup : styles.otherFirstInGroup),
          isLastInGroup && (isUser ? styles.userLastInGroup : styles.otherLastInGroup),
          !isFirstInGroup && !isLastInGroup && styles.messageInMiddle,
          !isUser && !showAvatarAndTime && styles.consecutiveMessage
        ]}>
          {/* Message content */}
          <Text style={[
            styles.messageText,
            isUser && styles.userMessageText
          ]}>
            {item.text}
          </Text>
          
          {/* Time and delivery indicators (only show for last message in group) */}
          {isLastInGroup && (
            <View style={[
              styles.messageFooter,
              isUser ? styles.userMessageFooter : styles.otherMessageFooter
            ]}>
              <Text style={[
                styles.timestampText,
                isUser && styles.userTimestampText
              ]}>
                {timestamp}
              </Text>
              
              {/* Delivery status (only for user's messages) */}
              {isUser && item.status && (
                <View style={styles.statusContainer}>
                  {item.status.read ? (
                    <MaterialIcons name="done-all" size={14} color="#fff" />
                  ) : item.status.delivered ? (
                    <MaterialIcons name="done" size={14} color="rgba(255,255,255,0.8)" />
                  ) : (
                    <MaterialIcons name="access-time" size={12} color="rgba(255,255,255,0.5)" />
                  )}
                </View>
              )}
            </View>
          )}
        </View>
      </View>
    );
  };

  // Handle typing indicator
  const handleTyping = (text) => {
    setNewMessage(text);
    
    // If the user is typing and we haven't set the typing indicator yet
    if (text.length > 0 && !isTyping && user?.uid && chatId) {
      setIsTyping(true);
      
      // Update typing status in Firebase
      const typingRef = doc(db, 'chatRooms', chatId.toString(), 'typing', user.uid);
      setDoc(typingRef, {
        isTyping: true,
        timestamp: serverTimestamp(),
        userId: user.uid,
        userName: userData?.name || 'You'
      });
    }
    
    // Clear previous timeout
    if (typingTimeoutRef.current) {
      clearTimeout(typingTimeoutRef.current);
    }
    
    // Set timeout to stop typing after 2 seconds of inactivity
    typingTimeoutRef.current = setTimeout(() => {
      if (isTyping && user?.uid && chatId) {
        setIsTyping(false);
        
        // Update typing status in Firebase
        const typingRef = doc(db, 'chatRooms', chatId.toString(), 'typing', user.uid);
        setDoc(typingRef, {
          isTyping: false,
          timestamp: serverTimestamp(),
          userId: user.uid,
          userName: userData?.name || 'You'
        });
      }
    }, 2000);
  };
  
  // Listen for other user typing status
  useEffect(() => {
    if (!user?.uid || !chatId || !otherUser) return;
    
    const typingRef = doc(db, 'chatRooms', chatId.toString(), 'typing', otherUser.id);
    
    const unsubscribe = onSnapshot(typingRef, (snapshot) => {
      if (snapshot.exists()) {
        const typingData = snapshot.data();
        setOtherUserTyping(typingData.isTyping);
      }
    });
    
    return () => unsubscribe();
  }, [user?.uid, chatId, otherUser]);

  // Handle going back to the chat list
  const handleGoBack = useCallback(() => {
    // Fade out animation
    Animated.timing(fadeAnim, {
      toValue: 0,
      duration: 200,
      useNativeDriver: true,
    }).start(() => {
      if (Platform.OS === 'ios') {
        // For iOS, use standard back
        router.back();
      } else {
        // For Android, explicitly navigate to ensure proper cleanup
        router.push('/(tabs)/chat');
      }
    });
  }, []);
  
  // Calculate content container padding bottom based on input height
  const contentPaddingBottom = inputHeight + 16;

  // Header component for FlatList (actually appears at the bottom since list is inverted)
  const ListHeaderComponent = useCallback(() => (
    <View style={{ paddingVertical: 20 }}>
      {otherUserTyping && (
        <View style={styles.typingIndicatorContainer}>
          <View style={styles.typingBubble}>
            <View style={styles.typingDot} />
            <View style={[styles.typingDot, styles.typingDotMiddle]} />
            <View style={styles.typingDot} />
          </View>
          <Text style={styles.typingText}>
            {otherUser?.name || 'User'} is typing...
          </Text>
        </View>
      )}
    </View>
  ), [otherUserTyping, otherUser]);

  return (
    <SafeAreaView style={styles.safeArea}>
      <StatusBar style="dark" />
      <Animated.View 
        style={[styles.container, { opacity: fadeAnim }]}
      >
        <Stack.Screen
          options={{
            headerShown: true,
            headerStyle: {
              backgroundColor: '#fff',
            },
            headerShadowVisible: false,
            headerTitle: () => (
              <View style={styles.headerTitleContainer}>
                {otherUser?.photoURL ? (
                  <Image 
                    source={{ uri: otherUser.photoURL }} 
                    style={styles.headerAvatar} 
                  />
                ) : (
                  <View style={styles.headerDefaultAvatar}>
                    <Text style={styles.headerDefaultAvatarText}>
                      {(name || '?').charAt(0).toUpperCase()}
                    </Text>
                  </View>
                )}
                <Text style={styles.headerTitle} numberOfLines={1}>
                  {name || 'Chat'}
                </Text>
              </View>
            ),
            headerLeft: () => (
              <TouchableOpacity onPress={handleGoBack} style={styles.headerButton}>
                <Ionicons name="arrow-back" size={24} color="#6C5CE7" />
              </TouchableOpacity>
            ),
            headerRight: () => (
              <TouchableOpacity style={styles.headerButton}>
                <Ionicons name="ellipsis-vertical" size={24} color="#6C5CE7" />
              </TouchableOpacity>
            ),
          }}
        />
        
        <KeyboardAvoidingView
          style={styles.keyboardAvoidingView}
          behavior={Platform.OS === 'ios' ? 'padding' : undefined}
          keyboardVerticalOffset={Platform.OS === 'ios' ? 90 : 0}
        >
          {loading ? (
            <View style={styles.loadingContainer}>
              <ActivityIndicator size="large" color="#6C5CE7" />
              <Text style={styles.loadingText}>Loading messages...</Text>
            </View>
          ) : (
            <View style={styles.chatContainer}>
              {/* Messages List */}
              <Animated.FlatList
                ref={flatListRef}
                data={messages}
                renderItem={renderMessage}
                keyExtractor={(item) => item.id}
                inverted={true} // Display most recent messages at the bottom
                contentContainerStyle={[
                  styles.messagesList,
                  { paddingBottom: contentPaddingBottom }
                ]}
                showsVerticalScrollIndicator={false}
                ListHeaderComponent={ListHeaderComponent}
                onScroll={Animated.event(
                  [{ nativeEvent: { contentOffset: { y: contentOffsetY } } }],
                  { useNativeDriver: true }
                )}
              />
              
              {/* Input Container */}
              <View style={styles.inputContainer}>
                <View style={styles.inputWrapper}>
                  <TouchableOpacity style={styles.attachButton}>
                    <Ionicons name="add-circle-outline" size={24} color="#6C5CE7" />
                  </TouchableOpacity>
                  
                  <TextInput
                    style={[styles.input, { height: Math.max(40, inputHeight) }]}
                    value={newMessage}
                    onChangeText={handleTyping}
                    placeholder="Type a message..."
                    placeholderTextColor="#999"
                    multiline={true}
                    maxHeight={120}
                    onContentSizeChange={(e) => {
                      const height = e.nativeEvent.contentSize.height;
                      setInputHeight(Math.min(Math.max(40, height), 120));
                    }}
                  />
                  
                  <TouchableOpacity style={styles.emojiButton}>
                    <Ionicons name="happy-outline" size={24} color="#6C5CE7" />
                  </TouchableOpacity>
                </View>
                
                <TouchableOpacity
                  style={[
                    styles.sendButton,
                    !newMessage.trim() && styles.sendButtonDisabled
                  ]}
                  onPress={handleSendMessage}
                  disabled={!newMessage.trim()}
                  activeOpacity={0.7}
                >
                  <LinearGradient
                    colors={!newMessage.trim() ? ['#ccc', '#ccc'] : ['#6C5CE7', '#a29bfe']}
                    style={styles.sendButtonGradient}
                    start={{ x: 0, y: 0 }}
                    end={{ x: 1, y: 1 }}
                  >
                    <MaterialIcons name="send" size={20} color="#fff" />
                  </LinearGradient>
                </TouchableOpacity>
              </View>
            </View>
          )}
        </KeyboardAvoidingView>
      </Animated.View>
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  safeArea: {
    flex: 1,
    backgroundColor: '#fff',
  },
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
  },
  keyboardAvoidingView: {
    flex: 1,
  },
  headerButton: {
    padding: 8,
  },
  headerTitleContainer: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  headerAvatar: {
    width: 32,
    height: 32,
    borderRadius: 16,
    marginRight: 8,
  },
  headerDefaultAvatar: {
    width: 32,
    height: 32,
    borderRadius: 16,
    backgroundColor: '#a29bfe',
    justifyContent: 'center',
    alignItems: 'center',
    marginRight: 8,
  },
  headerDefaultAvatarText: {
    fontSize: 16,
    fontWeight: 'bold',
    color: '#fff',
  },
  headerTitle: {
    fontSize: 17,
    fontWeight: '600',
    color: '#333',
    maxWidth: SCREEN_WIDTH - 150, // Adjust based on header button widths
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  loadingText: {
    marginTop: 16,
    fontSize: 16,
    color: '#666',
  },
  chatContainer: {
    flex: 1,
    position: 'relative',
  },
  messagesList: {
    paddingHorizontal: 16,
    paddingTop: 10,
  },
  messageRow: {
    flexDirection: 'row',
    marginVertical: 2,
    alignItems: 'flex-end',
  },
  userMessageRow: {
    justifyContent: 'flex-end',
  },
  otherMessageRow: {
    justifyContent: 'flex-start',
  },
  avatarContainer: {
    width: 30,
    height: 30,
    borderRadius: 15,
    marginRight: 8,
    overflow: 'hidden',
  },
  avatarSpacer: {
    width: 38, // Avatar width + margin
  },
  avatar: {
    width: 30,
    height: 30,
    borderRadius: 15,
  },
  defaultAvatar: {
    width: 30,
    height: 30,
    borderRadius: 15,
    backgroundColor: '#a29bfe',
    justifyContent: 'center',
    alignItems: 'center',
  },
  defaultAvatarText: {
    fontSize: 14,
    fontWeight: 'bold',
    color: '#fff',
  },
  messageContainer: {
    maxWidth: BUBBLE_MAX_WIDTH,
    padding: 12,
    borderRadius: 18,
    position: 'relative',
  },
  userMessage: {
    backgroundColor: '#6C5CE7',
  },
  otherMessage: {
    backgroundColor: '#f0f0f0',
  },
  userFirstInGroup: {
    borderTopRightRadius: 18,
  },
  userLastInGroup: {
    borderBottomRightRadius: 18,
  },
  otherFirstInGroup: {
    borderTopLeftRadius: 18,
  },
  otherLastInGroup: {
    borderBottomLeftRadius: 18,
  },
  messageInMiddle: {
    borderRadius: 18,
  },
  consecutiveMessage: {
    marginLeft: 38, // To align with the avatar
  },
  messageText: {
    fontSize: 16,
    color: '#333',
  },
  userMessageText: {
    color: '#fff',
  },
  messageFooter: {
    flexDirection: 'row',
    alignItems: 'center',
    marginTop: 4,
  },
  userMessageFooter: {
    justifyContent: 'flex-end',
  },
  otherMessageFooter: {
    justifyContent: 'flex-start',
  },
  timestampText: {
    fontSize: 11,
    color: 'rgba(0, 0, 0, 0.5)',
  },
  userTimestampText: {
    color: 'rgba(255, 255, 255, 0.7)',
  },
  statusContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    marginLeft: 4,
  },
  systemMessageContainer: {
    alignItems: 'center',
    marginVertical: 16,
  },
  systemMessageText: {
    fontSize: 13,
    color: '#888',
    backgroundColor: 'rgba(0, 0, 0, 0.05)',
    borderRadius: 12,
    paddingHorizontal: 12,
    paddingVertical: 6,
  },
  typingIndicatorContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    marginLeft: 46, // Align with messages
    marginBottom: 8,
  },
  typingBubble: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#f0f0f0',
    borderRadius: 12,
    padding: 8,
    width: 48,
    justifyContent: 'center',
  },
  typingDot: {
    width: 6,
    height: 6,
    borderRadius: 3,
    backgroundColor: '#a29bfe',
    marginHorizontal: 2,
    opacity: 0.6,
  },
  typingDotMiddle: {
    opacity: 0.8,
    transform: [{ translateY: -2 }],
  },
  typingText: {
    fontSize: 12,
    color: '#666',
    marginLeft: 8,
    fontStyle: 'italic',
  },
  inputContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: 8,
    paddingHorizontal: 16,
    backgroundColor: '#fff',
    borderTopWidth: 1,
    borderTopColor: '#f0f0f0',
  },
  inputWrapper: {
    flex: 1,
    flexDirection: 'row',
    backgroundColor: '#f5f5f5',
    borderRadius: 24,
    paddingHorizontal: 8,
    marginRight: 8,
    alignItems: 'center',
  },
  attachButton: {
    padding: 8,
  },
  emojiButton: {
    padding: 8,
  },
  input: {
    flex: 1,
    fontSize: 16,
    paddingVertical: 8,
    color: '#333',
    maxHeight: 120,
  },
  sendButton: {
    width: 44,
    height: 44,
    borderRadius: 22,
    justifyContent: 'center',
    alignItems: 'center',
    overflow: 'hidden',
  },
  sendButtonGradient: {
    width: '100%',
    height: '100%',
    justifyContent: 'center',
    alignItems: 'center',
  },
  sendButtonDisabled: {
    opacity: 0.7,
  },
});
</file>

<file path="app/_layout.tsx">
import FontAwesome from '@expo/vector-icons/FontAwesome';
import { DarkTheme, DefaultTheme, ThemeProvider } from '@react-navigation/native';
import { useFonts } from 'expo-font';
import { Stack } from 'expo-router';
import * as SplashScreen from 'expo-splash-screen';
import { useEffect } from 'react';
import { ActivityIndicator, View, Platform } from 'react-native';
import 'react-native-reanimated';
import { auth } from '@/config/firebase';

import { useColorScheme } from '@/components/useColorScheme';
import { AuthProvider, useAuth } from '@/contexts/AuthContext';

export {
  // Catch any errors thrown by the Layout component.
  ErrorBoundary,
} from 'expo-router';

export const unstable_settings = {
  // Ensure that reloading on `/modal` keeps a back button present.
  initialRouteName: '(tabs)',
};

// Prevent the splash screen from auto-hiding before asset loading is complete.
SplashScreen.preventAutoHideAsync();

export default function RootLayout() {
  const [loaded, error] = useFonts({
    SpaceMono: require('../assets/fonts/SpaceMono-Regular.ttf'),
    ...FontAwesome.font,
  });

  // Expo Router uses Error Boundaries to catch errors in the navigation tree.
  useEffect(() => {
    if (error) throw error;
  }, [error]);

  useEffect(() => {
    if (loaded) {
      SplashScreen.hideAsync();
    }
  }, [loaded]);

  // Check if user is logged in at app startup
  useEffect(() => {
    const checkCurrentUser = async () => {
      const currentUser = auth.currentUser;
      console.log('App startup - Firebase currentUser:', currentUser ? 
        `User logged in: ${currentUser.uid}` : 
        'No user logged in');
    };
    
    checkCurrentUser();
  }, []);

  if (!loaded) {
    console.log('Fonts not loaded yet, returning null');
    return null;
  }

  console.log('Platform:', Platform.OS);
  console.log('RootLayout rendered with fonts loaded');

  return (
    <AuthProvider>
      <RootLayoutNav />
    </AuthProvider>
  );
}

function RootLayoutNav() {
  const colorScheme = useColorScheme();
  const { user, userData, loading } = useAuth();
  
  // Debug logging
  useEffect(() => {
    console.log('Root layout rendered, auth state:', { 
      loading, 
      user: user ? 'Authenticated' : 'Not authenticated',
      platform: Platform.OS
    });
  }, [user, loading]);
  
  console.log('RootLayoutNav rendering with Stack navigator');
  
  return (
    <ThemeProvider value={colorScheme === 'dark' ? DarkTheme : DefaultTheme}>
      {/* Use Stack for all routes for proper navigation */}
      <Stack screenOptions={{ headerShown: false }}>
        <Stack.Screen 
          name="index" 
          options={{ headerShown: false }}
        />
        <Stack.Screen 
          name="(tabs)" 
          options={{ headerShown: false }}
          listeners={{
            focus: () => {
              console.log('(tabs) route focused');
            },
          }}
        />
        <Stack.Screen 
          name="chat/[id]" 
          options={{ 
            headerShown: true,
            // Ensure proper cleanup between screens
            animation: 'slide_from_right',
            fullScreenGestureEnabled: true
          }} 
        />
        <Stack.Screen name="modal" options={{ presentation: 'modal', headerShown: true, title: 'Modal' }} />
        <Stack.Screen name="settings" options={{ presentation: 'modal', headerShown: true, title: 'Settings' }} />
        <Stack.Screen 
          name="auth" 
          options={{ headerShown: false }}
          listeners={{
            focus: () => {
              console.log('auth route focused');
            },
          }}
        />
        <Stack.Screen name="complete-profile" options={{ headerShown: true }} />
        <Stack.Screen name="edit-profile" options={{ headerShown: true, title: 'Edit Profile' }} />
        <Stack.Screen name="+not-found" options={{ headerShown: false, title: 'Not Found' }} />
      </Stack>
    </ThemeProvider>
  );
}
</file>

<file path="app/+not-found.tsx">
import { Stack, useRouter } from 'expo-router';
import { StyleSheet, TouchableOpacity, Platform } from 'react-native';
import { Text, View } from '@/components/Themed';
import * as Linking from 'expo-linking';

// Simple not found screen with platform-specific navigation
export default function NotFoundScreen() {
  const router = useRouter();
  
  console.log('Not found screen rendered, Platform:', Platform.OS);
  
  const handleNavigation = () => {
    console.log('Navigation button pressed on not-found screen');
    
    // Use router instead of window.location
    setTimeout(() => {
      try {
        console.log('Attempting to navigate to home...');
        router.replace('/');
      } catch (error) {
        console.error('Navigation error:', error);
        
        // Fallback navigation using deep linking
        try {
          console.log('Attempting fallback with deep linking...');
          const url = Linking.createURL('/');
          Linking.openURL(url);
        } catch (e) {
          console.error('Deep linking error:', e);
        }
      }
    }, 100);
  };

  return (
    <>
      <Stack.Screen options={{ title: 'Oops!' }} />
      <View style={styles.container}>
        <Text style={styles.title}>This screen doesn't exist.</Text>
        <Text style={styles.subtitle}>Please tap the button below to return to the app.</Text>

        <TouchableOpacity 
          style={styles.button}
          onPress={handleNavigation}
        >
          <Text style={styles.buttonText}>
            Go to Home Screen
          </Text>
        </TouchableOpacity>
      </View>
    </>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center',
    padding: 20,
  },
  title: {
    fontSize: 20,
    fontWeight: 'bold',
    marginBottom: 10,
  },
  subtitle: {
    fontSize: 16,
    color: '#666',
    marginBottom: 30,
    textAlign: 'center',
  },
  button: {
    marginTop: 15,
    paddingVertical: 12,
    paddingHorizontal: 20,
    backgroundColor: '#007bff',
    borderRadius: 8,
  },
  buttonText: {
    fontSize: 16,
    color: '#ffffff',
    fontWeight: 'bold',
  },
});
</file>

<file path="app/edit-profile.tsx">
import React, { useState, useEffect } from 'react';
import { 
  StyleSheet, 
  View, 
  Text, 
  TextInput, 
  TouchableOpacity, 
  ScrollView, 
  Alert, 
  ActivityIndicator, 
  FlatList, 
  Image, 
  Platform, 
  Dimensions,
  Animated,
} from 'react-native';
import { Stack, router } from 'expo-router';
import { LinearGradient } from 'expo-linear-gradient';
import FontAwesome from '@expo/vector-icons/FontAwesome';
import MaterialIcons from '@expo/vector-icons/MaterialIcons';
import * as ImagePicker from 'expo-image-picker';
import { doc, updateDoc } from '@firebase/firestore';
import { ref, uploadBytes, getDownloadURL, deleteObject } from '@firebase/storage';
import { db, storage } from '@/config/firebase';
import { useAuth } from '@/contexts/AuthContext';
import { StatusBar } from 'expo-status-bar';

// Sample interests list - in a real app, this could be fetched from Firestore
const INTERESTS = [
  'Hiking', 'Reading', 'Gaming', 'Cooking', 'Photography', 
  'Art', 'Music', 'Movies', 'Sports', 'Travel', 
  'Technology', 'Fashion', 'Fitness', 'Dancing', 'Writing',
  'Gardening', 'Pets', 'Yoga', 'Meditation', 'Programming',
  'Coffee', 'Wine', 'Food', 'Cycling', 'Running'
];

const { width: SCREEN_WIDTH } = Dimensions.get('window');
const CARD_PADDING = 20;

export default function EditProfileScreen() {
  const { user, userData, refreshUserData } = useAuth();
  const [name, setName] = useState('');
  const [bio, setBio] = useState('');
  const [selectedInterests, setSelectedInterests] = useState<string[]>([]);
  const [customInterests, setCustomInterests] = useState<string[]>([]);
  const [customInterest, setCustomInterest] = useState('');
  const [profileImage, setProfileImage] = useState<string | null>(null);
  const [profileImages, setProfileImages] = useState<string[]>([]);
  const [locationVisible, setLocationVisible] = useState(false);
  const [loading, setLoading] = useState(false);
  const [uploadingImage, setUploadingImage] = useState(false);
  
  // For subtle animations
  const fadeAnim = useState(new Animated.Value(0))[0];
  
  // Load user data when the component mounts
  useEffect(() => {
    if (userData) {
      setName(userData.name || '');
      setBio(userData.bio || '');
      
      // Set existing interests
      if (userData.interests && Array.isArray(userData.interests)) {
        // Split interests into predefined and custom
        const predefined = userData.interests.filter(interest => INTERESTS.includes(interest));
        const custom = userData.interests.filter(interest => !INTERESTS.includes(interest));
        
        setSelectedInterests(predefined);
        setCustomInterests(custom);
      }
      
      // Set main profile image
      if (userData.photoURL) {
        setProfileImage(userData.photoURL);
      }
      
      // Set additional profile images
      if (userData.profileImages && Array.isArray(userData.profileImages)) {
        setProfileImages(userData.profileImages);
      }
      
      // Set location visibility
      if (userData.location && typeof userData.location.visible === 'boolean') {
        setLocationVisible(userData.location.visible);
      }
      
      // Run the fade-in animation
      Animated.timing(fadeAnim, {
        toValue: 1,
        duration: 600,
        useNativeDriver: true,
      }).start();
    }
  }, [userData]);

  // Request permission for media library access
  useEffect(() => {
    (async () => {
      if (Platform.OS !== 'web') {
        const { status } = await ImagePicker.requestMediaLibraryPermissionsAsync();
        if (status !== 'granted') {
          Alert.alert('Permission Needed', 'Sorry, we need camera roll permissions to upload a profile photo.');
        }
      }
    })();
  }, []);

  const toggleInterest = (interest: string) => {
    if (selectedInterests.includes(interest)) {
      setSelectedInterests(selectedInterests.filter(item => item !== interest));
    } else {
      setSelectedInterests([...selectedInterests, interest]);
    }
  };

  const addCustomInterest = () => {
    if (!customInterest.trim()) {
      return;
    }
    
    // Check if interest already exists
    if ([...selectedInterests, ...customInterests].includes(customInterest.trim())) {
      Alert.alert('Interest Exists', 'You have already added this interest.');
      return;
    }
    
    setCustomInterests([...customInterests, customInterest.trim()]);
    setCustomInterest('');
  };

  const removeCustomInterest = (interest: string) => {
    setCustomInterests(customInterests.filter(item => item !== interest));
  };

  const pickImage = async () => {
    try {
      const result = await ImagePicker.launchImageLibraryAsync({
        mediaTypes: ImagePicker.MediaTypeOptions.Images,
        allowsEditing: true,
        aspect: [1, 1],
        quality: 0.7,
      });
      
      if (!result.canceled && result.assets && result.assets.length > 0) {
        await uploadImage(result.assets[0].uri);
      }
    } catch (error) {
      console.error('Error picking image:', error);
      Alert.alert('Error', 'Failed to pick image. Please try again.');
    }
  };

  const pickProfileImages = async () => {
    try {
      // Check how many more images can be added (limit of 6 total)
      const remainingSlots = 6 - profileImages.length;
      
      if (remainingSlots <= 0) {
        Alert.alert(
          'Maximum Images Reached', 
          'You can only have up to 6 profile images. Remove some existing images to add more.',
          [{ text: 'OK' }]
        );
        return;
      }
      
      // For Android, we need to explicitly set selectionLimit to avoid the bug
      // where multiple images are selected when only one was picked
      const result = await ImagePicker.launchImageLibraryAsync({
        mediaTypes: ImagePicker.MediaTypeOptions.Images,
        allowsMultipleSelection: true,
        selectionLimit: remainingSlots,
        quality: 0.7,
        exif: false, // Don't need EXIF data to reduce memory usage
      });
      
      if (!result.canceled && result.assets && result.assets.length > 0) {
        setUploadingImage(true);
        
        try {
          // Upload each image and get their URLs
          const uploadPromises = result.assets.map(asset => uploadProfileImage(asset.uri));
          const uploadedImageUrls = await Promise.all(uploadPromises);
          
          // Filter out any null values (failed uploads)
          const validUrls = uploadedImageUrls.filter(url => url !== null);
          
          if (validUrls.length > 0) {
            // Add the new image URLs to the existing array
            setProfileImages([...profileImages, ...validUrls]);
          }
        } catch (error) {
          console.error('Error uploading profile images:', error);
          Alert.alert('Upload Failed', 'Failed to upload one or more images. Please try again.');
        } finally {
          setUploadingImage(false);
        }
      }
    } catch (error) {
      console.error('Error picking multiple images:', error);
      Alert.alert('Error', 'Failed to pick images. Please try again.');
    }
  };

  const uploadImage = async (uri: string) => {
    setUploadingImage(true);
    
    try {
      // Get file name from URI
      const fileName = uri.split('/').pop();
      const fileExtension = fileName?.split('.').pop() || 'jpg';
      
      // Create a unique file name to avoid overwriting
      const storageFileName = `profile_${user?.uid}_${Date.now()}.${fileExtension}`;
      
      // Create a reference to the storage location
      const storageRef = ref(storage, `profile_images/${storageFileName}`);
      
      // Fetch the image and convert it to a blob
      const response = await fetch(uri);
      const blob = await response.blob();
      
      // Upload the blob to Firebase Storage
      const snapshot = await uploadBytes(storageRef, blob);
      
      // Get the download URL
      const downloadURL = await getDownloadURL(snapshot.ref);
      
      // Update the profile image state
      setProfileImage(downloadURL);
      
      console.log('Main profile image uploaded successfully. URL:', downloadURL);
      
      return downloadURL;
    } catch (error) {
      console.error('Error uploading image:', error);
      Alert.alert('Upload Failed', 'Failed to upload image. Please try again.');
      return null;
    } finally {
      setUploadingImage(false);
    }
  };

  const uploadProfileImage = async (uri: string) => {
    try {
      // Get file name from URI
      const fileName = uri.split('/').pop();
      const fileExtension = fileName?.split('.').pop() || 'jpg';
      
      // Create a unique file name to avoid overwriting
      const storageFileName = `profile_grid_${user?.uid}_${Date.now()}_${Math.random().toString(36).substring(2, 8)}.${fileExtension}`;
      
      // Create a reference to the storage location - store in a dedicated subfolder for better organization
      const storageRef = ref(storage, `profile_images/${storageFileName}`);
      
      // Fetch the image and convert it to a blob
      const response = await fetch(uri);
      const blob = await response.blob();
      
      // Upload the blob to Firebase Storage
      const snapshot = await uploadBytes(storageRef, blob);
      
      // Get the download URL
      const downloadURL = await getDownloadURL(snapshot.ref);
      
      console.log('Grid profile image uploaded successfully. URL:', downloadURL);
      
      return downloadURL;
    } catch (error) {
      console.error('Error uploading grid image:', error);
      return null; // Return null on error to help with filtering out failed uploads
    }
  };

  const removeProfileImage = async (imageUrl: string, index: number) => {
    try {
      setLoading(true);
      
      // Parse the URL to get the storage path
      if (imageUrl) {
        try {
          // First, remove from the profile images array (UI update)
          const updatedImages = [...profileImages];
          updatedImages.splice(index, 1);
          setProfileImages(updatedImages);
          
          // Try to extract the reference path from Firebase Storage URL
          // Example URL: https://firebasestorage.googleapis.com/v0/b/bucket-name.appspot.com/o/profile_images%2Fprofile_grid_uid_timestamp.jpg?alt=media&token=...
          if (imageUrl.includes('firebasestorage.googleapis.com')) {
            // Extract the path segment
            const baseUrlPattern = 'https://firebasestorage.googleapis.com/v0/b/[^/]+/o/';
            const pathStart = imageUrl.search(new RegExp(baseUrlPattern)) + imageUrl.match(new RegExp(baseUrlPattern))[0].length;
            const pathEnd = imageUrl.indexOf('?', pathStart);
            
            if (pathStart >= 0 && pathEnd >= 0) {
              // Get the encoded path and decode it
              const encodedPath = imageUrl.substring(pathStart, pathEnd);
              const path = decodeURIComponent(encodedPath);
              
              // Create a reference to the file
              const imageRef = ref(storage, path);
              
              console.log('Attempting to delete file at path:', path);
              
              // Delete the file
              await deleteObject(imageRef)
                .then(() => {
                  console.log('Image deleted successfully from storage');
                })
                .catch((error) => {
                  // Continue with UI update even if storage deletion fails
                  console.error('Error deleting image from storage:', error);
                });
            }
          }
        } catch (storageError) {
          console.error('Error parsing URL or deleting from storage:', storageError);
          // Continue anyway to keep UI consistent
        }
      }
      
      console.log('Image removed from profile grid');
    } catch (error) {
      console.error('Error removing profile image:', error);
      Alert.alert('Error', 'Failed to remove image. Please try again.');
    } finally {
      setLoading(false);
    }
  };

  const toggleLocationVisibility = () => {
    setLocationVisible(!locationVisible);
  };

  const handleSaveProfile = async () => {
    // Validation
    if (!name.trim()) {
      Alert.alert('Missing Information', 'Please enter your name.');
      return;
    }

    if ([...selectedInterests, ...customInterests].length < 1) {
      Alert.alert('Missing Information', 'Please select at least one interest.');
      return;
    }

    setLoading(true);

    try {
      if (user?.uid) {
        const userRef = doc(db, 'users', user.uid);
        
        // Combine selected predefined interests and custom interests
        const combinedInterests = [...selectedInterests, ...customInterests];
        
        const updateData: any = {
          name: name.trim(),
          bio: bio.trim(),
          interests: combinedInterests,
          'location.visible': locationVisible,
          lastUpdated: new Date()
        };
        
        // Only update photoURL if it's changed
        if (profileImage) {
          updateData.photoURL = profileImage;
        }
        
        // Add profile images array if exists
        if (profileImages.length > 0) {
          updateData.profileImages = profileImages;
        }
        
        await updateDoc(userRef, updateData);
        
        await refreshUserData();
        
        Alert.alert('Success', 'Your profile has been updated!', [
          { text: 'OK', onPress: () => router.back() }
        ]);
      }
    } catch (error) {
      console.error('Error updating profile:', error);
      Alert.alert('Error', 'Failed to save profile. Please try again.');
    } finally {
      setLoading(false);
    }
  };

  const renderInterestItem = ({ item }: { item: string }) => (
    <TouchableOpacity
      style={[
        styles.interestTag,
        selectedInterests.includes(item) && styles.interestTagSelected
      ]}
      onPress={() => toggleInterest(item)}
      activeOpacity={0.7}
    >
      <Text 
        style={[
          styles.interestText,
          selectedInterests.includes(item) && styles.interestTextSelected
        ]}
      >
        {item}
      </Text>
    </TouchableOpacity>
  );

  return (
    <Animated.View style={[styles.container, { opacity: fadeAnim }]}>
      <StatusBar style="dark" />
      <Stack.Screen 
        options={{ 
          headerShown: true,
          headerStyle: {
            backgroundColor: '#fff',
          },
          headerTitleStyle: {
            fontWeight: '600',
            color: '#333',
          },
          headerShadowVisible: false,
          headerTitle: 'Edit Profile',
        }} 
      />
      
      <ScrollView 
        contentContainerStyle={styles.scrollContent}
        showsVerticalScrollIndicator={false}
      >
        {/* Profile Image Section */}
        <View style={styles.profileImageSection}>
          <TouchableOpacity 
            style={styles.profileImageContainer}
            onPress={pickImage}
            disabled={uploadingImage || loading}
            activeOpacity={0.9}
          >
            {profileImage ? (
              <Image source={{ uri: profileImage }} style={styles.profileImage} />
            ) : (
              <View style={styles.placeholderImage}>
                <FontAwesome name="user" size={50} color="#fff" />
              </View>
            )}
            
            {uploadingImage && (
              <View style={styles.uploadingOverlay}>
                <ActivityIndicator size="large" color="#fff" />
              </View>
            )}
            
            <View style={styles.editIconContainer}>
              <MaterialIcons name="camera-alt" size={20} color="#fff" />
            </View>
          </TouchableOpacity>
          <Text style={styles.changePhotoText}>Tap to change profile photo</Text>
        </View>
        
        {/* Card for Name and Bio */}
        <View style={styles.card}>
          <View style={styles.inputGroup}>
            <Text style={styles.label}>Name</Text>
            <TextInput
              style={styles.input}
              placeholder="Your name"
              value={name}
              onChangeText={setName}
              maxLength={50}
              editable={!loading}
              placeholderTextColor="#aaa"
            />
          </View>
          
          <View style={styles.inputGroup}>
            <Text style={styles.label}>Bio</Text>
            <TextInput
              style={styles.bioInput}
              placeholder="Tell us about yourself..."
              value={bio}
              onChangeText={setBio}
              multiline
              maxLength={200}
              editable={!loading}
              placeholderTextColor="#aaa"
            />
            <Text style={styles.charCount}>{bio?.length || 0}/200</Text>
          </View>
        </View>
        
        {/* Photo Gallery Card */}
        <View style={styles.card}>
          <View style={styles.cardHeader}>
            <MaterialIcons name="photo-library" size={20} color="#6C5CE7" />
            <Text style={styles.cardTitle}>Photo Gallery</Text>
          </View>
          <Text style={styles.subLabel}>
            Add up to 6 photos to your profile gallery ({profileImages.length}/6)
          </Text>
          
          <View style={styles.profileImagesGrid}>
            {/* Render existing images */}
            {profileImages.map((imageUrl, index) => (
              <View key={index} style={styles.gridImageContainer}>
                <Image source={{ uri: imageUrl }} style={styles.gridImage} />
                <TouchableOpacity 
                  style={styles.removeImageButton}
                  onPress={() => removeProfileImage(imageUrl, index)}
                  disabled={loading}
                >
                  <MaterialIcons name="close" size={16} color="#fff" />
                </TouchableOpacity>
              </View>
            ))}
            
            {/* Add image button (if less than 6 images) */}
            {profileImages.length < 6 && (
              <TouchableOpacity 
                style={styles.addImageButton}
                onPress={pickProfileImages}
                disabled={uploadingImage || loading}
                activeOpacity={0.7}
              >
                {uploadingImage ? (
                  <ActivityIndicator size="small" color="#6C5CE7" />
                ) : (
                  <>
                    <MaterialIcons name="add-photo-alternate" size={28} color="#6C5CE7" />
                    <Text style={styles.addImageText}>Add Photos</Text>
                  </>
                )}
              </TouchableOpacity>
            )}
          </View>
        </View>
        
        {/* Interests Card */}
        <View style={styles.card}>
          <View style={styles.cardHeader}>
            <MaterialIcons name="favorite" size={20} color="#6C5CE7" />
            <Text style={styles.cardTitle}>Your Interests</Text>
          </View>
          <Text style={styles.subLabel}>
            Select interests to connect with like-minded people ({selectedInterests.length + customInterests.length} selected)
          </Text>
          
          <FlatList
            data={INTERESTS}
            renderItem={renderInterestItem}
            keyExtractor={(item) => item}
            numColumns={3}
            scrollEnabled={false}
            contentContainerStyle={styles.interestsContainer}
          />
          
          {/* Custom Interest Input */}
          <View style={styles.customInterestSection}>
            <Text style={styles.subLabel}>Add your own interests</Text>
            <View style={styles.customInterestInputContainer}>
              <TextInput
                style={styles.customInterestInput}
                placeholder="Add a custom interest"
                value={customInterest}
                onChangeText={setCustomInterest}
                maxLength={20}
                editable={!loading}
                placeholderTextColor="#aaa"
              />
              <TouchableOpacity
                style={[styles.addButton, (!customInterest.trim() || loading) && styles.addButtonDisabled]}
                onPress={addCustomInterest}
                disabled={!customInterest.trim() || loading}
              >
                <Text style={styles.addButtonText}>Add</Text>
              </TouchableOpacity>
            </View>
            
            {/* Custom Interests List */}
            {customInterests.length > 0 && (
              <View style={styles.customInterestsList}>
                {customInterests.map((interest, index) => (
                  <View key={index} style={styles.customInterestItem}>
                    <Text style={styles.customInterestText}>{interest}</Text>
                    <TouchableOpacity
                      style={styles.removeButton}
                      onPress={() => removeCustomInterest(interest)}
                      disabled={loading}
                    >
                      <MaterialIcons name="close" size={12} color="#fff" />
                    </TouchableOpacity>
                  </View>
                ))}
              </View>
            )}
          </View>
        </View>
        
        {/* Location Settings Card */}
        <View style={styles.card}>
          <View style={styles.cardHeader}>
            <MaterialIcons name="location-on" size={20} color="#6C5CE7" />
            <Text style={styles.cardTitle}>Location Settings</Text>
          </View>
          
          <TouchableOpacity 
            style={styles.visibilityToggle}
            onPress={toggleLocationVisibility}
            disabled={loading}
            activeOpacity={0.8}
          >
            <View style={styles.toggleTextContainer}>
              <Text style={styles.visibilityText}>
                Show my location to other users
              </Text>
              <Text style={styles.visibilityDescription}>
                {locationVisible 
                  ? 'Your location is visible to other users'
                  : 'Your location is hidden from other users'}
              </Text>
            </View>
            
            <View style={[
              styles.toggleSwitch,
              locationVisible && styles.toggleSwitchActive
            ]}>
              <View style={[
                styles.toggleBall,
                locationVisible && styles.toggleBallActive
              ]} />
            </View>
          </TouchableOpacity>
        </View>
        
        {/* Save Button */}
        <TouchableOpacity
          style={[styles.saveButton, loading && styles.saveButtonDisabled]}
          onPress={handleSaveProfile}
          disabled={loading}
          activeOpacity={0.8}
        >
          <LinearGradient
            colors={loading ? ['#a29bfe', '#a29bfe'] : ['#6C5CE7', '#a29bfe']}
            style={styles.saveButtonGradient}
            start={{ x: 0, y: 0 }}
            end={{ x: 1, y: 0 }}
          >
            {loading ? (
              <ActivityIndicator size="small" color="#fff" />
            ) : (
              <Text style={styles.saveButtonText}>Save Changes</Text>
            )}
          </LinearGradient>
        </TouchableOpacity>
      </ScrollView>
    </Animated.View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
  },
  scrollContent: {
    paddingHorizontal: 16,
    paddingBottom: 40,
  },
  profileImageSection: {
    alignItems: 'center',
    marginTop: 16,
    marginBottom: 20,
  },
  profileImageContainer: {
    position: 'relative',
    width: 120,
    height: 120,
    borderRadius: 60,
    backgroundColor: '#eee',
    justifyContent: 'center',
    alignItems: 'center',
    marginBottom: 8,
    overflow: 'hidden',
    borderWidth: 5,
    borderColor: '#fff',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.2,
    shadowRadius: 5,
    elevation: 3,
  },
  profileImage: {
    width: 120,
    height: 120,
    borderRadius: 60,
  },
  placeholderImage: {
    width: 120,
    height: 120,
    borderRadius: 60,
    backgroundColor: '#a29bfe',
    justifyContent: 'center',
    alignItems: 'center',
  },
  uploadingOverlay: {
    position: 'absolute',
    width: '100%',
    height: '100%',
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  editIconContainer: {
    position: 'absolute',
    bottom: 0,
    right: 0,
    backgroundColor: '#6C5CE7',
    width: 36,
    height: 36,
    borderRadius: 18,
    justifyContent: 'center',
    alignItems: 'center',
    borderWidth: 2,
    borderColor: '#fff',
  },
  changePhotoText: {
    fontSize: 14,
    color: '#6C5CE7',
    fontWeight: '500',
  },
  card: {
    backgroundColor: '#fff',
    borderRadius: 16,
    marginBottom: 16,
    padding: CARD_PADDING,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.05,
    shadowRadius: 3,
    elevation: 3,
  },
  cardHeader: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 12,
  },
  cardTitle: {
    fontSize: 18,
    fontWeight: '600',
    color: '#333',
    marginLeft: 8,
  },
  inputGroup: {
    marginBottom: 16,
  },
  label: {
    fontSize: 16,
    fontWeight: '600',
    color: '#333',
    marginBottom: 8,
  },
  subLabel: {
    fontSize: 14,
    color: '#666',
    marginBottom: 12,
  },
  input: {
    backgroundColor: '#f9f9f9',
    borderWidth: 1,
    borderColor: '#e0e0e0',
    borderRadius: 12,
    padding: 14,
    fontSize: 16,
    color: '#333',
  },
  bioInput: {
    backgroundColor: '#f9f9f9',
    borderWidth: 1,
    borderColor: '#e0e0e0',
    borderRadius: 12,
    padding: 14,
    fontSize: 16,
    height: 120,
    textAlignVertical: 'top',
    color: '#333',
  },
  charCount: {
    fontSize: 12,
    color: '#999',
    textAlign: 'right',
    marginTop: 4,
  },
  profileImagesGrid: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    marginHorizontal: -6,
  },
  gridImageContainer: {
    width: (SCREEN_WIDTH - 32 - CARD_PADDING * 2 - 12) / 3,
    aspectRatio: 1,
    padding: 6,
    position: 'relative',
  },
  gridImage: {
    width: '100%',
    height: '100%',
    borderRadius: 12,
  },
  removeImageButton: {
    position: 'absolute',
    top: 10,
    right: 10,
    backgroundColor: 'rgba(0, 0, 0, 0.6)',
    width: 24,
    height: 24,
    borderRadius: 12,
    justifyContent: 'center',
    alignItems: 'center',
    zIndex: 2,
  },
  addImageButton: {
    width: (SCREEN_WIDTH - 32 - CARD_PADDING * 2 - 12) / 3,
    aspectRatio: 1,
    padding: 6,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#f3f0ff',
    borderRadius: 12,
    marginHorizontal: 6,
  },
  addImageText: {
    fontSize: 14,
    color: '#6C5CE7',
    fontWeight: '500',
    marginTop: 8,
  },
  interestsContainer: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    marginHorizontal: -4,
  },
  interestTag: {
    backgroundColor: '#f9f9f9',
    borderWidth: 1,
    borderColor: '#e0e0e0',
    borderRadius: 20,
    paddingHorizontal: 14,
    paddingVertical: 8,
    margin: 4,
  },
  interestTagSelected: {
    backgroundColor: '#6C5CE7',
    borderColor: '#6C5CE7',
  },
  interestText: {
    fontSize: 14,
    color: '#666',
    fontWeight: '500',
  },
  interestTextSelected: {
    color: '#fff',
  },
  customInterestSection: {
    marginTop: 20,
  },
  customInterestInputContainer: {
    flexDirection: 'row',
    marginBottom: 12,
  },
  customInterestInput: {
    flex: 1,
    backgroundColor: '#f9f9f9',
    borderWidth: 1,
    borderColor: '#e0e0e0',
    borderRadius: 12,
    padding: 14,
    fontSize: 16,
    marginRight: 10,
    color: '#333',
  },
  addButton: {
    backgroundColor: '#6C5CE7',
    borderRadius: 12,
    paddingHorizontal: 16,
    justifyContent: 'center',
    alignItems: 'center',
  },
  addButtonDisabled: {
    backgroundColor: '#a29bfe',
  },
  addButtonText: {
    color: '#fff',
    fontSize: 16,
    fontWeight: 'bold',
  },
  customInterestsList: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    marginTop: 8,
  },
  customInterestItem: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#f3f0ff',
    borderRadius: 20,
    paddingHorizontal: 12,
    paddingVertical: 6,
    marginRight: 8,
    marginBottom: 8,
  },
  customInterestText: {
    fontSize: 14,
    color: '#6C5CE7',
    fontWeight: '500',
    marginRight: 8,
  },
  removeButton: {
    backgroundColor: '#6C5CE7',
    width: 20,
    height: 20,
    borderRadius: 10,
    justifyContent: 'center',
    alignItems: 'center',
  },
  visibilityToggle: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    backgroundColor: '#f9f9f9',
    borderWidth: 1,
    borderColor: '#e0e0e0',
    borderRadius: 12,
    padding: 16,
  },
  toggleTextContainer: {
    flex: 1,
  },
  visibilityText: {
    fontSize: 16,
    color: '#333',
    fontWeight: '500',
  },
  visibilityDescription: {
    fontSize: 14,
    color: '#777',
    marginTop: 4,
  },
  toggleSwitch: {
    width: 50,
    height: 28,
    borderRadius: 14,
    backgroundColor: '#e0e0e0',
    padding: 2,
  },
  toggleSwitchActive: {
    backgroundColor: '#a29bfe',
  },
  toggleBall: {
    width: 24,
    height: 24,
    borderRadius: 12,
    backgroundColor: '#fff',
  },
  toggleBallActive: {
    transform: [{ translateX: 22 }],
  },
  saveButton: {
    marginTop: 8,
    borderRadius: 12,
    overflow: 'hidden',
    marginBottom: 30,
    shadowColor: '#6C5CE7',
    shadowOffset: { width: 0, height: 3 },
    shadowOpacity: 0.2,
    shadowRadius: 4,
    elevation: 5,
  },
  saveButtonDisabled: {
    opacity: 0.8,
  },
  saveButtonGradient: {
    paddingVertical: 16,
    alignItems: 'center',
  },
  saveButtonText: {
    color: '#fff',
    fontSize: 16,
    fontWeight: 'bold',
  },
});
</file>

<file path="components/maps/EnhancedUserMapMarker.tsx">
import React, { useState, useEffect, useRef } from 'react';
import { View, Image, Text, StyleSheet, ViewStyle, ActivityIndicator } from 'react-native';
import FontAwesome from '@expo/vector-icons/FontAwesome';
import { Asset } from 'expo-asset';

// Define tier types for the marker
export type MarkerTier = 'soulmate' | 'bestFriend' | 'friend' | 'buddy' | 'casual';

// Define the props for the enhanced marker component
interface EnhancedUserMapMarkerProps {
  photoURL?: string;
  distance?: number;
  name?: string;
  tier?: MarkerTier;
  sharedInterestsCount?: number;
  online?: boolean;
  style?: ViewStyle;
}

/**
 * Enhanced map marker component for displaying users on the map with tier-based styling
 */
const EnhancedUserMapMarker: React.FC<EnhancedUserMapMarkerProps> = ({ 
  photoURL, 
  distance, 
  name, 
  tier = 'casual',
  sharedInterestsCount = 0,
  online = false,
  style 
}) => {
  const [imageLoaded, setImageLoaded] = useState(false);
  const [imageError, setImageError] = useState(false);
  const [isLoading, setIsLoading] = useState(true);
  const [tracksViewChanges, setTracksViewChanges] = useState(true);
  const [imageKey, setImageKey] = useState(Date.now().toString());
  const retryCount = useRef(0);
  const imageComponent = useRef(null);

  // Load image and handle errors with retry mechanism
  useEffect(() => {
    if (photoURL) {
      // Reset states when photoURL changes
      setIsLoading(true);
      setImageLoaded(false);
      setImageError(false);
      setTracksViewChanges(true);

      // Force refresh of image
      setImageKey(Date.now().toString());
      
      // Set up a timeout to stop tracking view changes after image loads
      const viewChangesTimeout = setTimeout(() => {
        if (tracksViewChanges) {
          console.log('Setting tracksViewChanges to false for:', name);
          setTracksViewChanges(false);
        }
      }, 2000);

      // Prefetch image to pre-cache
      if (photoURL) {
        console.log('Prefetching image for marker:', name);
        Image.prefetch(photoURL).catch(err => {
          console.log('Prefetch error:', err);
        });
      }
      
      return () => {
        clearTimeout(viewChangesTimeout);
      };
    }
  }, [photoURL]);

  // Add an automatic retry mechanism if the image fails to load
  useEffect(() => {
    if (photoURL && imageError && retryCount.current < 3) {
      const retryTimeout = setTimeout(() => {
        console.log(`Retry ${retryCount.current + 1} loading image for:`, name);
        retryCount.current += 1;
        setImageKey(Date.now().toString());
        setImageError(false);
        setIsLoading(true);
      }, 1000);
      
      return () => clearTimeout(retryTimeout);
    }
  }, [imageError, photoURL, name]);

  // Handle image load success
  const handleImageLoad = () => {
    console.log('Image loaded successfully for:', name);
    setImageLoaded(true);
    setImageError(false);
    setIsLoading(false);
    
    // After a short delay, set tracksViewChanges to false for performance
    setTimeout(() => {
      setTracksViewChanges(false);
    }, 100);
  };

  // Handle image load error
  const handleImageError = (error) => {
    console.error('Image load error for user:', name, error?.nativeEvent?.error || 'Unknown error');
    setImageError(true);
    setIsLoading(false);
  };

  // Determine the marker size based on tier
  const getMarkerSize = () => {
    const safeType = tier || 'casual';
    switch(safeType) {
      case 'soulmate': return { container: 60, image: 52 };
      case 'bestFriend': return { container: 52, image: 44 };
      case 'friend': return { container: 48, image: 40 };
      case 'buddy': return { container: 44, image: 36 };
      case 'casual':
      default: return { container: 40, image: 32 };
    }
  };

  // Determine the marker border color based on tier
  const getMarkerColor = () => {
    const safeType = tier || 'casual';
    switch(safeType) {
      case 'soulmate': return '#00B0FF'; // Light blue
      case 'bestFriend': return '#FFD700'; // Gold
      case 'friend': return '#C0C0C0'; // Silver
      case 'buddy': return '#CD7F32'; // Bronze
      case 'casual':
      default: return '#AAAAAA'; // Gray
    }
  };

  const markerSize = getMarkerSize();
  const markerColor = getMarkerColor();
  
  const containerRadius = markerSize.container / 2;
  const imageRadius = markerSize.image / 2;

  return (
    <View style={[styles.container, style]}>
      <View 
        style={[
          styles.imageContainer, 
          { 
            width: markerSize.container, 
            height: markerSize.container, 
            borderRadius: containerRadius,
            borderColor: markerColor,
            backgroundColor: '#fff',
            justifyContent: 'center',
            alignItems: 'center',
            overflow: 'hidden'
          }
        ]}
      >
        {photoURL ? (
          <>
            {/* Default icon shown while image is loading */}
            {(!imageLoaded || imageError) && (
              <View style={[
                styles.defaultImage, 
                { 
                  width: markerSize.image, 
                  height: markerSize.image, 
                  borderRadius: imageRadius,
                  backgroundColor: markerColor
                }
              ]}>
                <FontAwesome 
                  name="user" 
                  size={markerSize.image / 2.5} 
                  color="#fff" 
                />
              </View>
            )}
            
            {/* Main profile image */}
            <Image 
              key={imageKey}
              ref={imageComponent}
              source={{ 
                uri: photoURL,
                cache: 'force-cache'
              }}
              style={[
                styles.image, 
                { 
                  width: markerSize.image, 
                  height: markerSize.image, 
                  borderRadius: imageRadius,
                  opacity: imageLoaded ? 1 : 0  // Only show when loaded
                }
              ]}
              onLoad={handleImageLoad}
              onError={handleImageError}
              resizeMode="cover"
              fadeDuration={0}
            />
            
            {/* Loading indicator */}
            {isLoading && !imageLoaded && !imageError && (
              <ActivityIndicator 
                size="small" 
                color={markerColor} 
                style={styles.loadingIndicator}
              />
            )}
          </>
        ) : (
          <View style={[
            styles.defaultImage, 
            { 
              width: markerSize.image, 
              height: markerSize.image, 
              borderRadius: imageRadius,
              backgroundColor: markerColor
            }
          ]}>
            <FontAwesome 
              name="user" 
              size={markerSize.image / 2.5} 
              color="#fff" 
            />
          </View>
        )}
      </View>
      
      {/* Display the number of shared interests */}
      {sharedInterestsCount > 0 && (
        <View style={[styles.interestBadge, { backgroundColor: markerColor }]}>
          <Text style={styles.interestCount}>{sharedInterestsCount}</Text>
        </View>
      )}
      
      {/* Online status indicator */}
      {online && (
        <View style={styles.onlineIndicator} />
      )}
      
      {/* Display distance if available */}
      {distance && (
        <View style={[styles.distanceContainer, { backgroundColor: `${markerColor}CC` }]}>
          <Text style={styles.distanceText}>{distance}m</Text>
        </View>
      )}
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    alignItems: 'center',
    width: 80,
    height: 70,
  },
  imageContainer: {
    borderWidth: 3,
    position: 'relative',
  },
  image: {
    backgroundColor: '#eee',
  },
  defaultImage: {
    justifyContent: 'center',
    alignItems: 'center',
  },
  distanceContainer: {
    paddingHorizontal: 8,
    paddingVertical: 2,
    borderRadius: 10,
    marginTop: 4,
  },
  distanceText: {
    color: '#fff',
    fontSize: 10,
    fontWeight: 'bold',
  },
  interestBadge: {
    position: 'absolute',
    top: -5,
    right: 5,
    width: 20,
    height: 20,
    borderRadius: 10,
    backgroundColor: '#007bff',
    justifyContent: 'center',
    alignItems: 'center',
    borderWidth: 1,
    borderColor: '#fff',
  },
  interestCount: {
    color: '#fff',
    fontSize: 10,
    fontWeight: 'bold',
  },
  onlineIndicator: {
    position: 'absolute',
    bottom: -5,
    right: 5,
    width: 12,
    height: 12,
    borderRadius: 6,
    backgroundColor: '#4CAF50', // Green for online
    borderWidth: 1,
    borderColor: '#fff',
  },
  loadingIndicator: {
    position: 'absolute',
  }
});

export default EnhancedUserMapMarker;
</file>

<file path="components/maps/ProfileCard.tsx">
import React, { useState, useEffect, useRef } from 'react';
import { 
  View, 
  Text, 
  Image, 
  StyleSheet, 
  TouchableOpacity, 
  ScrollView, 
  ActivityIndicator,
  Animated,
  PanResponder,
  Dimensions,
  Modal,
  Platform
} from 'react-native';
import FontAwesome from '@expo/vector-icons/FontAwesome';
import { MarkerTier } from './EnhancedUserMapMarker';
import { collection, query, where, getDocs } from '@firebase/firestore';
import { db } from '@/config/firebase';
import { useAuth } from '@/contexts/AuthContext';

interface ProfileCardProps {
  uid: string;
  name: string;
  bio?: string;
  photoURL?: string;
  profileImages?: string[];
  interests: string[];
  sharedInterests: string[];
  tier: MarkerTier;
  distance?: number;
  online?: boolean;
  onDismiss: () => void;
  onStartChat?: (uid: string) => void;
  onInvite?: (uid: string) => void;
  onAcceptInvite?: (uid: string) => void;
  onDeclineInvite?: (uid: string) => void;
}

const { height, width } = Dimensions.get('window');
const DISMISS_THRESHOLD = 100; // How far the user needs to drag to dismiss

// Get the safe area insets
const SAFE_AREA_TOP = Platform.OS === 'ios' ? 44 : 0;
// Tab bar height estimation for bottom spacing
const TAB_BAR_HEIGHT = Platform.OS === 'ios' ? 83 : 70; // Height including safe area insets on iOS
// Header height estimation (status bar + app header)
const HEADER_HEIGHT = Platform.OS === 'ios' ? 90 : 60;

// Connection Status Types
type ConnectionStatus = 'none' | 'pending_sent' | 'pending_received' | 'connected';

const ProfileCard: React.FC<ProfileCardProps> = ({
  uid,
  name = 'User',
  bio = '',
  photoURL,
  profileImages = [],
  interests = [],
  sharedInterests = [],
  tier = 'casual',
  distance,
  online = false,
  onDismiss,
  onStartChat,
  onInvite,
  onAcceptInvite,
  onDeclineInvite
}) => {
  const { user } = useAuth();
  
  // Make sure we have arrays even if undefined is passed
  const safeProfileImages = Array.isArray(profileImages) ? profileImages : [];
  const safeInterests = Array.isArray(interests) ? interests : [];
  const safeSharedInterests = Array.isArray(sharedInterests) ? sharedInterests : [];

  // State for image loading and errors
  const [imageLoaded, setImageLoaded] = useState(false);
  const [imageError, setImageError] = useState(false);
  const [isLoading, setIsLoading] = useState(false);
  const [selectedImageIndex, setSelectedImageIndex] = useState<number | null>(null);
  const [showImageModal, setShowImageModal] = useState(false);
  
  // Connection status state
  const [connectionStatus, setConnectionStatus] = useState<ConnectionStatus>('none');
  const [connectionId, setConnectionId] = useState<string | null>(null);
  const [chatRoomId, setChatRoomId] = useState<string | null>(null);
  const [checkingConnection, setCheckingConnection] = useState(true);

  // Calculate available space between header and tab bar
  const getAvailableSpace = () => {
    return height - HEADER_HEIGHT - TAB_BAR_HEIGHT - 30; // 30px buffer
  };

  // Calculate appropriate max height for the card
  const calculateMaxHeight = () => {
    const availableSpace = getAvailableSpace();
    // Use at most 85% of available space
    return availableSpace * 0.85;
  };

  // Ensure the button container is visible above the tab bar
  const ensureButtonVisibility = () => {
    const availableSpace = getAvailableSpace();
    
    return {
      // Ensure the card height is at least tall enough to show buttons plus some content
      minHeight: Math.min(200, availableSpace * 0.3),
      // Ensure maximum height fits between header and tab bar
      maxHeight: availableSpace * 0.85
    };
  };

  // Check connection status on component mount
  useEffect(() => {
    const checkConnectionStatus = async () => {
      if (!user?.uid || !uid) return;
      
      try {
        setCheckingConnection(true);
        
        // Check for connection requests in both directions
        const connectionRequestsRef = collection(db, 'connectionRequests');
        
        // Check for sent request
        const sentQuery = query(
          connectionRequestsRef,
          where('senderId', '==', user.uid),
          where('receiverId', '==', uid)
        );
        
        // Check for received request
        const receivedQuery = query(
          connectionRequestsRef,
          where('senderId', '==', uid),
          where('receiverId', '==', user.uid)
        );
        
        const [sentSnapshot, receivedSnapshot] = await Promise.all([
          getDocs(sentQuery),
          getDocs(receivedQuery)
        ]);
        
        if (!sentSnapshot.empty) {
          // We sent an invitation
          const request = sentSnapshot.docs[0];
          const requestData = request.data();
          
          if (requestData.status === 'accepted') {
            // Connection established
            setConnectionStatus('connected');
            setConnectionId(request.id);
            setChatRoomId(requestData.chatRoomId || null);
          } else {
            // Pending invitation we sent
            setConnectionStatus('pending_sent');
            setConnectionId(request.id);
          }
        } else if (!receivedSnapshot.empty) {
          // We received an invitation
          const request = receivedSnapshot.docs[0];
          const requestData = request.data();
          
          if (requestData.status === 'accepted') {
            // Connection established
            setConnectionStatus('connected');
            setConnectionId(request.id);
            setChatRoomId(requestData.chatRoomId || null);
          } else {
            // Pending invitation we received
            setConnectionStatus('pending_received');
            setConnectionId(request.id);
          }
        } else {
          // No connection or invitation
          setConnectionStatus('none');
        }
      } catch (error) {
        console.error('Error checking connection status:', error);
        setConnectionStatus('none');
      } finally {
        setCheckingConnection(false);
      }
    };
    
    checkConnectionStatus();
  }, [user?.uid, uid]);

  // Animation setup - starting from below and sliding up
  const slideAnim = useRef(new Animated.Value(getAvailableSpace())).current;
  const opacityAnim = useRef(new Animated.Value(0)).current;

  // Pan responder for swipe to dismiss from the drag handle only
  const panResponder = useRef(
    PanResponder.create({
      // Only respond to touch events that start in the drag handle
      onStartShouldSetPanResponder: () => true,
      
      // Only respond to movements if they're primarily downward
      onMoveShouldSetPanResponder: (_, gestureState) => {
        // Detect primarily downward swipe (more vertical than horizontal)
        return gestureState.dy > 5 && Math.abs(gestureState.dy) > Math.abs(gestureState.dx);
      },
      
      // Handle the drag movement
      onPanResponderMove: (_, gestureState) => {
        if (gestureState.dy > 0) {
          // Only allow downward movement (positive dy)
          slideAnim.setValue(gestureState.dy);
        }
      },
      
      // Handle the release of the drag
      onPanResponderRelease: (_, gestureState) => {
        if (gestureState.dy > DISMISS_THRESHOLD) {
          // If dragged down far enough, dismiss the card
          dismiss();
        } else {
          // Otherwise, spring back to the original position
          Animated.spring(slideAnim, {
            toValue: 0,
            useNativeDriver: true,
            tension: 40,
            friction: 7
          }).start();
        }
      },
      
      // Terminate responder when needed
      onPanResponderTerminate: () => {
        // Spring back to original position if terminated
        Animated.spring(slideAnim, {
          toValue: 0,
          useNativeDriver: true,
        }).start();
      }
    })
  ).current;

  // Animate card entry from bottom
  useEffect(() => {
    Animated.parallel([
      Animated.spring(slideAnim, {
        toValue: 0,
        speed: 12,
        bounciness: 6,
        useNativeDriver: true,
      }),
      Animated.timing(opacityAnim, {
        toValue: 1,
        duration: 300,
        useNativeDriver: true,
      })
    ]).start();
  }, []);

  // Dismiss animation - slide down
  const dismiss = () => {
    Animated.parallel([
      Animated.timing(slideAnim, {
        toValue: getAvailableSpace(),
        duration: 300,
        useNativeDriver: true,
      }),
      Animated.timing(opacityAnim, {
        toValue: 0,
        duration: 300,
        useNativeDriver: true,
      })
    ]).start(() => {
      onDismiss();
    });
  };

  // Close image modal
  const closeImageModal = () => {
    setShowImageModal(false);
    setSelectedImageIndex(null);
  };

  // Image gallery
  const handleImageTap = (index: number) => {
    console.log('Image tapped:', index);
    setSelectedImageIndex(index);
    setShowImageModal(true);
  };

  // Handle sending an invitation
  const handleSendInvite = () => {
    if (onInvite) {
      setIsLoading(true);
      onInvite(uid);
    }
  };
  
  // Handle accepting an invitation
  const handleAcceptInvite = () => {
    if (onAcceptInvite && connectionId) {
      setIsLoading(true);
      onAcceptInvite(connectionId);
    }
  };
  
  // Handle declining an invitation
  const handleDeclineInvite = () => {
    if (onDeclineInvite && connectionId) {
      setIsLoading(true);
      onDeclineInvite(connectionId);
    }
  };
  
  // Handle starting a chat
  const handleStartChat = () => {
    if (onStartChat) {
      onStartChat(uid);
    }
  };

  // Get tier display info
  const getTierInfo = () => {
    switch(tier) {
      case 'soulmate': return { name: 'Soulmate', color: '#00B0FF' };
      case 'bestFriend': return { name: 'Best Friend', color: '#FFD700' };
      case 'friend': return { name: 'Friend', color: '#C0C0C0' };
      case 'buddy': return { name: 'Buddy', color: '#CD7F32' };
      case 'casual':
      default: return { name: 'Casual', color: '#999999' };
    }
  };

  const tierInfo = getTierInfo();
  
  // Render action buttons based on connection status
  const renderActionButtons = () => {
    if (checkingConnection || isLoading) {
      return (
        <View style={styles.buttonContainer}>
          <View style={[styles.button, { backgroundColor: '#ccc' }]}>
            <ActivityIndicator size="small" color="#fff" />
          </View>
        </View>
      );
    }
    
    switch (connectionStatus) {
      case 'none':
        // No connection - show Connect button
        return (
          <View style={styles.buttonContainer}>
            {onInvite && (
              <TouchableOpacity 
                style={[styles.button, { backgroundColor: '#4B7BEC' }]}
                onPress={handleSendInvite}
              >
                <FontAwesome name="user-plus" size={18} color="#fff" />
                <Text style={styles.buttonText}>Connect</Text>
              </TouchableOpacity>
            )}
          </View>
        );
        
      case 'pending_sent':
        // We sent an invitation - show Pending button (disabled)
        return (
          <View style={styles.buttonContainer}>
            <View style={[styles.button, { backgroundColor: '#ccc' }]}>
              <FontAwesome name="clock-o" size={18} color="#fff" />
              <Text style={styles.buttonText}>Pending</Text>
            </View>
          </View>
        );
        
      case 'pending_received':
        // We received an invitation - show Accept/Decline buttons
        return (
          <View style={styles.buttonContainer}>
            <TouchableOpacity 
              style={[styles.button, styles.buttonHalf, { backgroundColor: '#4BB543' }]}
              onPress={handleAcceptInvite}
            >
              <FontAwesome name="check" size={18} color="#fff" />
              <Text style={styles.buttonText}>Accept</Text>
            </TouchableOpacity>
            
            <TouchableOpacity 
              style={[styles.button, styles.buttonHalf, { backgroundColor: '#FF3B30' }]}
              onPress={handleDeclineInvite}
            >
              <FontAwesome name="times" size={18} color="#fff" />
              <Text style={styles.buttonText}>Decline</Text>
            </TouchableOpacity>
          </View>
        );
        
      case 'connected':
        // Connected - show Message button
        return (
          <View style={styles.buttonContainer}>
            <TouchableOpacity 
              style={[styles.button, { backgroundColor: '#26DE81' }]}
              onPress={handleStartChat}
            >
              <FontAwesome name="comment" size={18} color="#fff" />
              <Text style={styles.buttonText}>Message</Text>
            </TouchableOpacity>
          </View>
        );
        
      default:
        return null;
    }
  };

  return (
    <Animated.View 
      style={[
        styles.overlay, 
        { opacity: opacityAnim }
      ]}
    >
      <TouchableOpacity 
        style={styles.dismissOverlay} 
        activeOpacity={1} 
        onPress={dismiss}
      >
        <Animated.View 
          style={[
            styles.container, 
            { 
              transform: [{ translateY: slideAnim }],
              // Position from bottom with more space above the tab bar
              bottom: TAB_BAR_HEIGHT + 20,
              // Ensure top margin accounts for header
              top: HEADER_HEIGHT + 10,
              // Use a calculated height to ensure card fits between header and tab bar
              height: undefined,
              maxHeight: height - HEADER_HEIGHT - TAB_BAR_HEIGHT - 40
            }
          ]}
        >
          {/* This TouchableOpacity blocks touch events from propagating to the overlay */}
          <TouchableOpacity activeOpacity={1} style={{flex: 1}} onPress={() => {}}>
            {/* Close button */}
            <TouchableOpacity 
              style={styles.closeButton}
              onPress={dismiss}
            >
              <FontAwesome name="times" size={22} color="#888" />
            </TouchableOpacity>

          {/* Drag Handle - Only area where pan gesture works */}
          <View {...panResponder.panHandlers} style={styles.dragHandle}>
            <View style={styles.dragIndicator} />
          </View>

          {/* Main Content Area - No pan gestures here */}
          <View style={styles.contentWrapper}>
            {/* Content in ScrollView including action buttons */}
            <ScrollView 
              style={styles.scrollView} 
              contentContainerStyle={styles.scrollViewContent}
              showsVerticalScrollIndicator={true}
              bounces={false}
              overScrollMode="never"
              contentInset={{ bottom: 20 }}
              automaticallyAdjustContentInsets={false}
            >
              {/* Profile Header */}
              <View style={styles.header}>
                <View style={[styles.photoContainer, { borderColor: tierInfo.color }]}>
                  {photoURL ? (
                    <Image 
                      source={{ uri: photoURL }} 
                      style={styles.photo}
                      resizeMode="cover"
                    />
                  ) : (
                    <View style={[styles.defaultPhoto, { backgroundColor: tierInfo.color }]}>
                      <FontAwesome name="user" size={40} color="#fff" />
                    </View>
                  )}
                </View>
                
                <View style={styles.userInfo}>
                  <Text style={styles.nameText}>{name}</Text>
                  <View style={styles.badgeContainer}>
                    <View style={[styles.tierBadge, { backgroundColor: tierInfo.color }]}>
                      <Text style={styles.tierText}>{tierInfo.name}</Text>
                    </View>
                    
                    {online && (
                      <View style={styles.onlineBadge}>
                        <Text style={styles.onlineText}>Online</Text>
                      </View>
                    )}
                  </View>
                  {distance !== undefined && (
                    <Text style={styles.distanceText}>{distance}m away</Text>
                  )}
                </View>
              </View>

              {/* Bio Section */}
              {bio && (
                <View style={styles.section}>
                  <Text style={styles.sectionTitle}>Bio</Text>
                  <Text style={styles.bioText}>{bio}</Text>
                </View>
              )}

              {/* Photo Gallery */}
              {safeProfileImages.length > 0 && (
                <View style={styles.section}>
                  <Text style={styles.sectionTitle}>Photos</Text>
                  <View style={styles.photoGrid}>
                    {safeProfileImages.map((url, index) => (
                      <TouchableOpacity 
                        key={`image-${index}`} 
                        style={styles.gridItem}
                        onPress={() => handleImageTap(index)}
                      >
                        <Image 
                          source={{ uri: url }} 
                          style={styles.gridImage}
                          resizeMode="cover"
                        />
                      </TouchableOpacity>
                    ))}
                  </View>
                </View>
              )}

              {/* Shared Interests */}
              {safeSharedInterests.length > 0 && (
                <View style={styles.section}>
                  <Text style={styles.sectionTitle}>
                    Shared Interests ({safeSharedInterests.length})
                  </Text>
                  <View style={styles.interestsContainer}>
                    {safeSharedInterests.map((interest, index) => (
                      <View 
                        key={`interest-${index}`} 
                        style={[
                          styles.interestTag, 
                          { backgroundColor: `${tierInfo.color}15` }
                        ]}
                      >
                        <Text style={[styles.interestText, { color: tierInfo.color }]}>
                          {interest}
                        </Text>
                      </View>
                    ))}
                  </View>
                </View>
              )}

              {/* Empty Interests Fallback */}
              {safeSharedInterests.length === 0 && (
                <View style={styles.section}>
                  <Text style={styles.sectionTitle}>Shared Interests (0)</Text>
                  <View style={styles.emptyInterests}>
                    <Text style={styles.emptyText}>No shared interests found</Text>
                  </View>
                </View>
              )}

              {/* Action Buttons included as part of scrollable content */}
              <View style={styles.buttonSection}>
                {renderActionButtons()}
              </View>
              
              {/* Bottom Spacing - limited to avoid excessive padding */}
              <View style={{ height: 15 }} />
            </ScrollView>
          </View>
          </TouchableOpacity>
        </Animated.View>
      </TouchableOpacity>

      {/* Full Screen Image Modal */}
      <Modal
        visible={showImageModal}
        transparent={true}
        animationType="fade"
        onRequestClose={closeImageModal}
      >
        <View style={styles.modalContainer}>
          <TouchableOpacity 
            style={styles.modalCloseButton}
            onPress={closeImageModal}
          >
            <FontAwesome name="close" size={24} color="#fff" />
          </TouchableOpacity>
          
          {selectedImageIndex !== null && safeProfileImages[selectedImageIndex] && (
            <Image
              source={{ uri: safeProfileImages[selectedImageIndex] }}
              style={styles.fullImage}
              resizeMode="contain"
            />
          )}
        </View>
      </Modal>
    </Animated.View>
  );
};

const styles = StyleSheet.create({
  overlay: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
    justifyContent: 'flex-start',
  },
  dismissOverlay: {
    flex: 1,
  },
  container: {
    position: 'absolute',
    left: 10,
    right: 10,
    backgroundColor: 'white',
    borderRadius: 20,
    minHeight: 200, // Ensure minimum height
    flexDirection: 'column',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.3,
    shadowRadius: 5,
    elevation: 10,
    overflow: 'hidden', // Ensure content doesn't overflow
  },
  contentWrapper: {
    flex: 1,
    flexDirection: 'column',
    overflow: 'hidden',
    borderBottomLeftRadius: 20,
    borderBottomRightRadius: 20,
  },
  closeButton: {
    position: 'absolute',
    top: 10,
    right: 10,
    width: 36,
    height: 36,
    borderRadius: 18,
    backgroundColor: '#f0f0f0',
    justifyContent: 'center',
    alignItems: 'center',
    zIndex: 10,
  },
  dragHandle: {
    height: 40,
    justifyContent: 'center',
    alignItems: 'center',
    borderTopLeftRadius: 20,
    borderTopRightRadius: 20,
    padding: 5,
    backgroundColor: 'white', // Ensures visible background when dragging
  },
  dragIndicator: {
    width: 40,
    height: 5,
    backgroundColor: '#D3D3D3',
    borderRadius: 2.5,
  },
  scrollView: {
    flex: 1,
    borderBottomLeftRadius: 20,
    borderBottomRightRadius: 20,
    overflow: 'hidden', // Ensure content doesn't overflow
  },
  scrollViewContent: {
    padding: 20,
    paddingTop: 10,
    paddingBottom: 30, // Adequate bottom padding
  },
  buttonSection: {
    marginTop: 30,
    paddingTop: 15,
    borderTopWidth: 1,
    borderTopColor: '#eee',
  },
  header: {
    flexDirection: 'row',
    marginBottom: 20,
  },
  photoContainer: {
    width: 80,
    height: 80,
    borderRadius: 40,
    borderWidth: 3,
    overflow: 'hidden',
  },
  photo: {
    width: '100%',
    height: '100%',
  },
  defaultPhoto: {
    width: '100%',
    height: '100%',
    justifyContent: 'center',
    alignItems: 'center',
  },
  userInfo: {
    flex: 1,
    marginLeft: 15,
    justifyContent: 'center',
  },
  nameText: {
    fontSize: 20,
    fontWeight: 'bold',
    color: '#333',
    marginBottom: 5,
  },
  badgeContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    flexWrap: 'wrap',
    marginBottom: 5,
  },
  tierBadge: {
    paddingHorizontal: 10,
    paddingVertical: 4,
    borderRadius: 12,
    alignSelf: 'flex-start',
    marginRight: 8,
  },
  onlineBadge: {
    paddingHorizontal: 10,
    paddingVertical: 4,
    borderRadius: 12,
    backgroundColor: '#4CAF50',
    alignSelf: 'flex-start',
  },
  tierText: {
    color: 'white',
    fontWeight: 'bold',
    fontSize: 12,
  },
  onlineText: {
    color: 'white',
    fontWeight: 'bold',
    fontSize: 12,
  },
  distanceText: {
    fontSize: 14,
    color: '#666',
  },
  section: {
    marginTop: 20,
  },
  sectionTitle: {
    fontSize: 17,
    fontWeight: 'bold',
    color: '#333',
    marginBottom: 10,
  },
  bioText: {
    fontSize: 15,
    color: '#444',
    lineHeight: 22,
  },
  photoGrid: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    marginHorizontal: -5,
  },
  gridItem: {
    width: '33.33%',
    aspectRatio: 1,
    padding: 5,
  },
  gridImage: {
    width: '100%',
    height: '100%',
    borderRadius: 8,
    backgroundColor: '#f0f0f0',
  },
  interestsContainer: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    marginHorizontal: -4,
  },
  interestTag: {
    paddingHorizontal: 12,
    paddingVertical: 8,
    borderRadius: 16,
    margin: 4,
    borderWidth: 1,
    borderColor: 'rgba(0,0,0,0.1)',
  },
  interestText: {
    fontSize: 14,
    fontWeight: '500',
  },
  emptyInterests: {
    padding: 15,
    backgroundColor: '#f8f8f8',
    borderRadius: 8,
    alignItems: 'center',
  },
  emptyText: {
    color: '#999',
    fontStyle: 'italic',
  },
  buttonContainer: {
    flexDirection: 'row',
    padding: 15,
    backgroundColor: 'white',
    borderRadius: 12,
  },
  button: {
    flex: 1,
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: 12,
    borderRadius: 8,
    marginHorizontal: 5,
  },
  buttonHalf: {
    flex: 0.5,
  },
  buttonText: {
    color: 'white',
    fontWeight: 'bold',
    fontSize: 15,
    marginLeft: 8,
  },
  modalContainer: {
    flex: 1,
    backgroundColor: 'rgba(0, 0, 0, 0.9)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  modalCloseButton: {
    position: 'absolute',
    top: 40,
    right: 20,
    width: 44,
    height: 44,
    borderRadius: 22,
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
    justifyContent: 'center',
    alignItems: 'center',
    zIndex: 10,
  },
  fullImage: {
    width: '90%',
    height: '70%',
  },
});

export default ProfileCard;
</file>

<file path="constants/Colors.ts">
// Primary purple palette matching the profile style
const primaryColor = '#6C5CE7';
const primaryLightColor = '#a29bfe';
const secondaryColor = '#FF6B6B';

export default {
  light: {
    text: '#333',
    background: '#fff',
    tint: primaryColor,
    tabIconDefault: '#BDBDBD',
    tabIconSelected: primaryColor,
    tabBarBackground: '#FFFFFF',
    tabBarBorder: '#F0F0F0',
    cardBackground: '#FFF',
    cardShadow: 'rgba(0, 0, 0, 0.05)',
  },
  dark: {
    text: '#F5F5F5',
    background: '#121212',
    tint: primaryLightColor,
    tabIconDefault: '#757575',
    tabIconSelected: primaryLightColor,
    tabBarBackground: '#1E1E1E',
    tabBarBorder: '#2C2C2C',
    cardBackground: '#232323',
    cardShadow: 'rgba(0, 0, 0, 0.2)',
  },
  primary: primaryColor,
  primaryLight: primaryLightColor,
  secondary: secondaryColor,
};
</file>

<file path="utils/geospatial.ts">
/**
 * Utility functions for geospatial calculations and marker positioning
 */

import { Platform } from 'react-native';
import { GeoPoint } from '@firebase/firestore';

/**
 * Calculate distance between two points in meters using the Haversine formula
 */
export const getDistanceFromLatLonInMeters = (lat1: number, lon1: number, lat2: number, lon2: number): number => {
  const R = 6371; // Radius of the earth in km
  const dLat = deg2rad(lat2 - lat1);
  const dLon = deg2rad(lon2 - lon1);
  const a = 
    Math.sin(dLat/2) * Math.sin(dLat/2) +
    Math.cos(deg2rad(lat1)) * Math.cos(deg2rad(lat2)) * 
    Math.sin(dLon/2) * Math.sin(dLon/2); 
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a)); 
  const d = R * c * 1000; // Distance in meters
  return d;
};

/**
 * Convert degrees to radians
 */
export const deg2rad = (deg: number): number => {
  return deg * (Math.PI/180);
};

/**
 * Create a GeoHash for Firebase GeoPoint (simplified implementation)
 */
export const createGeoHash = (latitude: number, longitude: number): string => {
  // This is a simplified version, in production you would use a library like geofire
  const lat = latitude.toFixed(6);
  const lng = longitude.toFixed(6);
  return `${lat}_${lng}`;
};

/**
 * Offset overlapping markers to make them all visible
 * Improved implementation that better handles multiple overlapping markers
 */
export const offsetOverlappingMarkers = (markers: any[]): any[] => {
  const MIN_DISTANCE = 0.00025; // Increased minimum distance in degrees lat/lng
  const result = [...markers];
  
  // Enhanced algorithm:
  // 1. Use a more precise method to detect overlapping
  // 2. Use a spiral pattern with increasing distance for more markers
  // 3. Consider marker size in the offset calculation
  
  // Group markers by location (with some tolerance)
  const locationGroups: {[key: string]: any[]} = {};
  
  markers.forEach(marker => {
    // Create a key by rounding the coordinates with higher precision
    const key = `${marker.latitude.toFixed(6)}_${marker.longitude.toFixed(6)}`;
    
    if (!locationGroups[key]) {
      locationGroups[key] = [];
    }
    
    locationGroups[key].push(marker);
  });
  
  // For each group with more than one marker, apply more sophisticated offsets
  Object.values(locationGroups).forEach(group => {
    if (group.length <= 1) return;
    
    // Sort by tier precedence (soulmate first, casual last)
    group.sort((a, b) => {
      const tierRanking: { [key: string]: number } = {
        'soulmate': 5,
        'bestFriend': 4,
        'friend': 3,
        'buddy': 2,
        'casual': 1
      };
      
      return tierRanking[b.tier] - tierRanking[a.tier];
    });
    
    // Keep the first marker at its original position
    const baseMarker = group[0];
    
    // For large groups, use a spiral pattern instead of a circle
    const useSpiral = group.length > 8;
    
    // Add a small identifier to show original coordinate group
    group.forEach((marker) => {
      marker.originalCoordinateGroup = key;
    });
    
    // Calculate scale based on marker's tier - larger markers need more space
    const getScaleForTier = (tier: string): number => {
      const tierScales: { [key: string]: number } = {
        'soulmate': 1.5,
        'bestFriend': 1.4,
        'friend': 1.3,
        'buddy': 1.2,
        'casual': 1.0
      };
      
      return tierScales[tier] || 1.0;
    };
    
    if (useSpiral) {
      // Apply spiral pattern for many markers
      const spiralAngleDelta = 2 * Math.PI / 6;  // How much to rotate per spiral
      let currentRadius = MIN_DISTANCE;
      let currentAngle = 0;
      
      for (let i = 1; i < group.length; i++) {
        const marker = group[i];
        const scale = getScaleForTier(marker.tier);
        
        // Calculate position on spiral
        const offsetLat = currentRadius * Math.sin(currentAngle) * scale;
        const offsetLng = currentRadius * Math.cos(currentAngle) * scale;
        
        // Apply offset
        marker.latitude = baseMarker.latitude + offsetLat;
        marker.longitude = baseMarker.longitude + offsetLng;
        
        // Increment angle and occasionally radius for spiral effect
        currentAngle += spiralAngleDelta;
        if (i % 6 === 0) {
          currentRadius += MIN_DISTANCE / 2;
        }
      }
    } else {
      // For smaller groups, use a circle with scaled distances
      for (let i = 1; i < group.length; i++) {
        const marker = group[i];
        const scale = getScaleForTier(marker.tier);
        
        // Calculate angle for this marker's position in the circle
        const angle = (i - 1) * (2 * Math.PI / (group.length - 1));
        
        // Apply scaled radius based on tier
        const radius = MIN_DISTANCE * scale;
        
        // Calculate offset
        const offsetLat = radius * Math.sin(angle);
        const offsetLng = radius * Math.cos(angle);
        
        // Apply offset
        marker.latitude = baseMarker.latitude + offsetLat;
        marker.longitude = baseMarker.longitude + offsetLng;
      }
    }
  });
  
  return result;
};

/**
 * Convert a region delta to a radius in meters
 */
export const deltaToRadiusInMeters = (latitude: number, latitudeDelta: number): number => {
  // Approximate conversion from delta to radius in meters
  // This is a simplified formula, not exact but good enough for visualization
  const EARTH_RADIUS = 6371000; // Earth radius in meters
  const latRadians = latitude * (Math.PI / 180);
  
  // Calculate the meters per degree at this latitude
  const metersPerDegree = EARTH_RADIUS * Math.cos(latRadians) * (Math.PI / 180);
  
  // Convert latitudeDelta to meters
  return latitudeDelta * metersPerDegree / 2;
};

/**
 * Convert a radius in meters to a region delta
 */
export const radiusToLatitudeDelta = (latitude: number, radiusInMeters: number): number => {
  // Approximate conversion from radius in meters to delta
  // This is a simplified formula, not exact but good enough for visualization
  const EARTH_RADIUS = 6371000; // Earth radius in meters
  const latRadians = latitude * (Math.PI / 180);
  
  // Calculate the degrees per meter at this latitude
  const degreesPerMeter = (180 / Math.PI) / (EARTH_RADIUS * Math.cos(latRadians));
  
  // Convert radius to latitudeDelta
  return radiusInMeters * degreesPerMeter * 2;
};

/**
 * Check if a device is using iOS
 */
export const isIOS = (): boolean => {
  return Platform.OS === 'ios';
};

export default {
  getDistanceFromLatLonInMeters,
  deg2rad,
  createGeoHash,
  offsetOverlappingMarkers,
  deltaToRadiusInMeters,
  radiusToLatitudeDelta,
  isIOS
};
</file>

<file path="app.json">
{
  "expo": {
    "name": "HiveSocial",
    "slug": "hivesocial",
    "version": "1.0.0",
    "orientation": "portrait",
    "icon": "./assets/images/icon.png",
    "scheme": "hivesocial",
    "userInterfaceStyle": "automatic",
    "newArchEnabled": true,
    "splash": {
      "image": "./assets/images/splash-icon.png",
      "resizeMode": "contain",
      "backgroundColor": "#ffffff"
    },
    "ios": {
      "supportsTablet": true,
      "bundleIdentifier": "com.romanabad.hivesocial",
      "googleServicesFile": "./ios/GoogleService-Info.plist",
      "infoPlist": {
        "NSLocationWhenInUseUsageDescription": "HiveSocial uses your location to help you find nearby people with similar interests.",
        "NSLocationAlwaysAndWhenInUseUsageDescription": "HiveSocial uses your location to help you find nearby people with similar interests.",
        "NSLocationAlwaysUsageDescription": "HiveSocial uses your location to help you find nearby people with similar interests.",
        "NSPhotoLibraryUsageDescription": "HiveSocial needs access to your photos to let you update your profile picture.",
        "NSCameraUsageDescription": "HiveSocial needs access to your camera to take a profile picture.",
        "UIBackgroundModes": ["location", "fetch"]
      },
      "config": {
        "googleMapsApiKey": "YOUR_GOOGLE_MAPS_API_KEY"
      }
    },
    "android": {
      "adaptiveIcon": {
        "foregroundImage": "./assets/images/adaptive-icon.png",
        "backgroundColor": "#ffffff"
      },
      "package": "com.romanabad.hivesocial",
      "googleServicesFile": "./android/app/google-services.json",
      "permissions": [
        "ACCESS_COARSE_LOCATION",
        "ACCESS_FINE_LOCATION",
        "ACCESS_BACKGROUND_LOCATION",
        "READ_EXTERNAL_STORAGE",
        "WRITE_EXTERNAL_STORAGE",
        "CAMERA"
      ],
      "config": {
        "googleMaps": {
          "apiKey": "YOUR_GOOGLE_MAPS_API_KEY"
        }
      },
      "edgeToEdgeEnabled": true
    },
    "web": {
      "bundler": "metro",
      "output": "static",
      "favicon": "./assets/images/favicon.png"
    },
    "plugins": [
      "expo-router",
      [
        "expo-location",
        {
          "locationAlwaysAndWhenInUsePermission": "HiveSocial uses your location to help you find nearby people with similar interests.",
          "locationAlwaysPermission": "HiveSocial uses your location to help you find nearby people with similar interests.",
          "locationWhenInUsePermission": "HiveSocial uses your location to help you find nearby people with similar interests."
        }
      ],
      [
        "expo-image-picker",
        {
          "photosPermission": "HiveSocial needs access to your photos to let you update your profile picture."
        }
      ]
    ],
    "experiments": {
      "typedRoutes": true
    }
  }
}
</file>

<file path="app/(tabs)/chat/index.tsx">
import React, { useState, useEffect, useRef } from 'react';
import { 
  StyleSheet, 
  View, 
  Text, 
  FlatList, 
  TouchableOpacity, 
  ActivityIndicator, 
  Image,
  Animated,
  StatusBar,
  Dimensions,
  Platform
} from 'react-native';
import { router } from 'expo-router';
import { LinearGradient } from 'expo-linear-gradient';
import FontAwesome from '@expo/vector-icons/FontAwesome';
import MaterialIcons from '@expo/vector-icons/MaterialIcons';
import { useAuth } from '@/contexts/AuthContext';
import { 
  collection, 
  query, 
  where, 
  getDocs, 
  orderBy, 
  onSnapshot, 
  doc, 
  getDoc 
} from '@firebase/firestore';
import { db } from '@/config/firebase';
import { useSafeAreaInsets } from 'react-native-safe-area-context';

const { width: SCREEN_WIDTH } = Dimensions.get('window');

// Tabbed navigation menu height calculation
const TAB_BAR_HEIGHT = Platform.OS === 'ios' ? 83 : 70; // Height including safe area insets on iOS

export default function ChatScreen() {
  const { user, userData } = useAuth();
  const [loading, setLoading] = useState(true);
  const [chatRooms, setChatRooms] = useState([]);
  const scrollY = useRef(new Animated.Value(0)).current;
  
  // Animated header opacity for scroll effect
  const headerOpacity = scrollY.interpolate({
    inputRange: [0, 60],
    outputRange: [0, 1],
    extrapolate: 'clamp',
  });

  // Load chat rooms
  useEffect(() => {
    if (!user?.uid) return;
    
    let unsubscribers = [];

    const loadChatRooms = async () => {
      try {
        console.log('Loading chat rooms for user:', user.uid);
        
        // First get all connections that the user is part of
        const connectionsQuery = query(
          collection(db, 'connectionRequests'),
          where('status', '==', 'accepted'),
          where('participants', 'array-contains', user.uid)
        );
        
        // Get connection documents
        const connectionSnapshot = await getDocs(connectionsQuery);
        
        if (connectionSnapshot.empty) {
          console.log('No connections found');
          setChatRooms([]);
          setLoading(false);
          return;
        }

        // Get chat room IDs from the connections
        const chatRoomIds = connectionSnapshot.docs
          .filter(doc => doc.data().chatRoomId)
          .map(doc => ({
            id: doc.data().chatRoomId,
            connectionData: doc.data()
          }));
        
        if (chatRoomIds.length === 0) {
          console.log('No chat rooms found');
          setChatRooms([]);
          setLoading(false);
          return;
        }
        
        // Set up a listener for each chat room
        chatRoomIds.forEach(({ id, connectionData }) => {
          const chatRoomRef = doc(db, 'chatRooms', id);
          
          const unsubscribe = onSnapshot(chatRoomRef, async (chatRoomDoc) => {
            if (!chatRoomDoc.exists()) {
              console.log(`Chat room ${id} does not exist`);
              return;
            }
            
            const chatRoomData = chatRoomDoc.data();
            
            // Find the other user's ID (not the current user)
            const otherUserId = connectionData.senderId === user.uid 
              ? connectionData.receiverId 
              : connectionData.senderId;
            
            // Get other user's info
            const otherUserDoc = await getDoc(doc(db, 'users', otherUserId));
            
            let otherUserData = { name: 'Unknown User', photoURL: null };
            if (otherUserDoc.exists()) {
              otherUserData = otherUserDoc.data();
            }
            
            // Create a chat room object with the necessary data
            const chatRoom = {
              id: chatRoomDoc.id,
              otherUserId,
              otherUserName: otherUserData.name,
              otherUserPhotoURL: otherUserData.photoURL,
              lastMessage: chatRoomData.lastMessageText || 'No messages yet',
              lastMessageTimestamp: chatRoomData.lastMessageTimestamp?.toDate() || null,
              lastMessageUserId: chatRoomData.lastMessage?.userId || null,
              messageStatus: chatRoomData.lastMessage?.status || null,
              unread: 0, // TODO: Implement unread count
              tier: connectionData.tier || 'casual'
            };
            
            // Update the chat rooms state
            setChatRooms(prevRooms => {
              // Check if this room already exists in the state
              const existingIndex = prevRooms.findIndex(room => room.id === chatRoom.id);
              
              if (existingIndex >= 0) {
                // Update existing room
                const updatedRooms = [...prevRooms];
                updatedRooms[existingIndex] = chatRoom;
                return updatedRooms;
              } else {
                // Add new room
                return [...prevRooms, chatRoom];
              }
            });
            
            setLoading(false);
          }, error => {
            console.error(`Error listening to chat room ${id}:`, error);
          });
          
          unsubscribers.push(unsubscribe);
        });
      } catch (error) {
        console.error('Error loading chat rooms:', error);
        setLoading(false);
      }
    };

    loadChatRooms();
    
    // Return cleanup function that unsubscribes from all listeners
    return () => {
      console.log(`Cleaning up ${unsubscribers.length} chat room listeners`);
      unsubscribers.forEach(unsubscribe => {
        if (typeof unsubscribe === 'function') {
          unsubscribe();
        }
      });
    };
  }, [user?.uid]);

  const formatTimestamp = (timestamp) => {
    if (!timestamp) return '';
    
    const now = new Date();
    const messageDate = new Date(timestamp);
    
    // Check if the message is from today
    if (
      messageDate.getDate() === now.getDate() &&
      messageDate.getMonth() === now.getMonth() &&
      messageDate.getFullYear() === now.getFullYear()
    ) {
      // Format as time only for today's messages
      return messageDate.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
    }
    
    // Check if the message is from this week
    const diff = now.getTime() - messageDate.getTime();
    const daysDiff = Math.floor(diff / (1000 * 60 * 60 * 24));
    
    if (daysDiff < 7) {
      // Format as day of week for this week's messages
      return messageDate.toLocaleDateString([], { weekday: 'short' });
    }
    
    // Format as date for older messages
    return messageDate.toLocaleDateString([], { month: 'short', day: 'numeric' });
  };

  const renderChatItem = ({ item }) => (
    <TouchableOpacity
      style={styles.chatItem}
      onPress={() => router.push(`/chat/${item.id}?name=${encodeURIComponent(item.otherUserName)}`)}
      activeOpacity={0.7}
    >
      <View style={styles.avatar}>
        {item.otherUserPhotoURL ? (
          <Image 
            source={{ uri: item.otherUserPhotoURL }} 
            style={styles.avatarImage} 
            resizeMode="cover" 
          />
        ) : (
          <View style={styles.defaultAvatar}>
            <Text style={styles.defaultAvatarText}>
              {(item.otherUserName || '?').charAt(0).toUpperCase()}
            </Text>
          </View>
        )}
        {/* Online status indicator would go here */}
      </View>
      <View style={styles.chatInfo}>
        <View style={styles.chatHeader}>
          <Text style={styles.name} numberOfLines={1}>
            {item.otherUserName}
          </Text>
          {item.lastMessageTimestamp && (
            <Text style={styles.timestamp}>
              {formatTimestamp(item.lastMessageTimestamp)}
            </Text>
          )}
        </View>
        <View style={styles.chatFooter}>
          <View style={styles.lastMessageContainer}>
            <Text numberOfLines={1} style={styles.lastMessage}>
              {/* Show "You: " prefix if last message was from current user */}
              {item.lastMessageUserId === user?.uid ? 'You: ' : ''}
              {item.lastMessage}
            </Text>
            
            {/* Show status for last message if it's from the current user */}
            {item.lastMessageUserId === user?.uid && item.messageStatus && (
              <View style={styles.statusIconContainer}>
                {item.messageStatus.read ? (
                  <MaterialIcons name="done-all" size={16} color="#6C5CE7" />
                ) : item.messageStatus.delivered ? (
                  <MaterialIcons name="done" size={16} color="#a29bfe" />
                ) : (
                  <MaterialIcons name="access-time" size={14} color="#bdbdbd" />
                )}
              </View>
            )}
          </View>
          
          {item.unread > 0 && (
            <View style={styles.unreadBadge}>
              <Text style={styles.unreadText}>{item.unread}</Text>
            </View>
          )}
        </View>
      </View>
    </TouchableOpacity>
  );

  if (loading) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color="#6C5CE7" />
        <Text style={styles.loadingText}>Loading chats...</Text>
      </View>
    );
  }

  // Sort chat rooms by last message timestamp, newest first
  const sortedChatRooms = [...chatRooms].sort((a, b) => {
    if (!a.lastMessageTimestamp && !b.lastMessageTimestamp) return 0;
    if (!a.lastMessageTimestamp) return 1;
    if (!b.lastMessageTimestamp) return -1;
    return b.lastMessageTimestamp - a.lastMessageTimestamp;
  });

  return (
    <View style={styles.container}>
      <StatusBar style="dark" />
      
      {/* Animated Header */}
      <Animated.View style={[styles.animatedHeader, { opacity: headerOpacity }]}>
        <Text style={styles.animatedHeaderText}>Messages</Text>
      </Animated.View>
      
      {/* Main Content */}
      <View style={styles.contentContainer}>
        {/* Header */}
        <View style={styles.headerContainer}>
          <Text style={styles.title}>Messages</Text>
          <TouchableOpacity style={styles.searchButton}>
            <MaterialIcons name="search" size={24} color="#6C5CE7" />
          </TouchableOpacity>
        </View>
        
        {sortedChatRooms.length > 0 ? (
          <Animated.FlatList
            data={sortedChatRooms}
            renderItem={renderChatItem}
            keyExtractor={(item) => item.id}
            contentContainerStyle={styles.listContainer}
            showsVerticalScrollIndicator={false}
            onScroll={Animated.event(
              [{ nativeEvent: { contentOffset: { y: scrollY } } }],
              { useNativeDriver: true }
            )}
            scrollEventThrottle={16}
          />
        ) : (
          <View style={styles.emptyContainer}>
            <LinearGradient
              colors={['#6C5CE7', '#a29bfe']}
              style={styles.emptyIconBackground}
              start={{ x: 0, y: 0 }}
              end={{ x: 1, y: 1 }}
            >
              <MaterialIcons name="chat-bubble-outline" size={40} color="#fff" />
            </LinearGradient>
            <Text style={styles.emptyText}>No messages yet</Text>
            <Text style={styles.emptySubtext}>
              Connect with people around you to start chatting!
            </Text>
            <TouchableOpacity 
              style={styles.exploreButton}
              onPress={() => router.push('/map')}
              activeOpacity={0.8}
            >
              <LinearGradient
                colors={['#6C5CE7', '#a29bfe']}
                style={styles.exploreButtonGradient}
                start={{ x: 0, y: 0 }}
                end={{ x: 1, y: 0 }}
              >
                <Text style={styles.exploreButtonText}>Explore Map</Text>
              </LinearGradient>
            </TouchableOpacity>
          </View>
        )}
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
  },
  animatedHeader: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    height: Platform.OS === 'ios' ? 90 : 60,
    backgroundColor: '#fff',
    zIndex: 1000,
    justifyContent: 'flex-end',
    alignItems: 'center',
    paddingBottom: 10,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 3,
    elevation: 5,
  },
  animatedHeaderText: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#333',
  },
  contentContainer: {
    flex: 1,
    paddingTop: 16,
  },
  headerContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingHorizontal: 16,
    paddingBottom: 16,
  },
  title: {
    fontSize: 28,
    fontWeight: 'bold',
    color: '#333',
  },
  searchButton: {
    width: 40,
    height: 40,
    borderRadius: 20,
    backgroundColor: '#f0f0f0',
    justifyContent: 'center',
    alignItems: 'center',
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#f5f5f5',
  },
  loadingText: {
    marginTop: 16,
    fontSize: 16,
    color: '#666',
  },
  listContainer: {
    paddingHorizontal: 16,
    paddingBottom: TAB_BAR_HEIGHT + 20,
  },
  chatItem: {
    flexDirection: 'row',
    backgroundColor: '#fff',
    padding: 16,
    borderRadius: 16,
    marginBottom: 12,
    shadowColor: '#000',
    shadowOffset: {
      width: 0,
      height: 1,
    },
    shadowOpacity: 0.08,
    shadowRadius: 2,
    elevation: 2,
  },
  avatar: {
    position: 'relative',
    marginRight: 12,
    justifyContent: 'center',
    width: 56,
    height: 56,
    borderRadius: 28,
    overflow: 'hidden',
    backgroundColor: '#f3f0ff',
  },
  avatarImage: {
    width: 56,
    height: 56,
    borderRadius: 28,
  },
  defaultAvatar: {
    width: 56,
    height: 56,
    borderRadius: 28,
    backgroundColor: '#a29bfe',
    justifyContent: 'center',
    alignItems: 'center',
  },
  defaultAvatarText: {
    fontSize: 22,
    fontWeight: 'bold',
    color: '#fff',
  },
  chatInfo: {
    flex: 1,
    justifyContent: 'center',
  },
  chatHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 6,
  },
  chatFooter: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
  },
  name: {
    fontSize: 16,
    fontWeight: '600',
    color: '#333',
    flex: 1,
    marginRight: 8,
  },
  timestamp: {
    fontSize: 12,
    color: '#888',
  },
  lastMessageContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    flex: 1,
    marginRight: 8,
  },
  lastMessage: {
    fontSize: 14,
    color: '#666',
    flex: 1,
  },
  statusIconContainer: {
    marginLeft: 4,
    width: 16,
    height: 16,
    justifyContent: 'center',
    alignItems: 'center',
  },
  unreadBadge: {
    backgroundColor: '#6C5CE7',
    borderRadius: 12,
    minWidth: 24,
    height: 24,
    justifyContent: 'center',
    alignItems: 'center',
    paddingHorizontal: 8,
  },
  unreadText: {
    color: '#fff',
    fontSize: 12,
    fontWeight: 'bold',
  },
  emptyContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    paddingHorizontal: 32,
    paddingBottom: TAB_BAR_HEIGHT,
  },
  emptyIconBackground: {
    width: 80,
    height: 80,
    borderRadius: 40,
    justifyContent: 'center',
    alignItems: 'center',
    marginBottom: 16,
  },
  emptyText: {
    fontSize: 20,
    fontWeight: 'bold',
    color: '#333',
    marginTop: 8,
  },
  emptySubtext: {
    fontSize: 16,
    color: '#666',
    textAlign: 'center',
    marginTop: 8,
    lineHeight: 24,
  },
  exploreButton: {
    marginTop: 24,
    width: SCREEN_WIDTH * 0.6,
    height: 50,
    borderRadius: 25,
    overflow: 'hidden',
    shadowColor: '#6C5CE7',
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.2,
    shadowRadius: 8,
    elevation: 4,
  },
  exploreButtonGradient: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  exploreButtonText: {
    color: '#fff',
    fontWeight: 'bold',
    fontSize: 16,
  },
});
</file>

<file path="app/(tabs)/connections/index.tsx">
import React, { useState, useRef, useEffect } from 'react';
import { 
  StyleSheet, 
  View, 
  Text, 
  FlatList, 
  TouchableOpacity, 
  ActivityIndicator,
  Alert,
  Animated,
  Image,
  Dimensions,
  Platform,
  StatusBar
} from 'react-native';
import { router } from 'expo-router';
import { LinearGradient } from 'expo-linear-gradient';
import FontAwesome from '@expo/vector-icons/FontAwesome';
import MaterialIcons from '@expo/vector-icons/MaterialIcons';
import Ionicons from '@expo/vector-icons/Ionicons';
import { useAuth } from '@/contexts/AuthContext';
import { 
  collection, 
  query, 
  where, 
  getDocs, 
  updateDoc, 
  doc, 
  deleteDoc, 
  onSnapshot,
  addDoc,
  serverTimestamp
} from '@firebase/firestore';
import { db } from '@/config/firebase';
import { useSafeAreaInsets } from 'react-native-safe-area-context';

const { width: SCREEN_WIDTH } = Dimensions.get('window');
const CARD_PADDING = 16;

// Tabbed navigation menu height calculation
const TAB_BAR_HEIGHT = Platform.OS === 'ios' ? 83 : 70; // Height including safe area insets on iOS

// Tier color mapping to match the map screen colors
const TIER_COLORS = {
  'soulmate': { primary: '#00B0FF', gradient: ['#00B0FF', '#64c8ff'] },     // Light blue
  'bestFriend': { primary: '#FFD700', gradient: ['#FFD700', '#ffe666'] },  // Gold
  'friend': { primary: '#C0C0C0', gradient: ['#C0C0C0', '#e6e6e6'] },      // Silver
  'buddy': { primary: '#CD7F32', gradient: ['#CD7F32', '#e2aa73'] },       // Bronze
  'casual': { primary: '#AAAAAA', gradient: ['#AAAAAA', '#d9d9d9'] }        // Gray
};

export default function ConnectionsScreen() {
  const { user, userData } = useAuth();
  const [loading, setLoading] = useState(true);
  const [pendingConnections, setPendingConnections] = useState([]);
  const [connections, setConnections] = useState([]);
  const [activeTab, setActiveTab] = useState('connections'); // 'connections' or 'requests'
  
  // Animation values
  const scrollY = useRef(new Animated.Value(0)).current;
  const headerOpacity = scrollY.interpolate({
    inputRange: [0, 60],
    outputRange: [0, 1],
    extrapolate: 'clamp',
  });
  
  // Tab slide animation
  const tabIndicatorPosition = useRef(new Animated.Value(0)).current;
  
  // Animate tab indicator when active tab changes
  useEffect(() => {
    Animated.spring(tabIndicatorPosition, {
      toValue: activeTab === 'connections' ? 0 : 1,
      useNativeDriver: false,
      friction: 8,
      tension: 100
    }).start();
  }, [activeTab]);

  // Load connection requests and current connections
  useEffect(() => {
    if (!user?.uid) return;

    // Create listeners for both pending connections and active connections
    console.log('Setting up connection listeners for user:', user.uid);
    
    // Get pending connection requests (status = 'pending')
    const pendingConnectionsQuery = query(
      collection(db, 'connectionRequests'),
      where('receiverId', '==', user.uid),
      where('status', '==', 'pending')
    );

    // Get active connections (status = 'accepted')
    const connectionsQuery = query(
      collection(db, 'connectionRequests'),
      where('status', '==', 'accepted'),
      where('participants', 'array-contains', user.uid)
    );

    // Set up listeners
    const unsubscribePending = onSnapshot(pendingConnectionsQuery, async (snapshot) => {
      console.log(`Received ${snapshot.docs.length} pending connection requests`);
      
      // Get user data for each sender
      const pendingRequestsWithData = await Promise.all(
        snapshot.docs.map(async (docSnapshot) => {
          const requestData = docSnapshot.data();
          // Get sender info
          const senderDoc = await getDocs(
            query(collection(db, 'users'), where('uid', '==', requestData.senderId))
          );
          
          let senderData = { name: 'Unknown User' };
          if (!senderDoc.empty) {
            senderData = senderDoc.docs[0].data();
          }
          
          return {
            id: docSnapshot.id,
            ...requestData,
            senderName: senderData.name,
            senderPhotoURL: senderData.photoURL,
            timestamp: requestData.timestamp?.toDate() || new Date(),
            tier: requestData.tier || 'casual',
            sharedInterests: requestData.sharedInterests || []
          };
        })
      );
      
      // Sort by timestamp, newest first
      pendingRequestsWithData.sort((a, b) => b.timestamp - a.timestamp);
      setPendingConnections(pendingRequestsWithData);
      setLoading(false);
    }, (error) => {
      console.error('Error getting pending connections:', error);
      Alert.alert('Error', 'Could not load connection requests');
      setLoading(false);
    });

    const unsubscribeConnections = onSnapshot(connectionsQuery, async (snapshot) => {
      console.log(`Received ${snapshot.docs.length} active connections`);
      
      // Get user data for each connection (the other user, not the current user)
      const connectionsWithData = await Promise.all(
        snapshot.docs.map(async (docSnapshot) => {
          const connectionData = docSnapshot.data();
          
          // Find the other user's ID (not the current user)
          const otherUserId = connectionData.senderId === user.uid 
            ? connectionData.receiverId 
            : connectionData.senderId;
          
          // Get other user's info
          const otherUserDoc = await getDocs(
            query(collection(db, 'users'), where('uid', '==', otherUserId))
          );
          
          let otherUserData = { name: 'Unknown User' };
          if (!otherUserDoc.empty) {
            otherUserData = otherUserDoc.docs[0].data();
          }
          
          return {
            id: docSnapshot.id,
            ...connectionData,
            otherUserId,
            otherUserName: otherUserData.name,
            otherUserPhotoURL: otherUserData.photoURL,
            timestamp: connectionData.timestamp?.toDate() || new Date(),
            tier: connectionData.tier || 'casual',
            sharedInterests: connectionData.sharedInterests || []
          };
        })
      );
      
      // Sort by tier and then by name
      connectionsWithData.sort((a, b) => {
        const tierRanking = {
          'soulmate': 5,
          'bestFriend': 4,
          'friend': 3,
          'buddy': 2,
          'casual': 1
        };
        
        // First sort by tier
        const tierDiff = tierRanking[b.tier] - tierRanking[a.tier];
        if (tierDiff !== 0) return tierDiff;
        
        // Then sort by name
        return a.otherUserName.localeCompare(b.otherUserName);
      });
      
      setConnections(connectionsWithData);
      setLoading(false);
    }, (error) => {
      console.error('Error getting connections:', error);
      Alert.alert('Error', 'Could not load connections');
      setLoading(false);
    });

    // Clean up listeners on unmount
    return () => {
      unsubscribePending();
      unsubscribeConnections();
    };
  }, [user?.uid]);

  // Handle accepting a connection request
  const handleAcceptConnection = async (connectionRequest) => {
    if (!user?.uid) return;
    
    try {
      setLoading(true);
      
      // Get the connection request reference
      const connectionRef = doc(db, 'connectionRequests', connectionRequest.id);
      
      // Update status to 'accepted'
      await updateDoc(connectionRef, {
        status: 'accepted',
        // Add participants array for easier querying
        participants: [connectionRequest.senderId, connectionRequest.receiverId],
        acceptedAt: serverTimestamp()
      });
      
      // Create a chat room for these users
      const chatRoomRef = await addDoc(collection(db, 'chatRooms'), {
        participants: [connectionRequest.senderId, connectionRequest.receiverId],
        connectionId: connectionRequest.id,
        createdAt: serverTimestamp(),
        lastMessage: null,
        lastMessageText: '',
        lastMessageTimestamp: null
      });
      
      // Update the connection with the chat room ID
      await updateDoc(connectionRef, {
        chatRoomId: chatRoomRef.id
      });
      
      // Add a system message to the chat
      await addDoc(collection(db, 'chatRooms', chatRoomRef.id, 'messages'), {
        text: 'You are now connected! Say hello to your new connection.',
        createdAt: serverTimestamp(),
        system: true
      });
      
      console.log('Connection accepted and chat room created:', chatRoomRef.id);
      
      // Alert after a slight delay to avoid UI glitches
      setTimeout(() => {
        Alert.alert('Success', 'Connection accepted!');
      }, 300);
      
    } catch (error) {
      console.error('Error accepting connection:', error);
      Alert.alert('Error', 'Failed to accept connection request');
    } finally {
      setLoading(false);
    }
  };

  // Handle declining a connection request
  const handleDeclineConnection = async (connectionId) => {
    if (!user?.uid) return;
    
    // Ask for confirmation before declining
    Alert.alert(
      'Decline Connection',
      'Are you sure you want to decline this connection request?',
      [
        {
          text: 'Cancel',
          style: 'cancel'
        },
        {
          text: 'Decline',
          style: 'destructive',
          onPress: async () => {
            try {
              setLoading(true);
              
              // Delete the connection request
              await deleteDoc(doc(db, 'connectionRequests', connectionId));
              
              console.log('Connection request declined');
              
              // Alert after a slight delay to avoid UI glitches
              setTimeout(() => {
                Alert.alert('Success', 'Connection request declined');
              }, 300);
              
            } catch (error) {
              console.error('Error declining connection:', error);
              Alert.alert('Error', 'Failed to decline connection request');
            } finally {
              setLoading(false);
            }
          }
        }
      ]
    );
  };

  // Handle viewing a chat with a connection
  const handleViewChat = (connection) => {
    // Navigate to the chat screen with the connection's chat room ID
    if (connection.chatRoomId) {
      router.push(`/chat/${connection.chatRoomId}?name=${encodeURIComponent(connection.otherUserName)}`);
    } else {
      Alert.alert('Error', 'Chat room not found for this connection');
    }
  };

  // Handle viewing a connection profile
  const handleViewProfile = (user) => {
    // Navigate to the user profile screen with the user's ID and other necessary data
    router.push({
      pathname: `/user-profile`,
      params: {
        id: user.otherUserId,
        name: user.otherUserName,
        tier: user.tier
      }
    });
  };

  // Render a connection request
  const renderConnectionRequest = ({ item }) => (
    <View style={styles.connectionCard}>
      <View style={styles.connectionHeader}>
        <View style={styles.userInfoContainer}>
          {item.senderPhotoURL ? (
            <Image source={{ uri: item.senderPhotoURL }} style={styles.avatar} />
          ) : (
            <View style={[
              styles.defaultAvatar,
              { backgroundColor: TIER_COLORS[item.tier]?.primary || TIER_COLORS.casual.primary }
            ]}>
              <Text style={styles.defaultAvatarText}>
                {(item.senderName || '?').charAt(0).toUpperCase()}
              </Text>
            </View>
          )}
          <View style={styles.nameContainer}>
            <Text style={styles.name}>{item.senderName}</Text>
            <View style={styles.timestampContainer}>
              <MaterialIcons name="schedule" size={12} color="#888" />
              <Text style={styles.timestamp}>
                {new Date(item.timestamp).toLocaleDateString(undefined, { 
                  month: 'short', 
                  day: 'numeric' 
                })}
              </Text>
            </View>
          </View>
        </View>
        <View style={styles.tierBadgeContainer}>
          <LinearGradient
            colors={TIER_COLORS[item.tier]?.gradient || TIER_COLORS.casual.gradient}
            style={styles.tierBadge}
            start={{ x: 0, y: 0 }}
            end={{ x: 1, y: 0 }}
          >
            <Text style={styles.tierBadgeText}>{getTierDisplayName(item.tier)}</Text>
          </LinearGradient>
        </View>
      </View>

      {item.sharedInterests && item.sharedInterests.length > 0 && (
        <View style={styles.interestsContainer}>
          <Text style={styles.interestsLabel}>Shared Interests:</Text>
          <View style={styles.interestTagsContainer}>
            {item.sharedInterests.map((interest, index) => (
              <View key={index} style={styles.interestTag}>
                <Text style={styles.interestTagText}>{interest}</Text>
              </View>
            ))}
          </View>
        </View>
      )}

      <View style={styles.actionButtonsContainer}>
        <TouchableOpacity
          style={styles.declineButton}
          onPress={() => handleDeclineConnection(item.id)}
          activeOpacity={0.7}
        >
          <Text style={styles.declineButtonText}>Decline</Text>
        </TouchableOpacity>

        <TouchableOpacity
          style={styles.acceptButton}
          onPress={() => handleAcceptConnection(item)}
          activeOpacity={0.7}
        >
          <LinearGradient
            colors={['#26de81', '#20bf6b']}
            style={styles.acceptButtonGradient}
            start={{ x: 0, y: 0 }}
            end={{ x: 1, y: 0 }}
          >
            <Text style={styles.acceptButtonText}>Accept</Text>
          </LinearGradient>
        </TouchableOpacity>
      </View>
    </View>
  );

  // Render an active connection
  const renderConnection = ({ item }) => (
    <View style={styles.connectionCard}>
      <TouchableOpacity 
        style={styles.userInfoRow}
        onPress={() => handleViewProfile(item)}
        activeOpacity={0.7}
      >
        <View style={styles.userInfoContainer}>
          {item.otherUserPhotoURL ? (
            <Image source={{ uri: item.otherUserPhotoURL }} style={styles.avatar} />
          ) : (
            <View style={[
              styles.defaultAvatar, 
              { backgroundColor: TIER_COLORS[item.tier]?.primary || TIER_COLORS.casual.primary }
            ]}>
              <Text style={styles.defaultAvatarText}>
                {(item.otherUserName || '?').charAt(0).toUpperCase()}
              </Text>
            </View>
          )}
          <View style={styles.nameContainer}>
            <Text style={styles.name}>{item.otherUserName}</Text>
            <View style={styles.tierSmallTag}>
              <LinearGradient
                colors={TIER_COLORS[item.tier]?.gradient || TIER_COLORS.casual.gradient}
                style={styles.tierSmallBadge}
                start={{ x: 0, y: 0 }}
                end={{ x: 1, y: 0 }}
              >
                <Text style={styles.tierSmallText}>{getTierDisplayName(item.tier)}</Text>
              </LinearGradient>
            </View>
          </View>
        </View>
        <MaterialIcons name="chevron-right" size={24} color="#ccc" style={styles.chevronIcon} />
      </TouchableOpacity>

      {item.sharedInterests && item.sharedInterests.length > 0 && (
        <View style={styles.interestsContainer}>
          <Text style={styles.interestsLabel}>Shared Interests:</Text>
          <View style={styles.interestTagsContainer}>
            {item.sharedInterests.slice(0, 3).map((interest, index) => (
              <View key={index} style={styles.interestTag}>
                <Text style={styles.interestTagText}>{interest}</Text>
              </View>
            ))}
            {item.sharedInterests.length > 3 && (
              <View style={styles.moreInterestsTag}>
                <Text style={styles.moreInterestsText}>+{item.sharedInterests.length - 3}</Text>
              </View>
            )}
          </View>
        </View>
      )}

      <TouchableOpacity
        style={styles.chatButton}
        onPress={() => handleViewChat(item)}
        activeOpacity={0.7}
      >
        <LinearGradient
          colors={['#6C5CE7', '#a29bfe']}
          style={styles.chatButtonGradient}
          start={{ x: 0, y: 0 }}
          end={{ x: 1, y: 0 }}
        >
          <Ionicons name="chatbubble-outline" size={16} color="#fff" />
          <Text style={styles.chatButtonText}>Message</Text>
        </LinearGradient>
      </TouchableOpacity>
    </View>
  );

  // Helper function to get display name for tier
  const getTierDisplayName = (tier) => {
    switch(tier) {
      case 'soulmate': return 'Soulmate';
      case 'bestFriend': return 'Best Friend';
      case 'friend': return 'Friend';
      case 'buddy': return 'Buddy';
      case 'casual': 
      default: return 'Casual';
    }
  };

  // Render empty state
  const renderEmptyState = () => {
    const isConnections = activeTab === 'connections';
    
    return (
      <View style={styles.emptyContainer}>
        <LinearGradient
          colors={isConnections ? ['#6C5CE7', '#a29bfe'] : ['#ff9f43', '#f39c12']}
          style={styles.emptyIconContainer}
          start={{ x: 0, y: 0 }}
          end={{ x: 1, y: 1 }}
        >
          <MaterialIcons 
            name={isConnections ? "people-outline" : "notifications-none"} 
            size={40} 
            color="#fff" 
          />
        </LinearGradient>
        
        <Text style={styles.emptyTitle}>
          {isConnections 
            ? 'No Connections Yet' 
            : 'No Pending Requests'}
        </Text>
        
        <Text style={styles.emptyText}>
          {isConnections 
            ? 'You don\'t have any connections yet. Explore the map to find people nearby!' 
            : 'You don\'t have any pending connection requests at the moment.'}
        </Text>
        
        {isConnections && (
          <TouchableOpacity 
            style={styles.exploreButton}
            onPress={() => router.push('/map')}
            activeOpacity={0.8}
          >
            <LinearGradient
              colors={['#6C5CE7', '#a29bfe']}
              style={styles.exploreButtonGradient}
              start={{ x: 0, y: 0 }}
              end={{ x: 1, y: 0 }}
            >
              <MaterialIcons name="explore" size={18} color="#fff" style={{ marginRight: 8 }} />
              <Text style={styles.exploreButtonText}>Explore Map</Text>
            </LinearGradient>
          </TouchableOpacity>
        )}
      </View>
    );
  };

  if (loading) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color="#6C5CE7" />
        <Text style={styles.loadingText}>Loading connections...</Text>
      </View>
    );
  }

  return (
    <View style={styles.container}>
      <StatusBar style="dark" />
      
      {/* Animated Header */}
      <Animated.View style={[styles.animatedHeader, { opacity: headerOpacity }]}>
        <Text style={styles.animatedHeaderText}>Connections</Text>
      </Animated.View>
      
      {/* Main Content */}
      <View style={styles.contentContainer}>
        {/* Tab Navigation */}
        <View style={styles.tabContainer}>
          <TouchableOpacity 
            style={[styles.tabButton, activeTab === 'connections' && styles.activeTabButton]}
            onPress={() => setActiveTab('connections')}
            activeOpacity={0.8}
          >
            <Text style={[
              styles.tabButtonText, 
              activeTab === 'connections' && styles.activeTabButtonText
            ]}>
              My Connections
            </Text>
          </TouchableOpacity>
          
          <TouchableOpacity 
            style={[styles.tabButton, activeTab === 'requests' && styles.activeTabButton]}
            onPress={() => setActiveTab('requests')}
            activeOpacity={0.8}
          >
            <Text style={[
              styles.tabButtonText, 
              activeTab === 'requests' && styles.activeTabButtonText
            ]}>
              Requests
            </Text>
            
            {pendingConnections.length > 0 && (
              <View style={styles.tabBadge}>
                <Text style={styles.tabBadgeText}>{pendingConnections.length}</Text>
              </View>
            )}
          </TouchableOpacity>
          
          <Animated.View 
            style={[
              styles.tabIndicator, 
              { 
                left: tabIndicatorPosition.interpolate({
                  inputRange: [0, 1],
                  outputRange: ['0%', '50%']
                }) 
              }
            ]} 
          />
        </View>
        
        {/* Content based on active tab */}
        {activeTab === 'connections' ? (
          connections.length > 0 ? (
            <Animated.FlatList
              data={connections}
              renderItem={renderConnection}
              keyExtractor={(item) => item.id}
              contentContainerStyle={styles.listContainer}
              showsVerticalScrollIndicator={false}
              onScroll={Animated.event(
                [{ nativeEvent: { contentOffset: { y: scrollY } } }],
                { useNativeDriver: true }
              )}
              scrollEventThrottle={16}
            />
          ) : (
            renderEmptyState()
          )
        ) : (
          pendingConnections.length > 0 ? (
            <Animated.FlatList
              data={pendingConnections}
              renderItem={renderConnectionRequest}
              keyExtractor={(item) => item.id}
              contentContainerStyle={styles.listContainer}
              showsVerticalScrollIndicator={false}
              onScroll={Animated.event(
                [{ nativeEvent: { contentOffset: { y: scrollY } } }],
                { useNativeDriver: true }
              )}
              scrollEventThrottle={16}
            />
          ) : (
            renderEmptyState()
          )
        )}
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
  },
  animatedHeader: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    height: Platform.OS === 'ios' ? 90 : 60,
    backgroundColor: '#fff',
    zIndex: 1000,
    justifyContent: 'flex-end',
    alignItems: 'center',
    paddingBottom: 10,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 3,
    elevation: 5,
  },
  animatedHeaderText: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#333',
  },
  contentContainer: {
    flex: 1,
    paddingTop: 16,
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#f5f5f5',
  },
  loadingText: {
    marginTop: 16,
    fontSize: 16,
    color: '#666',
  },
  tabContainer: {
    flexDirection: 'row',
    marginBottom: 16,
    paddingHorizontal: 16,
    position: 'relative',
  },
  tabButton: {
    flex: 1,
    height: 48,
    justifyContent: 'center',
    alignItems: 'center',
    position: 'relative',
  },
  activeTabButton: {
    borderBottomColor: '#6C5CE7',
  },
  tabButtonText: {
    fontSize: 15,
    fontWeight: '500',
    color: '#888',
  },
  activeTabButtonText: {
    fontWeight: '700',
    color: '#6C5CE7',
  },
  tabIndicator: {
    position: 'absolute',
    bottom: 0,
    width: '50%',
    height: 3,
    backgroundColor: '#6C5CE7',
    borderRadius: 3,
  },
  tabBadge: {
    position: 'absolute',
    right: -8,
    top: 8,
    backgroundColor: '#ff4757',
    minWidth: 18,
    height: 18,
    borderRadius: 9,
    justifyContent: 'center',
    alignItems: 'center',
    paddingHorizontal: 4,
  },
  tabBadgeText: {
    color: '#fff',
    fontSize: 10,
    fontWeight: 'bold',
  },
  listContainer: {
    paddingHorizontal: 16,
    paddingBottom: TAB_BAR_HEIGHT + 24,
  },
  connectionCard: {
    backgroundColor: '#fff',
    borderRadius: 16,
    marginBottom: 16,
    padding: CARD_PADDING,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.05,
    shadowRadius: 3,
    elevation: 2,
  },
  connectionHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 12,
  },
  userInfoRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 12,
  },
  userInfoContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    flex: 1,
  },
  chevronIcon: {
    marginLeft: 8,
  },
  avatar: {
    width: 50,
    height: 50,
    borderRadius: 25,
    marginRight: 12,
  },
  defaultAvatar: {
    width: 50,
    height: 50,
    borderRadius: 25,
    backgroundColor: '#a29bfe',
    justifyContent: 'center',
    alignItems: 'center',
    marginRight: 12,
  },
  defaultAvatarText: {
    fontSize: 20,
    fontWeight: 'bold',
    color: '#fff',
  },
  nameContainer: {
    flex: 1,
  },
  name: {
    fontSize: 18,
    fontWeight: '600',
    color: '#333',
    marginBottom: 4,
  },
  timestampContainer: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  timestamp: {
    fontSize: 12,
    color: '#888',
    marginLeft: 4,
  },
  tierBadgeContainer: {
    marginLeft: 8,
  },
  tierBadge: {
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 12,
  },
  tierBadgeText: {
    fontSize: 12,
    fontWeight: '600',
    color: '#fff',
  },
  tierSmallTag: {
    alignSelf: 'flex-start',
  },
  tierSmallBadge: {
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 8,
  },
  tierSmallText: {
    fontSize: 11,
    fontWeight: '600',
    color: '#fff',
  },
  interestsContainer: {
    marginTop: 8,
    marginBottom: 16,
  },
  interestsLabel: {
    fontSize: 14,
    fontWeight: '600',
    color: '#555',
    marginBottom: 8,
  },
  interestTagsContainer: {
    flexDirection: 'row',
    flexWrap: 'wrap',
  },
  interestTag: {
    backgroundColor: '#f3f0ff',
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 12,
    marginRight: 8,
    marginBottom: 8,
  },
  interestTagText: {
    fontSize: 12,
    color: '#6C5CE7',
    fontWeight: '500',
  },
  moreInterestsTag: {
    backgroundColor: '#f0f0f0',
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 12,
    marginBottom: 8,
  },
  moreInterestsText: {
    fontSize: 12,
    color: '#888',
    fontWeight: '500',
  },
  actionButtonsContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginTop: 8,
  },
  declineButton: {
    flex: 1,
    height: 46,
    justifyContent: 'center',
    alignItems: 'center',
    borderWidth: 1,
    borderColor: '#ddd',
    borderRadius: 12,
    marginRight: 8,
  },
  declineButtonText: {
    fontSize: 15,
    fontWeight: '600',
    color: '#ff4757',
  },
  acceptButton: {
    flex: 1,
    height: 46,
    borderRadius: 12,
    overflow: 'hidden',
  },
  acceptButtonGradient: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  acceptButtonText: {
    fontSize: 15,
    fontWeight: '600',
    color: '#fff',
  },
  chatButton: {
    alignSelf: 'stretch',
    height: 46,
    borderRadius: 12,
    overflow: 'hidden',
  },
  chatButtonGradient: {
    flex: 1,
    flexDirection: 'row',
    justifyContent: 'center',
    alignItems: 'center',
  },
  chatButtonText: {
    fontSize: 15,
    fontWeight: '600',
    color: '#fff',
    marginLeft: 8,
  },
  emptyContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    paddingHorizontal: 32,
    paddingBottom: TAB_BAR_HEIGHT + 40,
  },
  emptyIconContainer: {
    width: 80,
    height: 80,
    borderRadius: 40,
    justifyContent: 'center',
    alignItems: 'center',
    marginBottom: 16,
  },
  emptyTitle: {
    fontSize: 20,
    fontWeight: 'bold',
    color: '#333',
    marginBottom: 8,
  },
  emptyText: {
    fontSize: 16,
    color: '#666',
    textAlign: 'center',
    lineHeight: 24,
    marginBottom: 24,
  },
  exploreButton: {
    width: SCREEN_WIDTH * 0.6,
    height: 46,
    borderRadius: 23,
    overflow: 'hidden',
    shadowColor: '#6C5CE7',
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.2,
    shadowRadius: 8,
    elevation: 4,
  },
  exploreButtonGradient: {
    flex: 1,
    flexDirection: 'row',
    justifyContent: 'center',
    alignItems: 'center',
  },
  exploreButtonText: {
    color: '#fff',
    fontSize: 16,
    fontWeight: '600',
  },
});
</file>

<file path="app/(tabs)/profile/index.tsx">
import React, { useState, useRef } from 'react';
import { 
  StyleSheet, 
  View, 
  Text, 
  Image, 
  ScrollView, 
  TouchableOpacity, 
  Switch, 
  Alert, 
  ActivityIndicator, 
  Modal, 
  Dimensions,
  Animated,
  Platform,
} from 'react-native';
import { LinearGradient } from 'expo-linear-gradient';
import FontAwesome from '@expo/vector-icons/FontAwesome';
import MaterialIcons from '@expo/vector-icons/MaterialIcons';
import Ionicons from '@expo/vector-icons/Ionicons';
import { useAuth } from '@/contexts/AuthContext';
import { signOut } from '@firebase/auth';
import { doc, updateDoc } from '@firebase/firestore';
import { auth, db } from '@/config/firebase';
import { router } from 'expo-router';
import { StatusBar } from 'expo-status-bar';
import { BlurView } from 'expo-blur';
import { useSafeAreaInsets } from 'react-native-safe-area-context';

const { width: SCREEN_WIDTH } = Dimensions.get('window');
const CARD_PADDING = 20;

// Tabbed navigation menu height calculation
const TAB_BAR_HEIGHT = Platform.OS === 'ios' ? 83 : 70; // Height including safe area insets on iOS

export default function ProfileScreen() {
  const { userData, user, refreshUserData } = useAuth();
  const [locationVisible, setLocationVisible] = useState(userData?.location?.visible || false);
  const [loading, setLoading] = useState(false);
  const [selectedImageIndex, setSelectedImageIndex] = useState<number | null>(null);
  const [showImageModal, setShowImageModal] = useState(false);
  const insets = useSafeAreaInsets();
  
  // Animation values
  const scrollY = useRef(new Animated.Value(0)).current;
  const headerOpacity = scrollY.interpolate({
    inputRange: [0, 100],
    outputRange: [0, 1],
    extrapolate: 'clamp',
  });
  
  // Handle image tap
  const handleImageTap = (index: number) => {
    setSelectedImageIndex(index);
    setShowImageModal(true);
  };

  // Close image modal
  const closeImageModal = () => {
    setShowImageModal(false);
    setSelectedImageIndex(null);
  };
  
  // Handle logout
  const handleLogout = async () => {
    try {
      await auth.signOut();
      console.log('User signed out via profile screen');
    } catch (error) {
      console.error('Error signing out:', error);
      Alert.alert('Error', 'Failed to sign out. Please try again.');
    }
  };
  
  // Handle location visibility toggle
  const handleLocationToggle = async (value) => {
    if (!user?.uid) return;
    
    setLoading(true);
    try {
      const userRef = doc(db, 'users', user.uid);
      await updateDoc(userRef, {
        'location.visible': value
      });
      
      await refreshUserData();
      setLocationVisible(value);
    } catch (error) {
      console.error('Error updating location visibility:', error);
      Alert.alert('Error', 'Failed to update setting. Please try again.');
    } finally {
      setLoading(false);
    }
  };
  
  if (!userData) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color="#6C5CE7" />
      </View>
    );
  }
  
  return (
    <View style={styles.container}>
      <StatusBar style="dark" />
      
      {/* Animated Header */}
      <Animated.View style={[styles.animatedHeader, { opacity: headerOpacity }]}>
        <Text style={styles.animatedHeaderText}>{userData.name || 'Profile'}</Text>
      </Animated.View>
      
      <Animated.ScrollView 
        style={styles.scrollView}
        contentContainerStyle={[
          styles.scrollContent,
          // Add bottom padding to account for the tab bar
          { paddingBottom: TAB_BAR_HEIGHT + 20 }
        ]}
        showsVerticalScrollIndicator={false}
        onScroll={Animated.event(
          [{ nativeEvent: { contentOffset: { y: scrollY } } }],
          { useNativeDriver: true }
        )}
        scrollEventThrottle={16}
      >
        {/* Profile Header */}
        <View style={styles.profileHeader}>
          <LinearGradient
            colors={['#6C5CE7', '#a29bfe']}
            style={styles.headerGradient}
            start={{ x: 0, y: 0 }}
            end={{ x: 1, y: 1 }}
          />
          <View style={styles.profileImageContainer}>
            {userData.photoURL ? (
              <Image source={{ uri: userData.photoURL }} style={styles.profileImage} />
            ) : (
              <View style={styles.placeholderImage}>
                <FontAwesome name="user" size={60} color="#fff" />
              </View>
            )}
          </View>
          <Text style={styles.profileName}>{userData.name || 'Anonymous User'}</Text>
        </View>
        
        {/* About Me Card */}
        <View style={styles.card}>
          <View style={styles.cardHeader}>
            <MaterialIcons name="person" size={20} color="#6C5CE7" />
            <Text style={styles.cardTitle}>About Me</Text>
          </View>
          <Text style={styles.bioText}>
            {userData.bio || 'No bio yet. Tap Edit Profile to add a bio.'}
          </Text>
        </View>
        
        {/* Interests Card */}
        <View style={styles.card}>
          <View style={styles.cardHeader}>
            <MaterialIcons name="favorite" size={20} color="#6C5CE7" />
            <Text style={styles.cardTitle}>Interests</Text>
          </View>
          
          {userData.interests && userData.interests.length > 0 ? (
            <View style={styles.interestsContainer}>
              {userData.interests.map((interest, index) => (
                <View key={index} style={styles.interestTag}>
                  <Text style={styles.interestText}>{interest}</Text>
                </View>
              ))}
            </View>
          ) : (
            <Text style={styles.emptyText}>No interests added yet. Tap Edit Profile to add interests.</Text>
          )}
        </View>
        
        {/* Profile Images Card */}
        {userData.profileImages && userData.profileImages.length > 0 && (
          <View style={styles.card}>
            <View style={styles.cardHeader}>
              <MaterialIcons name="photo-library" size={20} color="#6C5CE7" />
              <Text style={styles.cardTitle}>Photos</Text>
            </View>
            <View style={styles.profileImagesGrid}>
              {userData.profileImages.map((imageUrl, index) => (
                <TouchableOpacity 
                  key={index} 
                  style={styles.gridImageContainer}
                  onPress={() => handleImageTap(index)}
                  activeOpacity={0.9}
                >
                  <Image 
                    source={{ uri: imageUrl }} 
                    style={styles.gridImage}
                    resizeMode="cover"
                  />
                  <LinearGradient
                    colors={['transparent', 'rgba(0,0,0,0.3)']}
                    style={styles.gridImageOverlay}
                  />
                </TouchableOpacity>
              ))}
            </View>
          </View>
        )}
        
        {/* Settings Card */}
        <View style={styles.card}>
          <View style={styles.cardHeader}>
            <MaterialIcons name="settings" size={20} color="#6C5CE7" />
            <Text style={styles.cardTitle}>Settings</Text>
          </View>
          <View style={styles.settingItem}>
            <View style={styles.settingLabelContainer}>
              <MaterialIcons name="location-on" size={20} color="#6C5CE7" />
              <Text style={styles.settingLabel}>Location Visibility</Text>
            </View>
            <Switch
              value={locationVisible}
              onValueChange={handleLocationToggle}
              trackColor={{ false: '#e0e0e0', true: '#a29bfe' }}
              thumbColor={locationVisible ? '#6C5CE7' : '#f4f3f4'}
              ios_backgroundColor="#e0e0e0"
              disabled={loading}
            />
          </View>
          <Text style={styles.settingDescription}>
            {locationVisible 
              ? 'Your location is visible to other users'
              : 'Your location is hidden from other users'}
          </Text>
        </View>
        
        {/* Action Buttons */}
        <TouchableOpacity 
          style={styles.editButton}
          onPress={() => router.push('/edit-profile')}
        >
          <LinearGradient
            colors={['#6C5CE7', '#a29bfe']}
            style={styles.buttonGradient}
            start={{ x: 0, y: 0 }}
            end={{ x: 1, y: 0 }}
          >
            <Text style={styles.editButtonText}>Edit Profile</Text>
          </LinearGradient>
        </TouchableOpacity>
        
        <TouchableOpacity 
          style={styles.logoutButton}
          onPress={handleLogout}
        >
          <Text style={styles.logoutButtonText}>Log Out</Text>
        </TouchableOpacity>
      </Animated.ScrollView>
      
      {/* Image Modal */}
      <Modal
        visible={showImageModal}
        transparent={true}
        animationType="fade"
        onRequestClose={closeImageModal}
      >
        <View style={styles.modalContainer}>
          <BlurView intensity={100} style={styles.modalBlur} tint="dark">
            <TouchableOpacity 
              style={styles.modalCloseButton}
              onPress={closeImageModal}
            >
              <Ionicons name="close-circle" size={36} color="#fff" />
            </TouchableOpacity>
            
            {selectedImageIndex !== null && userData?.profileImages?.[selectedImageIndex] && (
              <Image
                source={{ uri: userData.profileImages[selectedImageIndex] }}
                style={styles.fullScreenImage}
                resizeMode="contain"
              />
            )}
          </BlurView>
        </View>
      </Modal>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#f5f5f5',
  },
  scrollView: {
    flex: 1,
  },
  scrollContent: {
    paddingBottom: 40, // This will be overridden by the inline style
  },
  animatedHeader: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    height: Platform.OS === 'ios' ? 90 : 60,
    backgroundColor: '#fff',
    zIndex: 1000,
    justifyContent: 'flex-end',
    alignItems: 'center',
    paddingBottom: 10,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 3,
    elevation: 5,
  },
  animatedHeaderText: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#333',
  },
  profileHeader: {
    height: 200,
    alignItems: 'center',
    justifyContent: 'flex-end',
    position: 'relative',
    marginBottom: 60,
  },
  headerGradient: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    height: '100%',
  },
  profileImageContainer: {
    position: 'absolute',
    bottom: -50,
    borderRadius: 80,
    borderWidth: 5,
    borderColor: '#fff',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.2,
    shadowRadius: 5,
    elevation: 5,
    backgroundColor: '#fff',
  },
  profileImage: {
    width: 100,
    height: 100,
    borderRadius: 50,
  },
  placeholderImage: {
    width: 100,
    height: 100,
    borderRadius: 50,
    backgroundColor: '#a29bfe',
    justifyContent: 'center',
    alignItems: 'center',
  },
  profileName: {
    color: '#fff',
    fontSize: 24,
    fontWeight: 'bold',
    marginBottom: 60,
    textShadowColor: 'rgba(0, 0, 0, 0.3)',
    textShadowOffset: { width: 0, height: 1 },
    textShadowRadius: 3,
  },
  card: {
    backgroundColor: '#fff',
    borderRadius: 16,
    marginHorizontal: 16,
    marginBottom: 16,
    padding: CARD_PADDING,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.05,
    shadowRadius: 3,
    elevation: 3,
  },
  cardHeader: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 14,
  },
  cardTitle: {
    fontSize: 18,
    fontWeight: '600',
    color: '#333',
    marginLeft: 8,
  },
  bioText: {
    fontSize: 16,
    color: '#555',
    lineHeight: 24,
  },
  interestsContainer: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    marginHorizontal: -4,
  },
  interestTag: {
    backgroundColor: '#f3f0ff',
    paddingHorizontal: 14,
    paddingVertical: 8,
    borderRadius: 20,
    marginRight: 8,
    marginBottom: 8,
  },
  interestText: {
    fontSize: 14,
    color: '#6C5CE7',
    fontWeight: '500',
  },
  emptyText: {
    fontSize: 14,
    color: '#888',
    fontStyle: 'italic',
  },
  profileImagesGrid: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    marginHorizontal: -6,
  },
  gridImageContainer: {
    width: (SCREEN_WIDTH - 32 - CARD_PADDING * 2 - 12) / 3,
    aspectRatio: 1,
    padding: 6,
    position: 'relative',
  },
  gridImage: {
    width: '100%',
    height: '100%',
    borderRadius: 12,
  },
  gridImageOverlay: {
    position: 'absolute',
    bottom: 6,
    left: 6,
    right: 6,
    height: '50%',
    borderBottomLeftRadius: 12,
    borderBottomRightRadius: 12,
  },
  settingItem: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 8,
  },
  settingLabelContainer: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  settingLabel: {
    fontSize: 16,
    color: '#333',
    marginLeft: 8,
  },
  settingDescription: {
    fontSize: 14,
    color: '#888',
    marginTop: 4,
    marginLeft: 28,
  },
  editButton: {
    marginHorizontal: 16,
    marginTop: 8,
    borderRadius: 12,
    overflow: 'hidden',
    shadowColor: '#6C5CE7',
    shadowOffset: { width: 0, height: 3 },
    shadowOpacity: 0.2,
    shadowRadius: 4,
    elevation: 5,
  },
  buttonGradient: {
    paddingVertical: 16,
    alignItems: 'center',
  },
  editButtonText: {
    color: '#fff',
    fontSize: 16,
    fontWeight: 'bold',
  },
  logoutButton: {
    backgroundColor: '#fff',
    borderWidth: 1,
    borderColor: '#ddd',
    borderRadius: 12,
    paddingVertical: 16,
    alignItems: 'center',
    marginHorizontal: 16,
    marginTop: 12,
    marginBottom: 20,
  },
  logoutButtonText: {
    color: '#ff3b30',
    fontSize: 16,
    fontWeight: 'bold',
  },
  modalContainer: {
    flex: 1,
    backgroundColor: 'transparent',
  },
  modalBlur: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  modalCloseButton: {
    position: 'absolute',
    top: 40,
    right: 20,
    zIndex: 2,
    backgroundColor: 'rgba(0,0,0,0.3)',
    borderRadius: 20,
  },
  fullScreenImage: {
    width: SCREEN_WIDTH - 40,
    height: SCREEN_WIDTH - 40,
    borderRadius: 12,
  },
});
</file>

<file path="app/(tabs)/_layout.tsx">
import React, { useEffect } from 'react';
import FontAwesome from '@expo/vector-icons/FontAwesome';
import { Link, Tabs, usePathname, useRouter } from 'expo-router';
import { Pressable, Platform, StyleSheet, View } from 'react-native';
import { useAuth } from '@/contexts/AuthContext';
import LoadingScreen from '@/components/screens/LoadingScreen';
import FloatingTabBar from '@/components/navigation/FloatingTabBar';

import Colors from '@/constants/Colors';
import { useColorScheme } from '@/components/useColorScheme';
import { useClientOnlyValue } from '@/components/useClientOnlyValue';

export const unstable_settings = {
  // Set the initial route name
  initialRouteName: 'index',
};

export default function TabLayout() {
  const colorScheme = useColorScheme();
  const path = usePathname();
  const { user, loading } = useAuth();
  const router = useRouter();
  
  useEffect(() => {
    console.log('TabLayout rendered. Current path:', path);
    console.log('Platform:', Platform.OS);
    console.log('TabLayout auth state:', { user: user ? 'Authenticated' : 'Not authenticated', loading });
    
    if (!loading && !user) {
      console.log('TabLayout: No authenticated user, redirecting to login...');
      router.replace('/');
    }
  }, [path, user, loading]);

  // If still loading, show loading screen
  if (loading) {
    return <LoadingScreen message="Loading HiveSocial..." />;
  }
  
  // If no user and not loading, we're in process of redirecting to login
  if (!user) {
    return <LoadingScreen message="Redirecting to login..." />;
  }
  
  return (
    <View style={styles.container}>
      <Tabs
        screenOptions={{
          tabBarActiveTintColor: Colors[colorScheme ?? 'light'].tint,
          headerShown: useClientOnlyValue(false, true),
          tabBarStyle: { 
            display: 'none' // Hide the default tab bar since we're using the floating tab bar
          },
          headerStyle: {
            backgroundColor: Colors[colorScheme ?? 'light'].background,
            elevation: 0,
            shadowOpacity: 0,
            borderBottomWidth: 0,
          },
          headerTitleStyle: {
            fontWeight: '600',
            fontSize: 18,
          },
          headerTitleAlign: 'center',
          headerShadowVisible: false,
        }}
        tabBar={props => <FloatingTabBar {...props} />}
      >
        {/* The tab to hide - not visible in tab bar */}
        <Tabs.Screen
          name="index"
          options={{
            href: null,
          }}
          listeners={{
            tabPress: e => {
              console.log('Tabs index pressed');
            },
          }}
        />
        
        <Tabs.Screen
          name="map/index"
          options={{
            title: 'Map',
            tabBarIcon: ({ color, size, focused }) => (
              <FontAwesome name="map" size={size} color={color} />
            ),
          }}
          listeners={{
            tabPress: e => {
              console.log('Map tab pressed');
            },
            focus: () => {
              console.log('Map tab focused');
            },
          }}
        />
        
        <Tabs.Screen
          name="connections/index"
          options={{
            title: 'Connections',
            tabBarIcon: ({ color, size, focused }) => (
              <FontAwesome name="users" size={size} color={color} />
            ),
          }}
          listeners={{
            tabPress: e => {
              console.log('Connections tab pressed');
            },
          }}
        />
        
        <Tabs.Screen
          name="chat/index"
          options={{
            title: 'Chat',
            tabBarIcon: ({ color, size, focused }) => (
              <FontAwesome name="comments" size={size} color={color} />
            ),
          }}
          listeners={{
            tabPress: e => {
              console.log('Chat tab pressed');
            },
          }}
        />
        
        <Tabs.Screen
          name="profile/index"
          options={{
            title: 'Profile',
            tabBarIcon: ({ color, size, focused }) => (
              <FontAwesome name="user" size={size} color={color} />
            ),
            headerRight: () => (
              <Link href="/settings" asChild>
                <Pressable style={styles.headerButton}>
                  {({ pressed }) => (
                    <FontAwesome
                      name="cog"
                      size={22}
                      color={Colors[colorScheme ?? 'light'].text}
                      style={{ opacity: pressed ? 0.5 : 1 }}
                    />
                  )}
                </Pressable>
              </Link>
            ),
          }}
          listeners={{
            tabPress: e => {
              console.log('Profile tab pressed');
            },
          }}
        />
      </Tabs>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    margin: 0,
    padding: 0,
  },
  headerButton: {
    width: 40,
    height: 40,
    justifyContent: 'center',
    alignItems: 'center',
    marginRight: 8,
    borderRadius: 20,
  },
});
</file>

<file path="utils/presence.ts">
/**
 * Utility for managing user presence (online status) using Firebase
 */

import { useEffect, useRef } from 'react';
import { AppState, AppStateStatus, Platform } from 'react-native';
import { db, auth, database } from '@/config/firebase';
import { doc, setDoc, serverTimestamp, collection, onSnapshot } from '@firebase/firestore';
import { ref, set, onValue, onDisconnect as rtdbOnDisconnect } from '@firebase/database';
// NetInfo dependency is commented out since it wasn't successfully installed
// import NetInfo from '@react-native-community/netinfo';

/**
 * Custom hook to manage user online presence
 * This uses both Firestore and Realtime Database for reliable presence detection
 */
export function useUserPresence() {
  // Track if presence has been initialized
  const initialized = useRef(false);
  // Track app state
  const appState = useRef(AppState.currentState);
  // Track connectivity
  const isConnected = useRef(true);
  
  useEffect(() => {
    // Skip if already initialized
    if (initialized.current) return;
    
    const setupPresence = async () => {
      // Get current user
      const user = auth.currentUser;
      if (!user) {
        console.log('Cannot setup presence: No user is signed in');
        return;
      }
      
      try {
        console.log('Setting up presence system for user:', user.uid);
        
        // 1. Setup Firestore presence
        const userPresenceRef = doc(db, 'presence', user.uid);
        
        // Update Firestore with initial online status
        await setDoc(userPresenceRef, {
          online: true,
          lastSeen: serverTimestamp(),
          updatedAt: serverTimestamp()
        }, { merge: true });
        
        // 2. Setup Realtime Database presence (more reliable for disconnect detection)
        if (database) {
          try {
            // Initialize Realtime Database references
            const rtdbPresenceRef = ref(database, `online/${user.uid}`);
            const connectedRef = ref(database, '.info/connected');
            
            // Handle realtime database connection state
            const unsubscribe = onValue(connectedRef, async (snapshot) => {
              try {
                if (snapshot.val() === true) {
                  console.log('Connected to Firebase Realtime Database');
                  
                  // User is online in RTDB
                  await set(rtdbPresenceRef, {
                    online: true,
                    lastSeen: new Date().toISOString()
                  });
                  
                  // Setup disconnect handling for RTDB
                  rtdbOnDisconnect(rtdbPresenceRef).update({
                    online: false,
                    lastSeen: new Date().toISOString()
                  });
                  
                  // Update Firestore status as well
                  await setDoc(userPresenceRef, {
                    online: true,
                    lastSeen: serverTimestamp(),
                    updatedAt: serverTimestamp()
                  }, { merge: true });
                } else {
                  console.log('Disconnected from Firebase Realtime Database');
                }
              } catch (error) {
                console.error('Error in onValue callback:', error);
              }
            }, (error) => {
              console.error('onValue error:', error);
            });
            
            // Cleanup function to remove the listener when component unmounts
            return () => {
              unsubscribe();
            };
          } catch (error) {
            console.error('Error setting up RTDB presence:', error);
            
            // Fallback to Firestore only if RTDB fails
            console.log('Falling back to Firestore-only presence');
          }
        } else {
          console.error('Realtime Database not initialized. Using Firestore-only presence.');
        }
        
        // Mark as initialized
        initialized.current = true;
      } catch (error) {
        console.error('Error setting up presence:', error);
      }
    };

    // Setup app state change listener
    const handleAppStateChange = async (nextAppState: AppStateStatus) => {
      // Get current user
      const user = auth.currentUser;
      if (!user) return;
      
      console.log('App state changed from', appState.current, 'to', nextAppState);
      
      // App going to background or inactive
      if (
        appState.current.match(/active/) && 
        (nextAppState === 'background' || nextAppState === 'inactive')
      ) {
        console.log('App is going to background, updating presence');
        
        // Update presence status
        try {
          // Update in Firestore
          const userPresenceRef = doc(db, 'presence', user.uid);
          await setDoc(userPresenceRef, {
            online: false,
            lastSeen: serverTimestamp(),
            updatedAt: serverTimestamp()
          }, { merge: true });
          
          // Update in RTDB if available
          if (database) {
            try {
              const rtdbPresenceRef = ref(database, `online/${user.uid}`);
              await set(rtdbPresenceRef, {
                online: false,
                lastSeen: new Date().toISOString()
              });
            } catch (error) {
              console.error('RTDB update error on background:', error);
            }
          }
        } catch (error) {
          console.error('Error updating presence on app background:', error);
        }
      } 
      // App coming to foreground
      else if (
        (appState.current === 'background' || appState.current === 'inactive') && 
        nextAppState === 'active'
      ) {
        console.log('App is coming to foreground, updating presence');
        
        // Update presence status
        try {
          // Update in Firestore
          const userPresenceRef = doc(db, 'presence', user.uid);
          await setDoc(userPresenceRef, {
            online: true,
            lastSeen: serverTimestamp(),
            updatedAt: serverTimestamp()
          }, { merge: true });
          
          // Update in RTDB if available
          if (database) {
            try {
              const rtdbPresenceRef = ref(database, `online/${user.uid}`);
              await set(rtdbPresenceRef, {
                online: true,
                lastSeen: new Date().toISOString()
              });
              
              // Setup disconnect handler again
              rtdbOnDisconnect(rtdbPresenceRef).update({
                online: false,
                lastSeen: new Date().toISOString()
              });
            } catch (error) {
              console.error('RTDB update error on foreground:', error);
            }
          }
        } catch (error) {
          console.error('Error updating presence on app foreground:', error);
        }
      }
      
      // Save current state
      appState.current = nextAppState;
    };
    
    // NetInfo dependency is commented out since it wasn't successfully installed
    /*
    // Setup connectivity change listener
    const handleConnectivityChange = async ({ isConnected: connected }) => {
      // Get current user
      const user = auth.currentUser;
      if (!user) return;
      
      // Skip if connection status hasn't changed
      if (connected === isConnected.current) return;
      console.log('Connectivity changed. Connected:', connected);
      
      // Save new state
      isConnected.current = connected;
      
      // Update presence status
      try {
        // Update in Firestore
        const userPresenceRef = doc(db, 'presence', user.uid);
        
        // If reconnected
        if (connected) {
          console.log('Device reconnected, updating presence');
          
          await setDoc(userPresenceRef, {
            online: true,
            lastSeen: serverTimestamp(),
            updatedAt: serverTimestamp()
          }, { merge: true });
          
          // Update in RTDB if available
          if (database) {
            try {
              const rtdbPresenceRef = ref(database, `online/${user.uid}`);
              await set(rtdbPresenceRef, {
                online: true,
                lastSeen: new Date().toISOString()
              });
              
              // Setup disconnect handler again
              rtdbOnDisconnect(rtdbPresenceRef).update({
                online: false,
                lastSeen: new Date().toISOString()
              });
            } catch (error) {
              console.error('RTDB update error on reconnect:', error);
            }
          }
        } 
        // If disconnected
        else {
          console.log('Device disconnected, updating presence');
          
          await setDoc(userPresenceRef, {
            online: false,
            lastSeen: serverTimestamp(),
            updatedAt: serverTimestamp()
          }, { merge: true });
          
          // Update in RTDB if available
          if (database) {
            try {
              const rtdbPresenceRef = ref(database, `online/${user.uid}`);
              await set(rtdbPresenceRef, {
                online: false,
                lastSeen: new Date().toISOString()
              });
            } catch (error) {
              console.error('RTDB update error on disconnect:', error);
            }
          }
        }
      } catch (error) {
        console.error('Error updating presence on connectivity change:', error);
      }
    };
    */
    
    // Only setup presence for authenticated users
    if (auth.currentUser) {
      setupPresence();
      
      // Subscribe to app state changes
      const appStateSubscription = AppState.addEventListener('change', handleAppStateChange);
      
      // NetInfo subscription is commented out since the package wasn't successfully installed
      // const netInfoSubscription = NetInfo.addEventListener(handleConnectivityChange);
      
      // Cleanup
      return () => {
        appStateSubscription.remove();
        // netInfoSubscription();
      };
    }
  }, []);
}
</file>

<file path="package.json">
{
  "name": "hivesocial",
  "main": "expo-router/entry",
  "version": "1.0.0",
  "scripts": {
    "start": "expo start",
    "android": "expo start --android",
    "ios": "expo start --ios",
    "web": "expo start --web",
    "test": "jest --watchAll"
  },
  "jest": {
    "preset": "jest-expo"
  },
  "dependencies": {
    "@expo/vector-icons": "^14.1.0",
    "@react-native-firebase/app": "^22.1.0",
    "@react-navigation/native": "^7.1.6",
    "expo": "~53.0.9",
    "expo-font": "~13.3.1",
    "expo-linking": "~7.1.5",
    "expo-router": "~5.0.6",
    "expo-splash-screen": "~0.30.8",
    "expo-status-bar": "~2.2.3",
    "expo-system-ui": "~5.0.7",
    "expo-web-browser": "~14.1.6",
    "firebase": "^11.7.1",
    "react": "19.0.0",
    "react-dom": "19.0.0",
    "react-native": "0.79.2",
    "react-native-reanimated": "~3.17.4",
    "react-native-safe-area-context": "5.4.0",
    "react-native-screens": "~4.10.0",
    "react-native-web": "~0.20.0",
    "react-native-maps": "1.20.1",
    "expo-location": "~18.1.4",
    "@react-native-async-storage/async-storage": "2.1.2",
    "expo-image-picker": "~16.1.4",
    "expo-linear-gradient": "~14.1.4",
    "expo-blur": "~14.1.4"
  },
  "devDependencies": {
    "@babel/core": "^7.25.2",
    "@types/react": "~19.0.10",
    "jest": "^29.2.1",
    "jest-expo": "~53.0.5",
    "react-test-renderer": "19.0.0",
    "typescript": "~5.8.3"
  },
  "private": true
}
</file>

<file path="app/(tabs)/map/index.tsx">
import React, { useState, useEffect, useRef, useCallback, useMemo } from 'react';
import { 
  StyleSheet, 
  View, 
  Text, 
  ActivityIndicator, 
  TouchableOpacity, 
  Alert, 
  Platform, 
  Image, 
  Animated,
  Dimensions,
  Switch
} from 'react-native';
import MapView, { PROVIDER_GOOGLE, Marker, Circle, Callout } from 'react-native-maps';
import * as Location from 'expo-location';
import { 
  collection, 
  query, 
  where, 
  getDocs, 
  doc, 
  setDoc, 
  getDoc, 
  GeoPoint, 
  addDoc,
  serverTimestamp,
  deleteDoc,
  onSnapshot 
} from '@firebase/firestore';
import { db } from '@/config/firebase';
import { useAuth } from '@/contexts/AuthContext';
import FontAwesome from '@expo/vector-icons/FontAwesome';
import EnhancedUserMapMarker from '@/components/maps/EnhancedUserMapMarker';
import MarkerSpiderfier from '@/components/maps/MarkerSpiderfier';
import ProfileCard from '@/components/maps/ProfileCard';
import FilterDrawer from '@/components/maps/FilterDrawer';
import { router } from 'expo-router';
import { 
  getDistanceFromLatLonInMeters, 
  offsetOverlappingMarkers, 
  radiusToLatitudeDelta 
} from '@/utils/geospatial';
import { useUserPresence } from '@/utils/presence';
import { useSafeAreaInsets } from 'react-native-safe-area-context';

// Constants for location
const QUARTER_MILE_IN_METERS = 400; // 0.4 km (quarter mile)
const LOCATION_TASK_NAME = 'background-location-task';

// Constants for tier system
const TIER_THRESHOLDS = {
  SOULMATE: 15, // 15+ shared interests
  BEST_FRIEND: 8, // 8-14 shared interests
  FRIEND: 5, // 5-7 shared interests
  BUDDY: 3, // 3-4 shared interests
  CASUAL: 1, // 1-2 shared interests
};

// Get screen dimensions
const { width, height } = Dimensions.get('window');

// Tabbed navigation menu height calculation
const TAB_BAR_HEIGHT = Platform.OS === 'ios' ? 83 : 70; // Height including safe area insets on iOS

export default function MapScreen() {
  const { user, userData } = useAuth();
  const [location, setLocation] = useState(null);
  const [nearbyUsers, setNearbyUsers] = useState([]);
  const [filteredUsers, setFilteredUsers] = useState([]);
  const [errorMsg, setErrorMsg] = useState(null);
  const [loading, setLoading] = useState(true);
  const [refreshing, setRefreshing] = useState(false);
  const [selectedUser, setSelectedUser] = useState(null);
  const [showProfileCard, setShowProfileCard] = useState(false);
  
  // Filter drawer state
  const [showFilterDrawer, setShowFilterDrawer] = useState(false);
  const [filters, setFilters] = useState({
    selectedInterests: [],
    minSharedInterests: 1,
    onlineOnly: false
  });
  const [filtersActive, setFiltersActive] = useState(false);
  
  // Spiderfier state for handling overlapping markers
  const [spiderfiedMarkers, setSpiderfiedMarkers] = useState([]);
  const [spiderfierBaseCoordinate, setSpiderfierBaseCoordinate] = useState(null);
  const [showSpiderfier, setShowSpiderfier] = useState(false);
  
  // Location visibility state
  const [locationVisible, setLocationVisible] = useState(userData?.location?.visible || false);
  const [availableInterests, setAvailableInterests] = useState([]);
  
  // Animation refs
  const filterDrawerAnimation = useRef(new Animated.Value(0)).current;
  const controlsOpacity = useRef(new Animated.Value(1)).current;
  const controlsPosition = useRef(new Animated.Value(0)).current;
  
  // Map refs
  const mapRef = useRef(null);
  
  // Setup user presence
  useUserPresence();
  
  console.log('MapScreen rendering, user:', user ? 'Authenticated' : 'Not authenticated');
  console.log('Platform:', Platform.OS);

  // Setup initial load effect
  useEffect(() => {
    loadAvailableInterests();
  }, []);

  // Initial location setup
  useEffect(() => {
    console.log('MapScreen useEffect triggered');

    const setupLocation = async () => {
      console.log('Setting up location');
      let { status } = await Location.requestForegroundPermissionsAsync();
      if (status !== 'granted') {
        console.log('Location permission denied');
        setErrorMsg('Permission to access location was denied');
        setLoading(false);
        return;
      }

      try {
        console.log('Getting current position');
        // Get current location
        let location = await Location.getCurrentPositionAsync({
          accuracy: Location.Accuracy.Balanced
        });
        console.log('Location obtained:', location ? 'Yes' : 'No');
        setLocation(location);
        
        // Restore visibility setting from user data
        if (userData?.location?.visible !== undefined) {
          setLocationVisible(userData.location.visible);
        }
        
        // Save user location to Firebase
        if (user?.uid) {
          console.log('Saving location to Firebase');
          const userLocationRef = doc(db, 'locations', user.uid);
          await setDoc(userLocationRef, {
            uid: user.uid,
            location: new GeoPoint(
              location.coords.latitude,
              location.coords.longitude
            ),
            timestamp: new Date(),
            lastSeen: serverTimestamp(),
            visible: userData?.location?.visible || false
          }, { merge: true });
          
          // Fetch nearby users
          console.log('Fetching nearby users');
          await fetchNearbyUsers(location.coords.latitude, location.coords.longitude);
        } else {
          console.log('No user UID available, skipping Firebase update');
        }
        
        setLoading(false);
      } catch (error) {
        console.error('Error getting location:', error);
        setErrorMsg('Error getting location');
        setLoading(false);
      }
    };

    setupLocation();
  }, [user?.uid, userData?.location?.visible]);
  
  // Listen for real-time updates of online users
  useEffect(() => {
    if (!user?.uid || !location) return;
    
    console.log('Setting up presence listener');
    
    const presenceRef = collection(db, 'presence');
    const unsubscribe = onSnapshot(
      presenceRef,
      (snapshot) => {
        // Get current online users
        const onlineUsers = new Set();
        snapshot.forEach(doc => {
          const data = doc.data();
          if (data.online === true) {
            onlineUsers.add(doc.id);
          }
        });
        
        console.log(`Found ${onlineUsers.size} online users`);
        
        // Update our nearby users with online status
        setNearbyUsers(prevUsers => {
          const updatedUsers = prevUsers.map(user => ({
            ...user,
            online: onlineUsers.has(user.uid)
          }));
          
          // Apply filters to get filtered user list
          applyFilters(updatedUsers);
          
          return updatedUsers;
        });
      },
      (error) => {
        console.error('Error getting presence:', error);
      }
    );
    
    return () => unsubscribe();
  }, [location, user?.uid, filters]);
  
  // Monitor filter changes and apply them
  useEffect(() => {
    applyFilters(nearbyUsers);
    
    // Check if any filters are active
    const isActive = 
      filters.selectedInterests.length > 0 || 
      filters.minSharedInterests > 1 ||
      filters.onlineOnly;
    
    setFiltersActive(isActive);
  }, [filters, nearbyUsers]);
  
  // Animate controls when profile card visibility changes
  useEffect(() => {
    if (showProfileCard) {
      // Hide controls when profile card appears
      Animated.parallel([
        Animated.timing(controlsOpacity, {
          toValue: 0,
          duration: 200,
          useNativeDriver: true,
        }),
        Animated.timing(controlsPosition, {
          toValue: 50, // Move controls down/away
          duration: 250,
          useNativeDriver: true,
        })
      ]).start();
    } else {
      // Show controls when profile card disappears
      Animated.parallel([
        Animated.timing(controlsOpacity, {
          toValue: 1,
          duration: 250,
          useNativeDriver: true,
        }),
        Animated.timing(controlsPosition, {
          toValue: 0, // Return to original position
          duration: 200,
          useNativeDriver: true,
        })
      ]).start();
    }
  }, [showProfileCard]);
  
  // Load all available interests for filtering
  const loadAvailableInterests = async () => {
    try {
      // In a real app, this would be a Cloud Function or a dedicated interests collection
      // For now, we'll extract interests from all user profiles
      const usersRef = collection(db, 'users');
      const snapshot = await getDocs(usersRef);
      
      const allInterests = new Set();
      
      snapshot.forEach(doc => {
        const data = doc.data();
        if (data.interests && Array.isArray(data.interests)) {
          data.interests.forEach(interest => {
            allInterests.add(interest);
          });
        }
      });
      
      console.log(`Loaded ${allInterests.size} unique interests`);
      setAvailableInterests(Array.from(allInterests).sort());
    } catch (error) {
      console.error('Error loading interests:', error);
    }
  };
  
  // Apply filters to users
  const applyFilters = useCallback((users) => {
    if (!users || users.length === 0) {
      setFilteredUsers([]);
      return;
    }
    
    console.log('Applying filters:', {
      interestsCount: filters.selectedInterests.length,
      minShared: filters.minSharedInterests,
      onlineOnly: filters.onlineOnly
    });
    
    let filtered = [...users];
    
    // Filter by minimum shared interests
    if (filters.minSharedInterests > 1) {
      filtered = filtered.filter(user => user.sharedInterestsCount >= filters.minSharedInterests);
    }
    
    // Filter by specific interests
    if (filters.selectedInterests.length > 0) {
      filtered = filtered.filter(user => {
        if (!user.interests || !Array.isArray(user.interests)) return false;
        
        // Check if user has at least one of the selected interests
        return filters.selectedInterests.some(interest => 
          user.interests.includes(interest)
        );
      });
    }
    
    // Filter by online status
    if (filters.onlineOnly) {
      filtered = filtered.filter(user => user.online === true);
    }
    
    // Apply the offset algorithm to prevent overlapping markers
    const offsetUsers = offsetOverlappingMarkers(filtered);
    
    console.log(`Filtered from ${users.length} to ${filtered.length} users`);
    setFilteredUsers(offsetUsers);
  }, [filters]);
  
  // Calculate tier based on number of shared interests
  const calculateTier = (sharedInterestsCount) => {
    if (sharedInterestsCount >= TIER_THRESHOLDS.SOULMATE) return 'soulmate';
    if (sharedInterestsCount >= TIER_THRESHOLDS.BEST_FRIEND) return 'bestFriend';
    if (sharedInterestsCount >= TIER_THRESHOLDS.FRIEND) return 'friend';
    if (sharedInterestsCount >= TIER_THRESHOLDS.BUDDY) return 'buddy';
    if (sharedInterestsCount >= TIER_THRESHOLDS.CASUAL) return 'casual';
    return 'casual'; // Default tier
  };

  // Find shared interests between current user and another user
  const findSharedInterests = (userInterests, otherUserInterests) => {
    if (!userInterests || !otherUserInterests) return [];
    
    return userInterests.filter(interest => 
      otherUserInterests.includes(interest)
    );
  };

  // Function to fetch user profile data
  const fetchUserProfile = async (uid) => {
    try {
      console.log(`Fetching profile for user: ${uid}`);
      const userDocRef = doc(db, 'users', uid);
      const userDoc = await getDoc(userDocRef);
      if (userDoc.exists()) {
        const userData = userDoc.data();
        console.log(`Profile data for ${uid}:`, {
          name: userData.name || 'No name',
          hasPhoto: !!userData.photoURL,
          interestsCount: userData.interests?.length || 0
        });
        return userData;
      }
      console.log(`No profile found for user: ${uid}`);
      return null;
    } catch (error) {
      console.error(`Error fetching profile for user ${uid}:`, error);
      return null;
    }
  };

  // Handle marker press - now with support for detecting overlapping markers
  const handleMarkerPress = (user) => {
    console.log('Marker pressed, user data:', {
      uid: user.uid,
      name: user.name,
      position: `${user.latitude.toFixed(6)}, ${user.longitude.toFixed(6)}`,
      hasProfileImages: !!user.profileImages && Array.isArray(user.profileImages),
      profileImagesCount: user.profileImages?.length || 0,
      hasInterests: !!user.interests && Array.isArray(user.interests),
      interestsCount: user.interests?.length || 0,
      hasSharedInterests: !!user.sharedInterests && Array.isArray(user.sharedInterests),
      sharedInterestsCount: user.sharedInterests?.length || 0,
      online: user.online
    });
    
    // Check if this marker is part of a group of overlapping markers
    // We identify these by the originalCoordinateGroup property we set during offsetting
    if (user.originalCoordinateGroup && !showSpiderfier) {
      // Get all markers that share the same original coordinate group
      const markersInSameGroup = filteredUsers.filter(
        m => m.originalCoordinateGroup === user.originalCoordinateGroup
      );
      
      // If there are multiple markers in this group and they're not already spiderfied
      if (markersInSameGroup.length > 1) {
        // Set up the spiderfier
        setSpiderfiedMarkers(markersInSameGroup);
        setSpiderfierBaseCoordinate({
          latitude: parseFloat(user.originalCoordinateGroup.split('_')[0]),
          longitude: parseFloat(user.originalCoordinateGroup.split('_')[1])
        });
        setShowSpiderfier(true);
        return; // Don't show profile card yet
      }
    }
    
    // If not part of an overlapping group, or already spiderfied, show the profile card
    setSelectedUser(user);
    setShowProfileCard(true);
    
    // Close the spiderfier if it's open
    if (showSpiderfier) {
      closeSpiderfier();
    }
  };
  
  // Handle closing the spiderfier
  const handleCloseSpiderfier = () => {
    closeSpiderfier();
  };
  
  // Helper to close the spiderfier
  const closeSpiderfier = () => {
    setShowSpiderfier(false);
    setSpiderfiedMarkers([]);
    setSpiderfierBaseCoordinate(null);
  };

  // Handle profile card dismiss
  const handleDismissProfileCard = () => {
    setShowProfileCard(false);
    setTimeout(() => setSelectedUser(null), 300); // Delay clearing user to allow animation
    
    // Also close spiderfier if it's open
    if (showSpiderfier) {
      closeSpiderfier();
    }
  };

  // Handle starting a chat
  const handleStartChat = (uid) => {
    // First check if there's an existing chat room
    const selectedUser = nearbyUsers.find(u => u.uid === uid);
    if (!selectedUser) {
      Alert.alert('Error', 'User not found');
      return;
    }
    
    // Check if we have a connection with this user
    const checkConnection = async () => {
      try {
        const connectionRequestsRef = collection(db, 'connectionRequests');
        
        // Check both sent and received connections
        const sentQuery = query(
          connectionRequestsRef,
          where('senderId', '==', user.uid),
          where('receiverId', '==', uid),
          where('status', '==', 'accepted')
        );
        
        const receivedQuery = query(
          connectionRequestsRef,
          where('senderId', '==', uid),
          where('receiverId', '==', user.uid),
          where('status', '==', 'accepted')
        );
        
        const [sentResults, receivedResults] = await Promise.all([
          getDocs(sentQuery),
          getDocs(receivedQuery)
        ]);
        
        let chatRoomId = null;
        
        // Check if there's a chat room from either query
        if (!sentResults.empty) {
          const connectionData = sentResults.docs[0].data();
          chatRoomId = connectionData.chatRoomId;
        } else if (!receivedResults.empty) {
          const connectionData = receivedResults.docs[0].data();
          chatRoomId = connectionData.chatRoomId;
        }
        
        if (chatRoomId) {
          // Navigate to the chat screen
          router.push(`/chat/${chatRoomId}?name=${encodeURIComponent(selectedUser.name)}`);
        } else {
          Alert.alert('Error', 'No chat room found for this connection');
        }
      } catch (error) {
        console.error('Error checking connection:', error);
        Alert.alert('Error', 'Failed to find chat room');
      }
    };
    
    checkConnection();
    handleDismissProfileCard();
  };

  // Handle accepting an invitation
  const handleAcceptInvite = async (connectionId) => {
    try {
      if (!user?.uid) {
        Alert.alert('Error', 'You must be logged in to accept invitations');
        return;
      }
      
      console.log(`Accepting connection invitation ${connectionId}`);
      
      // Get the connection request reference
      const connectionRef = doc(db, 'connectionRequests', connectionId);
      const connectionDoc = await getDoc(connectionRef);
      
      if (!connectionDoc.exists()) {
        Alert.alert('Error', 'Connection request not found');
        return;
      }
      
      const connectionData = connectionDoc.data();
      
      // Update status to 'accepted'
      await setDoc(connectionRef, {
        ...connectionData,
        status: 'accepted',
        // Add participants array for easier querying
        participants: [connectionData.senderId, connectionData.receiverId],
        acceptedAt: serverTimestamp()
      }, { merge: true });
      
      // Create a chat room for these users with all necessary data
      const chatRoomRef = await addDoc(collection(db, 'chatRooms'), {
        participants: [connectionData.senderId, connectionData.receiverId],
        connectionId: connectionId,
        createdAt: serverTimestamp(),
        lastMessage: null,
        lastMessageText: '',
        lastMessageTimestamp: null
      });
      
      // Update the connection with the chat room ID
      await setDoc(connectionRef, {
        chatRoomId: chatRoomRef.id
      }, { merge: true });
      
      // Add a system message to the chat
      await addDoc(collection(db, 'chatRooms', chatRoomRef.id, 'messages'), {
        text: 'You are now connected! Say hello to your new connection.',
        createdAt: serverTimestamp(),
        system: true
      });
      
      Alert.alert('Success', 'Connection accepted!');
      handleDismissProfileCard();
      
    } catch (error) {
      console.error('Error accepting connection:', error);
      Alert.alert('Error', 'Failed to accept connection request');
    }
  };
  
  // Handle declining an invitation
  const handleDeclineInvite = async (connectionId) => {
    try {
      if (!user?.uid) {
        Alert.alert('Error', 'You must be logged in to decline invitations');
        return;
      }
      
      console.log(`Declining connection invitation ${connectionId}`);
      
      // Delete the connection request instead of just marking as declined
      // This matches the behavior in the connections tab
      const connectionRef = doc(db, 'connectionRequests', connectionId);
      await deleteDoc(connectionRef);
      
      Alert.alert('Success', 'Connection declined');
      handleDismissProfileCard();
      
    } catch (error) {
      console.error('Error declining connection:', error);
      Alert.alert('Error', 'Failed to decline connection request');
    }
  };

  // Handle sending an invitation
  const handleSendInvite = async (uid) => {
    // In a real app, send a connection invitation
    try {
      if (!user?.uid || uid === user.uid) {
        Alert.alert('Error', 'Cannot send invitation to yourself');
        return;
      }
      
      console.log(`Sending connection invitation to user ${uid}`);
      
      // Check if there's already a connection or pending request
      const connectionRequestsRef = collection(db, 'connectionRequests');
      
      // Check for existing requests in either direction
      const existingSentQuery = query(
        connectionRequestsRef,
        where('senderId', '==', user.uid),
        where('receiverId', '==', uid)
      );
      
      const existingReceivedQuery = query(
        connectionRequestsRef,
        where('senderId', '==', uid),
        where('receiverId', '==', user.uid)
      );
      
      const [sentResults, receivedResults] = await Promise.all([
        getDocs(existingSentQuery),
        getDocs(existingReceivedQuery)
      ]);
      
      if (!sentResults.empty) {
        // Already sent a request to this user
        Alert.alert('Connection Request', 'You have already sent a connection request to this user.');
        handleDismissProfileCard();
        return;
      }
      
      if (!receivedResults.empty) {
        // Already received a request from this user
        Alert.alert(
          'Connection Request',
          'This user has already sent you a connection request. Check your connections tab!',
          [{ text: 'OK', onPress: () => router.push('/connections') }]
        );
        handleDismissProfileCard();
        return;
      }
      
      // Find the selected user in nearbyUsers
      const selectedNearbyUser = nearbyUsers.find(u => u.uid === uid);
      if (!selectedNearbyUser) {
        Alert.alert('Error', 'User not found');
        return;
      }
      
      // Create a new connection request
      await addDoc(connectionRequestsRef, {
        senderId: user.uid,
        receiverId: uid,
        senderName: userData?.name || 'Anonymous User',
        status: 'pending',
        timestamp: serverTimestamp(),
        tier: selectedNearbyUser.tier,
        sharedInterests: selectedNearbyUser.sharedInterests || [],
        sharedInterestsCount: selectedNearbyUser.sharedInterestsCount || 0
      });
      
      Alert.alert('Success', 'Invitation sent! They will be notified of your request.');
      handleDismissProfileCard();
      
    } catch (error) {
      console.error('Error sending invitation:', error);
      Alert.alert('Error', 'Failed to send invitation. Please try again.');
    }
  };
  
  // Function to fetch nearby users
  const fetchNearbyUsers = async (latitude, longitude) => {
    if (!user?.uid) {
      console.log('Cannot fetch nearby users: No user UID');
      return;
    }
    
    try {
      // Don't set refreshing here to avoid clearing the existing markers while loading
      console.log('Fetching nearby users around', latitude, longitude);
      
      // Create a temporary array to collect new users
      const newUsers = [];
      
      // Get current user's profile to compare interests
      const currentUserProfile = await fetchUserProfile(user.uid);
      const currentUserInterests = currentUserProfile?.interests || [];
      
      console.log('Current user interests:', currentUserInterests);
      
      // Get presence data to determine who's online
      const presenceRef = collection(db, 'presence');
      const presenceSnapshot = await getDocs(presenceRef);
      const onlineUsers = new Set();
      
      presenceSnapshot.forEach(doc => {
        const data = doc.data();
        if (data.online === true) {
          onlineUsers.add(doc.id);
        }
      });
      
      console.log(`Found ${onlineUsers.size} online users`);
      
      // In a production app, you would use Firebase Geoqueries or a cloud function
      // For simplicity, we'll fetch all visible locations and filter client-side
      const locationsRef = collection(db, 'locations');
      const q = query(locationsRef, where('visible', '==', true));
      const querySnapshot = await getDocs(q);
      
      const users = [];
      const profilePromises = [];
      
      console.log(`Found ${querySnapshot.size} total location entries`);
      
      querySnapshot.forEach((doc) => {
        const data = doc.data();
        // Don't include current user
        if (data.uid !== user.uid && data.location) {
          // Calculate distance
          const distance = getDistanceFromLatLonInMeters(
            latitude,
            longitude,
            data.location.latitude,
            data.location.longitude
          );
          
          // Only include users within quarter mile
          if (distance <= QUARTER_MILE_IN_METERS) {
            console.log(`User ${data.uid} is within range: ${Math.round(distance)}m`);
            
            const userObj = {
              uid: data.uid,
              latitude: data.location.latitude,
              longitude: data.location.longitude,
              distance: Math.round(distance),
              photoURL: null,
              name: null,
              bio: null,
              interests: [],
              sharedInterests: [],
              sharedInterestsCount: 0,
              tier: 'casual', // Default tier
              online: onlineUsers.has(data.uid) // Check if user is online
            };
            
            users.push(userObj);
            
            // Fetch user profile data
            const profilePromise = fetchUserProfile(data.uid).then(profile => {
              if (profile) {
                console.log(`Setting profile data for user ${data.uid}`);
                
                // Log the photo URL for debugging
                if (profile.photoURL) {
                  console.log(`User ${data.uid} photo URL: ${profile.photoURL.substring(0, 50)}...`);
                  
                  // Ensure the photoURL is properly formed
                  let finalPhotoURL = profile.photoURL.trim();
                  
                  // Validate URL - add https:// if missing
                  if (!finalPhotoURL.startsWith('http')) {
                    finalPhotoURL = `https://${finalPhotoURL}`;
                  }
                  
                  // Add a cache-busting parameter to force reload on each run
                  const timestamp = new Date().getTime();
                  if (finalPhotoURL.includes('?')) {
                    finalPhotoURL += `&_cb=${timestamp}`;
                  } else {
                    finalPhotoURL += `?_cb=${timestamp}`;
                  }
                  
                  // Additional validation
                  try {
                    new URL(finalPhotoURL); // Test if it's a valid URL
                    
                    // Set the URL only after validation
                    userObj.photoURL = finalPhotoURL;
                    console.log(`Set User ${data.uid} photoURL: ${finalPhotoURL.substring(0, 30)}...`);
                    
                    // Pre-cache the image immediately
                    try {
                      console.log(`Pre-fetching image for ${data.uid}`);
                      Image.prefetch(finalPhotoURL)
                        .catch(prefetchError => {
                          console.error(`Prefetch error for ${data.uid}:`, prefetchError);
                        });
                    } catch (err) {
                      console.warn('Prefetch attempt failed:', err);
                    }
                  } catch (e) {
                    console.error(`Invalid URL for user ${data.uid}:`, e.message);
                    userObj.photoURL = null;
                  }
                } else {
                  console.log(`User ${data.uid} has no photo URL`);
                  userObj.photoURL = null;
                }
                
                userObj.name = profile.name || 'Anonymous User';
                userObj.bio = profile.bio || null;
                userObj.interests = profile.interests || [];
                
                // Load profile images if available
                if (profile.profileImages && Array.isArray(profile.profileImages)) {
                  userObj.profileImages = profile.profileImages;
                }
                
                // Calculate shared interests
                if (profile.interests && currentUserInterests.length > 0) {
                  userObj.sharedInterests = findSharedInterests(currentUserInterests, profile.interests);
                  userObj.sharedInterestsCount = userObj.sharedInterests.length;
                  // Using a safer type casting approach
                  const tierValue = calculateTier(userObj.sharedInterestsCount);
                  userObj.tier = tierValue;
                }
                
                console.log(`User ${data.uid} profile:`, {
                  name: userObj.name,
                  hasPhoto: !!userObj.photoURL,
                  photoURL: userObj.photoURL ? 'exists' : 'missing',
                  sharedInterests: userObj.sharedInterestsCount,
                  tier: userObj.tier
                });
              }
            });
            
            profilePromises.push(profilePromise);
          } else {
            console.log(`User ${data.uid} is out of range: ${Math.round(distance)}m`);
          }
        } else if (data.uid === user.uid) {
          console.log('Skipping current user location');
        } else {
          console.log('Skipping user with no location data');
        }
      });
      
      // Wait for all profile data to be fetched
      console.log(`Waiting for ${profilePromises.length} profile fetch operations to complete...`);
      await Promise.all(profilePromises);
      
      // Sort users by tier first (highest tier first) and then by distance (closest first)
      const tierRanking = {
        'soulmate': 5,
        'bestFriend': 4,
        'friend': 3,
        'buddy': 2,
        'casual': 1
      };
      
      users.sort((a, b) => {
        // Compare tiers first
        const tierDiff = tierRanking[b.tier] - tierRanking[a.tier];
        
        if (tierDiff !== 0) {
          return tierDiff; // Sort by tier if tiers are different
        }
        
        // If tiers are the same, sort by distance
        return a.distance - b.distance;
      });
      
      console.log('All profile data fetched and sorted. Nearby users with profiles:', users.map(u => ({
        uid: u.uid,
        name: u.name,
        tier: u.tier,
        sharedInterests: u.sharedInterestsCount
      })));
      
      // Apply offset algorithm to prevent overlapping markers
      const offsetUsers = offsetOverlappingMarkers(users);
      
      // Update the state
      setNearbyUsers(offsetUsers);
      
      // Apply current filters
      applyFilters(offsetUsers);
    } catch (error) {
      console.error('Error fetching nearby users:', error);
      Alert.alert('Error', 'Failed to fetch nearby users.');
    } finally {
      setRefreshing(false);
    }
  };
  
  // Toggle location visibility
  const toggleLocationVisibility = async () => {
    try {
      if (!user?.uid) return;
      
      const newVisibility = !locationVisible;
      console.log(`Toggling location visibility to: ${newVisibility}`);
      
      // Update local state
      setLocationVisible(newVisibility);
      
      // Update in Firestore - user profile
      const userDocRef = doc(db, 'users', user.uid);
      await setDoc(userDocRef, {
        location: {
          visible: newVisibility
        }
      }, { merge: true });
      
      // Update in Firestore - locations collection
      const locationDocRef = doc(db, 'locations', user.uid);
      await setDoc(locationDocRef, {
        visible: newVisibility
      }, { merge: true });
      
      console.log('Location visibility updated in Firebase');
    } catch (error) {
      console.error('Error toggling location visibility:', error);
      // Revert local state on error
      setLocationVisible(!locationVisible);
      Alert.alert('Error', 'Failed to update location visibility.');
    }
  };
  
  // Open/close filter drawer
  const toggleFilterDrawer = () => {
    // Store current state for animation
    const isVisible = !showFilterDrawer;
    
    // Update state immediately
    setShowFilterDrawer(isVisible);
    
    // Animate drawer
    Animated.timing(filterDrawerAnimation, {
      toValue: isVisible ? 0 : -width,
      duration: 300,
      useNativeDriver: true,
    }).start();
  };
  // Handle filter changes
  const handleInterestToggle = (interest) => {
    setFilters(prev => {
      const updatedInterests = [...prev.selectedInterests];
      const index = updatedInterests.indexOf(interest);
      
      if (index === -1) {
        // Add the interest
        updatedInterests.push(interest);
      } else {
        // Remove the interest
        updatedInterests.splice(index, 1);
      }
      
      return {
        ...prev,
        selectedInterests: updatedInterests
      };
    });
  };
  
  // Handle minimum shared interests change
  const handleMinSharedInterestsChange = (value) => {
    setFilters(prev => ({
      ...prev,
      minSharedInterests: value
    }));
  };
  
  // Handle online only toggle
  const handleOnlineOnlyToggle = (value) => {
    setFilters(prev => ({
      ...prev,
      onlineOnly: value
    }));
  };
  
  // Function to get safe area insets
  const getSafeAreaInsets = () => {
    // On iOS, the status bar height is typically around 44pt
    // On Android, it varies, but we can use a default value
    const statusBarHeight = Platform.OS === 'ios' ? 44 : 24;
    
    // Use the TAB_BAR_HEIGHT constant for the bottom inset
    return {
      top: statusBarHeight,
      bottom: TAB_BAR_HEIGHT
    };
  };

  // Refresh location and nearby users
  const handleRefresh = async () => {
    if (loading || refreshing) return;
    
    try {
      setRefreshing(true);
      console.log('Refreshing location');
      let location = await Location.getCurrentPositionAsync({
        accuracy: Location.Accuracy.Balanced
      });
      setLocation(location);
      
      // Save updated location to Firebase
      if (user?.uid) {
        console.log('Updating location in Firebase');
        const userLocationRef = doc(db, 'locations', user.uid);
        await setDoc(userLocationRef, {
          uid: user.uid,
          location: new GeoPoint(
            location.coords.latitude,
            location.coords.longitude
          ),
          timestamp: new Date(),
          visible: locationVisible,
          lastSeen: serverTimestamp()
        }, { merge: true });
        
        // Fetch nearby users
        await fetchNearbyUsers(location.coords.latitude, location.coords.longitude);
      }
    } catch (error) {
      console.error('Error refreshing location:', error);
      Alert.alert('Error', 'Failed to refresh location.');
    } finally {
      setRefreshing(false);
    }
  };

  if (loading) {
    console.log('MapScreen showing loading state');
    return (
      <View style={styles.container}>
        <ActivityIndicator size="large" color="#0000ff" />
        <Text style={styles.paragraph}>Loading map...</Text>
      </View>
    );
  }

  if (errorMsg) {
    console.log('MapScreen showing error state:', errorMsg);
    return (
      <View style={styles.container}>
        <Text style={styles.paragraph}>{errorMsg}</Text>
      </View>
    );
  }

  console.log('MapScreen rendering map');
  return (
    <View style={styles.container}>
      {location ? (
        <>
          <MapView
            ref={mapRef}
            provider={PROVIDER_GOOGLE}
            style={styles.map}
            initialRegion={{
              latitude: location.coords.latitude,
              longitude: location.coords.longitude,
              latitudeDelta: 0.01,
              longitudeDelta: 0.01,
            }}
            showsUserLocation={true}
            showsMyLocationButton={true}
            cacheEnabled={Platform.OS === 'android'}
            loadingEnabled={true}
            loadingBackgroundColor="#F5F5F5"
            loadingIndicatorColor="#007bff"
            onPress={() => {
              // Close spiderfier when map is tapped
              if (showSpiderfier) {
                closeSpiderfier();
              }
            }}
          >
            {/* Quarter mile radius circle */}
            <Circle
              center={{
                latitude: location.coords.latitude,
                longitude: location.coords.longitude,
              }}
              radius={QUARTER_MILE_IN_METERS}
              fillColor="rgba(0, 123, 255, 0.1)"
              strokeColor="rgba(0, 123, 255, 0.5)"
              strokeWidth={1}
            />
            
            {/* Nearby users markers - Using filtered users */}
            {!showSpiderfier && filteredUsers.map((nearbyUser, index) => {
              if (nearbyUser.photoURL) {
                console.log(`Rendering marker for user ${nearbyUser.uid} - profile image available`);
              }
              
              // Use a stable key combining ID and coordinates to avoid remounts
              const markerKey = `marker-${nearbyUser.uid || index}-${nearbyUser.latitude.toFixed(6)}-${nearbyUser.longitude.toFixed(6)}`;
                
              return (
                <Marker
                  key={markerKey}
                  coordinate={{
                    latitude: nearbyUser.latitude,
                    longitude: nearbyUser.longitude,
                  }}
                  tracksViewChanges={true} // Set to true initially to ensure image loads
                  onPress={() => handleMarkerPress(nearbyUser)}
                >
                  <EnhancedUserMapMarker
                    photoURL={nearbyUser.photoURL}
                    distance={nearbyUser.distance}
                    name={nearbyUser.name}
                    tier={nearbyUser.tier}
                    sharedInterestsCount={nearbyUser.sharedInterestsCount}
                    online={nearbyUser.online}
                  />
                </Marker>
              );
            })}
            
            {/* Spiderfier component for showing overlapping markers */}
            {showSpiderfier && spiderfiedMarkers.length > 0 && spiderfierBaseCoordinate && (
              <MarkerSpiderfier
                markers={spiderfiedMarkers}
                baseCoordinate={spiderfierBaseCoordinate}
                onMarkerPress={handleMarkerPress}
                onClose={handleCloseSpiderfier}
              />
            )}
          </MapView>
          
          {/* Filter Drawer */}
          <FilterDrawer
            visible={showFilterDrawer}
            onClose={toggleFilterDrawer}
            filters={filters}
            allInterests={availableInterests}
            onInterestToggle={handleInterestToggle}
            onMinSharedInterestsChange={handleMinSharedInterestsChange}
            onOnlineOnlyToggle={handleOnlineOnlyToggle}
            drawerAnimation={filterDrawerAnimation}
          />
          
          {/* Top control buttons - position changes when profile card is visible */}
          <Animated.View 
            style={[
              styles.topButtonsContainer, 
              { 
                top: getSafeAreaInsets().top + 10,
                right: 16,
                opacity: controlsOpacity,
                transform: [
                  { translateY: controlsPosition },
                  { scale: Animated.subtract(1, Animated.multiply(0.2, Animated.divide(controlsPosition, 50))) }
                ]
              }
            ]}
          >
            {/* Refresh button */}
            <TouchableOpacity 
              style={styles.topButton}
              onPress={handleRefresh}
              disabled={refreshing}
            >
              {refreshing ? (
                <ActivityIndicator color="#fff" size="small" />
              ) : (
                <FontAwesome name="refresh" size={20} color="#fff" />
              )}
            </TouchableOpacity>
            
            {/* Filter button */}
            <TouchableOpacity 
              style={[
                styles.topButton, 
                filtersActive && styles.topButtonActive
              ]}
              onPress={toggleFilterDrawer}
            >
              <FontAwesome name="filter" size={20} color="#fff" />
            </TouchableOpacity>
            
            {/* Visibility toggle switch */}
            <View style={styles.switchContainer}>
              <Switch
                value={locationVisible}
                onValueChange={toggleLocationVisibility}
                trackColor={{ false: "#F44336", true: "#4CAF50" }}
                thumbColor="#ffffff"
                ios_backgroundColor="#F44336"
              />
            </View>
          </Animated.View>
          
          {/* Information panel - hide when profile card is visible */}
          <Animated.View 
            style={[
              styles.infoPanel, 
              { 
                bottom: TAB_BAR_HEIGHT + 16,
                opacity: controlsOpacity,
                transform: [
                  { translateY: controlsPosition }
                ]
              }
            ]}
          >
            <Text style={styles.infoTitle}>Nearby Users</Text>
            <Text style={styles.infoText}>
              {filteredUsers.length > 0 
                ? `${filteredUsers.length} users nearby`
                : filtersActive
                  ? 'No users match your current filters'
                  : 'No users nearby at the moment'}
            </Text>
            
            {!locationVisible && (
              <Text style={styles.warningText}>
                Your location is currently hidden. Others can't see you on the map.
              </Text>
            )}
            
            {filtersActive && (
              <Text style={styles.filterText}>
                Filters active: {
                  [
                    filters.minSharedInterests > 1 ? `Min ${filters.minSharedInterests} shared interests` : '',
                    filters.selectedInterests.length > 0 ? `${filters.selectedInterests.length} interests selected` : '',
                    filters.onlineOnly ? 'Online only' : ''
                  ].filter(Boolean).join(', ')
                }
              </Text>
            )}
          </Animated.View>
          
          {/* Profile card modal */}
          {showProfileCard && selectedUser && (
            <ProfileCard
              uid={selectedUser.uid || ''}
              name={selectedUser.name || 'User'}
              bio={selectedUser.bio || ''}
              photoURL={selectedUser.photoURL || undefined}
              profileImages={selectedUser.profileImages || []}
              interests={selectedUser.interests || []}
              sharedInterests={selectedUser.sharedInterests || []}
              tier={selectedUser.tier || 'casual'}
              distance={selectedUser.distance || 0}
              online={selectedUser.online || false}
              onDismiss={handleDismissProfileCard}
              onStartChat={handleStartChat}
              onInvite={handleSendInvite}
              onAcceptInvite={handleAcceptInvite}
              onDeclineInvite={handleDeclineInvite}
            />
          )}
        </>
      ) : (
        <Text style={styles.paragraph}>Waiting for location...</Text>
      )}
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  paragraph: {
    margin: 24,
    fontSize: 18,
    textAlign: 'center',
  },
  map: {
    width: '100%',
    height: '100%',
  },
  topButtonsContainer: {
    position: 'absolute',
    right: 16,
    zIndex: 10,
  },
  topButton: {
    backgroundColor: '#007bff',
    width: 50,
    height: 50,
    borderRadius: 25,
    justifyContent: 'center',
    alignItems: 'center',
    marginBottom: 10,
    elevation: 4,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.2,
    shadowRadius: 2,
  },
  topButtonActive: {
    backgroundColor: '#ff6600', // Orange color for active filter
  },
  visibleButton: {
    backgroundColor: '#4CAF50', // Green for visible
  },
  hiddenButton: {
    backgroundColor: '#F44336', // Red for hidden
  },
  switchContainer: {
    backgroundColor: 'rgba(255, 255, 255, 0.9)',
    borderRadius: 20,
    padding: 5,
    marginTop: 10,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.2,
    shadowRadius: 2,
    elevation: 3,
  },
  infoPanel: {
    position: 'absolute',
    left: 16,
    right: 16,
    backgroundColor: 'white',
    borderRadius: 8,
    padding: 16,
    elevation: 4,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.2,
    shadowRadius: 2,
  },
  infoTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    marginBottom: 8,
  },
  infoText: {
    fontSize: 14,
    color: '#666',
  },
  warningText: {
    fontSize: 14,
    color: '#ff6347',
    marginTop: 8,
    fontStyle: 'italic',
  },
  filterText: {
    fontSize: 14,
    color: '#ff6600',
    marginTop: 8,
    fontStyle: 'italic',
  },
  // Spiderfier styles
  spiderMarkerContainer: {
    alignItems: 'center',
    justifyContent: 'center',
  },
  spiderLine: {
    backgroundColor: 'rgba(0, 123, 255, 0.6)',
    height: 2,
  },
  spiderCloseButton: {
    backgroundColor: 'rgba(255, 0, 0, 0.8)',
    width: 28,
    height: 28,
    borderRadius: 14,
    justifyContent: 'center',
    alignItems: 'center',
    borderWidth: 2,
    borderColor: 'white',
  },
  spiderCloseText: {
    color: 'white',
    fontSize: 18,
    fontWeight: 'bold',
    textAlign: 'center',
  },
});
</file>

<file path="config/firebase.js">
// Import the functions you need from the SDKs
import { initializeApp, getApps, getApp } from '@firebase/app';
import { getAuth, initializeAuth, getReactNativePersistence } from '@firebase/auth';
import { getFirestore } from '@firebase/firestore';
import { getStorage } from '@firebase/storage';
import { getDatabase } from '@firebase/database';
import AsyncStorage from '@react-native-async-storage/async-storage';

// Your web app's Firebase configuration
const firebaseConfig = {
  apiKey: "AIzaSyDNSpecRefaNuzu4Hu0HeJGlCdsmLYRZWg",
  authDomain: "hivesocial-75456.firebaseapp.com",
  projectId: "hivesocial-75456",
  storageBucket: "hivesocial-75456.firebasestorage.app",
  messagingSenderId: "224390534339",
  appId: "1:224390534339:web:8b5bab677e40965365fe76",
  measurementId: "G-TNSRWTTRQ8",
  databaseURL: "https://hivesocial-75456-default-rtdb.firebaseio.com"
};

// Initialize Firebase
let app;
let auth;
let db;
let storage;
let database;

// Check if app is already initialized
if (getApps().length === 0) {
  console.log('Initializing Firebase app and authentication...');
  
  // Initialize the Firebase app first
  app = initializeApp(firebaseConfig);
  
  // Initialize auth with AsyncStorage for persistence
  auth = initializeAuth(app, {
    persistence: getReactNativePersistence(AsyncStorage)
  });
  
  // Initialize Firestore and Storage
  db = getFirestore(app);
  storage = getStorage(app);
  
  // Initialize Realtime Database explicitly with URL
  console.log('Initializing Realtime Database with URL:', firebaseConfig.databaseURL);
  database = getDatabase(app);
  
  console.log('Firebase initialized with persistence');
} else {
  console.log('Using existing Firebase instance');
  app = getApp();
  auth = getAuth(app);
  db = getFirestore(app);
  storage = getStorage(app);
  
  // Get the database with the same URL to ensure consistency
  console.log('Getting existing Realtime Database instance');
  database = getDatabase(app);
}

export { app, auth, db, storage, database };
</file>

</files>
